{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/module/Event.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__normalizations",
    "__hooks",
    "on",
    "off",
    "__isReady",
    "ready",
    "callback",
    "document",
    "readyState",
    "window",
    "setTimeout",
    "onWindowLoad",
    "module",
    "Event",
    "qxWeb",
    "wrappedCallback",
    "env",
    "get",
    "bom",
    "addNativeListener",
    "timer",
    "documentElement",
    "doScroll",
    "body",
    "error",
    "$registerEventNormalization",
    "types",
    "normalizer",
    "lang",
    "Type",
    "isArray",
    "registry",
    "i",
    "l",
    "length",
    "type",
    "isFunction",
    "push",
    "$unregisterEventNormalization",
    "Array",
    "remove",
    "$getEventNormalizationRegistry",
    "$registerEventHook",
    "registerHook",
    "unregisterHook",
    "onHooks",
    "offHooks",
    "$unregisterEventHook",
    "$getEventHookRegistry",
    "members",
    "listener",
    "context",
    "useCapture",
    "el",
    "ctx",
    "hooks",
    "typeHooks",
    "concat",
    "j",
    "m",
    "bound",
    "event",
    "normalizations",
    "x",
    "y",
    "apply",
    "bind",
    "original",
    "$$emitter",
    "Emitter",
    "$$lastlistenerId",
    "getEntryById",
    "__listener",
    "__ctx",
    "removeAll",
    "listenerType",
    "id",
    "storedListener",
    "hasStoredContext",
    "storedContext",
    "result",
    "removeNativeListener",
    "k",
    "allOff",
    "offById",
    "entry",
    "name",
    "emit",
    "data",
    "once",
    "self",
    "wrappedListener",
    "call",
    "hasListener",
    "getListeners",
    "attachedListeners",
    "undefined",
    "copyEventsTo",
    "target",
    "source",
    "targetCopy",
    "descendants",
    "getElementsByTagName",
    "forEach",
    "storage",
    "hover",
    "callbackIn",
    "callbackOut",
    "onMatchTarget",
    "eventType",
    "e",
    "eventTarget",
    "getTarget",
    "is",
    "object",
    "clone",
    "targetToMatch",
    "find",
    "isChildOf",
    "matchTarget",
    "$$matchTargetInfo",
    "offMatchTarget",
    "infos",
    "splice",
    "defer",
    "$attachAll",
    "$attachStatic"
  ],
  "mappings": "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",
  "file": "Event.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (wittemann)\n     * Daniel Wagner (danielwagner)\n\n************************************************************************ */\n\n/**\n * Support for native and custom events.\n *\n * @require(qx.module.Polyfill)\n * @require(qx.module.Environment)\n * @use(qx.module.event.PointerHandler)\n * @group (Core)\n */\nqx.Bootstrap.define(\"qx.module.Event\", {\n  statics :\n  {\n    /**\n     * Event normalization registry\n     *\n     * @internal\n     */\n    __normalizations : {},\n\n    /**\n     * Registry of event hooks\n     * @internal\n     */\n    __hooks : {\n      on : {},\n      off : {}\n    },\n\n\n\n    __isReady : false,\n\n\n    /**\n     * Executes the given function once the document is ready.\n     *\n     * @attachStatic {qxWeb}\n     * @param callback {Function} callback function\n     */\n    ready : function(callback) {\n      // DOM is already ready\n      if (document.readyState === \"complete\") {\n        window.setTimeout(callback, 1);\n        return;\n      }\n\n      // listen for the load event so the callback is executed no matter what\n      var onWindowLoad = function()\n      {\n        qx.module.Event.__isReady = true;\n        callback();\n      };\n\n      qxWeb(window).on(\"load\", onWindowLoad);\n\n      var wrappedCallback = function() {\n        qxWeb(window).off(\"load\", onWindowLoad);\n        callback();\n      };\n\n      // Listen for DOMContentLoaded event if available (no way to reliably detect\n      // support)\n      if (qxWeb.env.get(\"engine.name\") !== \"mshtml\" || qxWeb.env.get(\"browser.documentmode\") > 8) {\n        qx.bom.Event.addNativeListener(document, \"DOMContentLoaded\", wrappedCallback);\n      }\n      else {\n        // Continually check to see if the document is ready\n        var timer = function() {\n          // onWindowLoad already executed\n          if (qx.module.Event.__isReady) {\n            return;\n          }\n          try {\n            // If DOMContentLoaded is unavailable, use the trick by Diego Perini\n            // http://javascript.nwbox.com/IEContentLoaded/\n            document.documentElement.doScroll(\"left\");\n            if (document.body) {\n              wrappedCallback();\n            }\n          }\n          catch(error) {\n            window.setTimeout(timer, 100);\n          }\n        };\n\n        timer();\n      }\n    },\n\n\n    /**\n     * Registers a normalization function for the given event types. Listener\n     * callbacks for these types will be called with the return value of the\n     * normalization function instead of the regular event object.\n     *\n     * The normalizer will be called with two arguments: The original event\n     * object and the element on which the event was triggered\n     *\n     * @attachStatic {qxWeb, $registerEventNormalization}\n     * @param types {String[]} List of event types to be normalized. Use an\n     * asterisk (<code>*</code>) to normalize all event types\n     * @param normalizer {Function} Normalizer function\n     */\n    $registerEventNormalization : function(types, normalizer)\n    {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var registry = qx.module.Event.__normalizations;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(normalizer)) {\n          if (!registry[type]) {\n            registry[type] = [];\n          }\n          registry[type].push(normalizer);\n        }\n      }\n    },\n\n\n    /**\n     * Unregisters a normalization function from the given event types.\n     *\n     * @attachStatic {qxWeb, $unregisterEventNormalization}\n     * @param types {String[]} List of event types\n     * @param normalizer {Function} Normalizer function\n     */\n    $unregisterEventNormalization : function(types, normalizer)\n    {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var registry = qx.module.Event.__normalizations;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (registry[type]) {\n          qx.lang.Array.remove(registry[type], normalizer);\n        }\n      }\n    },\n\n\n    /**\n     * Returns all registered event normalizers\n     *\n     * @attachStatic {qxWeb, $getEventNormalizationRegistry}\n     * @return {Map} Map of event types/normalizer functions\n     */\n    $getEventNormalizationRegistry : function()\n    {\n      return qx.module.Event.__normalizations;\n    },\n\n\n    /**\n     * Registers an event hook for the given event types.\n     *\n     * @attachStatic {qxWeb, $registerEventHook}\n     * @param types {String[]} List of event types\n     * @param registerHook {Function} Hook function to be called on event registration\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\n     * @internal\n     */\n    $registerEventHook : function(types, registerHook, unregisterHook)\n    {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var onHooks = qx.module.Event.__hooks.on;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(registerHook)) {\n          if (!onHooks[type]) {\n            onHooks[type] = [];\n          }\n          onHooks[type].push(registerHook);\n        }\n      }\n      if (!unregisterHook) {\n        return;\n      }\n      var offHooks = qx.module.Event.__hooks.off;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (qx.lang.Type.isFunction(unregisterHook)) {\n          if (!offHooks[type]) {\n            offHooks[type] = [];\n          }\n          offHooks[type].push(unregisterHook);\n        }\n      }\n    },\n\n\n    /**\n     * Unregisters a hook from the given event types.\n     *\n     * @attachStatic {qxWeb, $unregisterEventHooks}\n     * @param types {String[]} List of event types\n     * @param registerHook {Function} Hook function to be called on event registration\n     * @param unregisterHook {Function?} Hook function to be called on event deregistration\n     * @internal\n     */\n    $unregisterEventHook : function(types, registerHook, unregisterHook)\n    {\n      if (!qx.lang.Type.isArray(types)) {\n        types = [types];\n      }\n      var onHooks = qx.module.Event.__hooks.on;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (onHooks[type]) {\n          qx.lang.Array.remove(onHooks[type], registerHook);\n        }\n      }\n      if (!unregisterHook) {\n        return;\n      }\n      var offHooks = qx.module.Event.__hooks.off;\n      for (var i=0,l=types.length; i<l; i++) {\n        var type = types[i];\n        if (offHooks[type]) {\n          qx.lang.Array.remove(offHooks[type], unregisterHook);\n        }\n      }\n    },\n\n\n    /**\n     * Returns all registered event hooks\n     *\n     * @attachStatic {qxWeb, $getEventHookRegistry}\n     * @return {Map} Map of event types/registration hook functions\n     * @internal\n     */\n    $getEventHookRegistry : function()\n    {\n      return qx.module.Event.__hooks;\n    }\n  },\n\n\n  members :\n  {\n    /**\n     * Registers a listener for the given event type on each item in the\n     * collection. This can be either native or custom events.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event to listen for\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Context the callback function will be executed in.\n     * Default: The element on which the listener was registered\n     * @param useCapture {Boolean?} Attach the listener to the capturing\n     * phase if true\n     * @return {qxWeb} The collection for chaining\n     */\n    on : function(type, listener, context, useCapture) {\n      for (var i=0; i < this.length; i++) {\n        var el = this[i];\n        var ctx = context || qxWeb(el);\n\n        // call hooks\n        var hooks = qx.module.Event.__hooks.on;\n        // generic\n        var typeHooks = hooks[\"*\"] || [];\n        // type specific\n        if (hooks[type]) {\n          typeHooks = typeHooks.concat(hooks[type]);\n        }\n        for (var j=0, m=typeHooks.length; j<m; j++) {\n          typeHooks[j](el, type, listener, context);\n        }\n\n        var bound = function(el, event) {\n          // apply normalizations\n          var registry = qx.module.Event.__normalizations;\n          // generic\n          var normalizations = registry[\"*\"] || [];\n          // type specific\n          if (registry[type]) {\n            normalizations = normalizations.concat(registry[type]);\n          }\n\n          for (var x=0, y=normalizations.length; x<y; x++) {\n            event = normalizations[x](event, el, type);\n          }\n          // call original listener with normalized event\n          listener.apply(this, [event]);\n        }.bind(ctx, el);\n        bound.original = listener;\n\n        // add native listener\n        qx.bom.Event.addNativeListener(el, type, bound, useCapture);\n\n        // create an emitter if necessary\n        if (!el.$$emitter) {\n          el.$$emitter = new qx.event.Emitter();\n        }\n\n        el.$$lastlistenerId = el.$$emitter.on(type, bound, ctx);\n        // save the useCapture for removing\n        el.$$emitter.getEntryById(el.$$lastlistenerId).useCapture = !!useCapture;\n\n        if (!el.__listener) {\n          el.__listener = {};\n        }\n        if (!el.__listener[type]) {\n          el.__listener[type] = {};\n        }\n        el.__listener[type][el.$$lastlistenerId] = bound;\n\n        if (!context) {\n          // store a reference to the dynamically created context so we know\n          // what to check for when removing the listener\n          if (!el.__ctx) {\n            el.__ctx = {};\n          }\n          el.__ctx[el.$$lastlistenerId] = ctx;\n        }\n      }\n      return this;\n    },\n\n\n    /**\n     * Unregisters event listeners for the given type from each element in the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Listener callback context\n     * @param useCapture {Boolean?} Attach the listener to the capturing\n     * phase if true\n     * @return {qxWeb} The collection for chaining\n     */\n    off : function(type, listener, context, useCapture) {\n      var removeAll = (listener === null && context === null);\n\n      for (var j=0; j < this.length; j++) {\n        var el = this[j];\n\n        // continue if no listeners are available\n        if (!el.__listener) {\n          continue;\n        }\n\n        var types = [];\n        if (type !== null) {\n          types.push(type);\n        } else {\n          // no type specified, remove all listeners\n          for (var listenerType in el.__listener) {\n            types.push(listenerType);\n          }\n        }\n\n        for (var i=0, l=types.length; i<l; i++) {\n          for (var id in el.__listener[types[i]]) {\n            var storedListener = el.__listener[types[i]][id];\n            if (removeAll || storedListener == listener || storedListener.original == listener) {\n              // get the stored context\n              var hasStoredContext = typeof el.__ctx !== \"undefined\" && el.__ctx[id];\n              var storedContext;\n              if (!context && hasStoredContext) {\n                storedContext = el.__ctx[id];\n              }\n              // remove the listener from the emitter\n              var result = el.$$emitter.off(types[i], storedListener, storedContext || context);\n\n              // check if it's a bound listener which means it was a native event\n              if (removeAll || storedListener.original == listener) {\n                // remove the native listener\n                qx.bom.Event.removeNativeListener(el, types[i], storedListener, useCapture);\n              }\n\n              // BUG #9184\n              // only if the emitter was successfully removed also delete the key in the data structure\n              if (result !== null) {\n                delete el.__listener[types[i]][id];\n              }\n\n              if (hasStoredContext) {\n                delete el.__ctx[id];\n              }\n            }\n          }\n\n          // call hooks\n          var hooks = qx.module.Event.__hooks.off;\n          // generic\n          var typeHooks = hooks[\"*\"] || [];\n          // type specific\n          if (hooks[type]) {\n            typeHooks = typeHooks.concat(hooks[type]);\n          }\n          for (var k=0, m=typeHooks.length; k<m; k++) {\n            typeHooks[k](el, type, listener, context);\n          }\n        }\n\n      }\n\n      return this;\n    },\n\n    /**\n     * Removes all event listeners (or all listeners for a given type) from the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param type {String?} Event type. All listeners will be removed if this is undefined.\n     * @return {qxWeb} The collection for chaining\n     */\n    allOff : function(type) {\n      return this.off(type || null, null, null);\n    },\n\n    /**\n     * Removes the listener with the given id.\n     * @param id {Number} The id of the listener to remove\n     * @return {qxWeb} The collection for chaining.\n     */\n    offById : function(id) {\n      var entry = this[0].$$emitter.getEntryById(id);\n      return this.off(entry.name, entry.listener.original, entry.ctx, entry.useCapture);\n    },\n\n    /**\n     * Fire an event of the given type.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Event type\n     * @param data {var?} Optional data that will be passed to the listener\n     * callback function.\n     * @return {qxWeb} The collection for chaining\n     */\n    emit : function(type, data) {\n      for (var j=0; j < this.length; j++) {\n        var el = this[j];\n        if (el.$$emitter) {\n          el.$$emitter.emit(type, data);\n        }\n      }\n      return this;\n    },\n\n\n    /**\n     * Attaches a listener for the given event that will be executed only once.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Type of the event to listen for\n     * @param listener {Function} Listener callback\n     * @param context {Object?} Context the callback function will be executed in.\n     * Default: The element on which the listener was registered\n     * @return {qxWeb} The collection for chaining\n     */\n    once : function(type, listener, context) {\n      var self = this;\n      var wrappedListener = function(data) {\n        self.off(type, wrappedListener, context);\n        listener.call(this, data);\n      };\n      this.on(type, wrappedListener, context);\n      return this;\n    },\n\n\n    /**\n     * Checks if one or more listeners for the given event type are attached to\n     * the first element in the collection.\n     *\n     * *Important:* Make sure you are handing in the *identical* context object to get\n     * the correct result. Especially when using a collection instance this is a common pitfall.\n     *\n     * @attach {qxWeb}\n     * @param type {String} Event type, e.g. <code>mousedown</code>\n     * @param listener {Function?} Event listener to check for.\n     * @param context {Object?} Context object listener to check for.\n     * @return {Boolean} <code>true</code> if one or more listeners are attached\n     */\n    hasListener : function(type, listener, context) {\n      if (!this[0] || !this[0].$$emitter ||\n        !this[0].$$emitter.getListeners()[type])\n      {\n        return false;\n      }\n\n      if (listener) {\n        var attachedListeners = this[0].$$emitter.getListeners()[type];\n        for (var i = 0; i < attachedListeners.length; i++) {\n          var hasListener = false;\n          if (attachedListeners[i].listener == listener) {\n            hasListener = true;\n          }\n          if (attachedListeners[i].listener.original &&\n              attachedListeners[i].listener.original == listener) {\n            hasListener =  true;\n          }\n\n          if (hasListener) {\n            if (context !== undefined) {\n              if (attachedListeners[i].ctx === context) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      return this[0].$$emitter.getListeners()[type].length > 0;\n    },\n\n\n    /**\n     * Copies any event listeners that are attached to the elements in the\n     * collection to the provided target element\n     *\n     * @internal\n     * @param target {Element} Element to attach the copied listeners to\n     */\n    copyEventsTo : function(target) {\n      // Copy both arrays to make sure the original collections are not manipulated.\n      // If e.g. the 'target' array contains a DOM node with child nodes we run into\n      // problems because the 'target' array is flattened within this method.\n      var source = this.concat();\n      var targetCopy = target.concat();\n\n      // get all children of source and target\n      for (var i = source.length - 1; i >= 0; i--) {\n        var descendants = source[i].getElementsByTagName(\"*\");\n        for (var j=0; j < descendants.length; j++) {\n          source.push(descendants[j]);\n        }\n      }\n\n      for (var i = targetCopy.length -1; i >= 0; i--) {\n        var descendants = targetCopy[i].getElementsByTagName(\"*\");\n        for (var j=0; j < descendants.length; j++) {\n          targetCopy.push(descendants[j]);\n        }\n      }\n      // make sure no emitter object has been copied\n      targetCopy.forEach(function(el) {\n        el.$$emitter = null;\n      });\n\n      for (var i=0; i < source.length; i++) {\n        var el = source[i];\n        if (!el.$$emitter) {\n          continue;\n        }\n        var storage = el.$$emitter.getListeners();\n        for (var name in storage) {\n          for (var j = storage[name].length - 1; j >= 0; j--) {\n            var listener = storage[name][j].listener;\n            if (listener.original) {\n              listener = listener.original;\n            }\n            qxWeb(targetCopy[i]).on(name, listener, storage[name][j].ctx);\n          }\n        }\n      }\n    },\n\n\n\n    /**\n     * Bind one or two callbacks to the collection.\n     * If only the first callback is defined the collection\n     * does react on 'pointerover' only.\n     *\n     * @attach {qxWeb}\n     *\n     * @param callbackIn {Function} callback when hovering over\n     * @param callbackOut {Function?} callback when hovering out\n     * @return {qxWeb} The collection for chaining\n     */\n    hover : function(callbackIn, callbackOut) {\n\n      this.on(\"pointerover\", callbackIn, this);\n\n      if (qx.lang.Type.isFunction(callbackOut)) {\n        this.on(\"pointerout\", callbackOut, this);\n      }\n\n      return this;\n    },\n\n\n    /**\n     * Adds a listener for the given type and checks if the target fulfills the selector check.\n     * If the check is successful the callback is executed with the target and event as arguments.\n     *\n     * @attach{qxWeb}\n     *\n     * @param eventType {String} name of the event to watch out for (attached to the document object)\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\n     * Array of DOM elements or collection\n     * @param callback {Function} function to call if the selector matches.\n     * The callback will get the target as qxWeb collection and the event as arguments\n     * @param context {Object?} optional context object to call the callback\n     * @return {qxWeb} The collection for chaining\n     */\n    onMatchTarget : function(eventType, target, callback, context) {\n\n      context = context !== undefined ? context : this;\n\n      var listener = function(e){\n\n        var eventTarget = qxWeb(e.getTarget());\n        if (eventTarget.is(target)) {\n          callback.call(context, eventTarget, qxWeb.object.clone(e));\n        } else {\n          var targetToMatch = typeof target == \"string\" ? this.find(target) : qxWeb(target);\n          for(var i = 0, l = targetToMatch.length; i < l; i++) {\n            if(eventTarget.isChildOf(qxWeb(targetToMatch[i]))) {\n              callback.call(context, eventTarget, qxWeb.object.clone(e));\n              break;\n            }\n          }\n        }\n      };\n\n      // make sure to store the infos for 'offMatchTarget' at each element of the collection\n      // to be able to remove the listener separately\n      this.forEach(function(el) {\n        var matchTarget = {\n          type : eventType,\n          listener : listener,\n          callback : callback,\n          context : context\n        };\n\n        if (!el.$$matchTargetInfo) {\n          el.$$matchTargetInfo = [];\n        }\n        el.$$matchTargetInfo.push(matchTarget);\n      });\n\n      this.on(eventType, listener);\n\n      return this;\n    },\n\n\n    /**\n     * Removes a listener for the given type and selector check.\n     *\n     * @attach{qxWeb}\n     *\n     * @param eventType {String} name of the event to remove for\n     * @param target {String|Element|Element[]|qxWeb} Selector expression, DOM element,\n     * Array of DOM elements or collection\n     * @param callback {Function} function to remove\n     * @param context {Object?} optional context object to remove\n     * @return {qxWeb} The collection for chaining\n     */\n    offMatchTarget : function(eventType, target, callback, context) {\n\n      context = context !== undefined ? context : this;\n\n      this.forEach(function(el) {\n\n        if (el.$$matchTargetInfo && qxWeb.type.get(el.$$matchTargetInfo) == \"Array\") {\n\n          var infos = el.$$matchTargetInfo;\n\n          for (var i=infos.length - 1; i>=0; i--) {\n\n            var entry = infos[i];\n            if (entry.type == eventType &&\n                entry.callback == callback &&\n                entry.context == context) {\n\n              this.off(eventType, entry.listener);\n              infos.splice(i, 1);\n            }\n\n          }\n\n          if (infos.length === 0) {\n            el.$$matchTargetInfo = null;\n          }\n        }\n      }, this);\n\n      return this;\n    }\n  },\n\n\n  defer : function(statics) {\n    qxWeb.$attachAll(this);\n    // manually attach internal $-methods as they are ignored by the previous method-call\n    qxWeb.$attachStatic({\n      \"$registerEventNormalization\" : statics.$registerEventNormalization,\n      \"$unregisterEventNormalization\" : statics.$unregisterEventNormalization,\n      \"$getEventNormalizationRegistry\" : statics.$getEventNormalizationRegistry,\n      \"$registerEventHook\" : statics.$registerEventHook,\n      \"$unregisterEventHook\" : statics.$unregisterEventHook,\n      \"$getEventHookRegistry\" : statics.$getEventHookRegistry\n    });\n  }\n});\n"
  ]
}