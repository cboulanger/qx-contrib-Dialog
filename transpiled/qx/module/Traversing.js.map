{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/module/Traversing.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "EQUALITY_ATTRIBUTES",
    "__getAncestors",
    "selector",
    "filter",
    "ancestors",
    "i",
    "length",
    "parent",
    "dom",
    "Element",
    "getParentElement",
    "found",
    "bom",
    "Selector",
    "matches",
    "concat",
    "qxWeb",
    "$init",
    "__getElementFromArgument",
    "arg",
    "isString",
    "__getNodeFromArgument",
    "Array",
    "isNode",
    "__getAttributes",
    "node",
    "attributes",
    "attr",
    "name",
    "value",
    "__hierarchyHelper",
    "collection",
    "method",
    "all",
    "Hierarchy",
    "l",
    "push",
    "apply",
    "ret",
    "lang",
    "unique",
    "isElement",
    "Node",
    "module",
    "Traversing",
    "isNodeName",
    "nodeName",
    "isDocument",
    "isDocumentFragment",
    "getWindow",
    "isTextNode",
    "obj",
    "isText",
    "isWindow",
    "getDocument",
    "getNodeName",
    "getName",
    "getNodeText",
    "getText",
    "isBlockNode",
    "equalNodes",
    "node1",
    "node2",
    "core",
    "Environment",
    "get",
    "isEqualNode",
    "hasAttributes",
    "hasChildNodes",
    "childNodes",
    "domAttributes",
    "domAttrib",
    "node1Attributes",
    "node2Attributes",
    "j",
    "m",
    "child1",
    "child2",
    "members",
    "add",
    "el",
    "getChildren",
    "children",
    "getChildElements",
    "forEach",
    "fn",
    "ctx",
    "call",
    "getParents",
    "parents",
    "isChildOf",
    "parentCollection",
    "getAncestors",
    "len",
    "indexOf",
    "getAncestorsUntil",
    "getClosest",
    "closest",
    "findClosest",
    "current",
    "parentNode",
    "find",
    "query",
    "getContents",
    "_forEachElement",
    "item",
    "fromCollection",
    "is",
    "Type",
    "isFunction",
    "eq",
    "index",
    "slice",
    "getFirst",
    "getLast",
    "has",
    "descendants",
    "constructor",
    "contains",
    "element",
    "document",
    "getNext",
    "map",
    "getNextElementSibling",
    "getNextAll",
    "getNextUntil",
    "nextSiblings",
    "getNextSiblings",
    "getPrev",
    "getPreviousElementSibling",
    "getPrevAll",
    "getPrevUntil",
    "previousSiblings",
    "getPreviousSiblings",
    "getSiblings",
    "not",
    "res",
    "getOffsetParent",
    "Location",
    "isRendered",
    "defer",
    "$attachAll",
    "$attach"
  ],
  "mappings": "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",
  "file": "Traversing.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2011-2012 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (wittemann)\n     * Daniel Wagner (danielwagner)\n\n************************************************************************ */\n\n/**\n * DOM traversal module\n *\n * @require(qx.dom.Hierarchy#getSiblings)\n * @require(qx.dom.Hierarchy#getNextSiblings)\n * @require(qx.dom.Hierarchy#getPreviousSiblings)\n * @require(qx.dom.Hierarchy#contains)\n *\n * @group (Core)\n */\nqx.Bootstrap.define(\"qx.module.Traversing\", {\n  statics :\n  {\n    /**\n     * String attributes used to determine if two DOM nodes are equal\n     * as defined in <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">\n     * DOM Level 3</a>\n     */\n    EQUALITY_ATTRIBUTES : [\n      \"nodeType\",\n      \"nodeName\",\n      \"localName\",\n      \"namespaceURI\",\n      \"prefix\",\n      \"nodeValue\"\n    ],\n\n\n    /**\n     * Internal helper for getAncestors and getAncestorsUntil\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector that indicates where to stop including\n     * ancestor elements\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     * @internal\n     */\n    __getAncestors : function(selector, filter) {\n      var ancestors = [];\n      for (var i=0; i < this.length; i++) {\n        var parent = qx.dom.Element.getParentElement(this[i]);\n        while (parent) {\n          var found = [parent];\n          if (selector && qx.bom.Selector.matches(selector, found).length > 0) {\n            break;\n          }\n          if (filter) {\n            found = qx.bom.Selector.matches(filter, found);\n          }\n          ancestors = ancestors.concat(found);\n          parent = qx.dom.Element.getParentElement(parent);\n        }\n      }\n      return qxWeb.$init(ancestors, qxWeb);\n    },\n\n\n\n    /**\n     * Helper which returns the element from the given argument. If it's a collection,\n     * it returns it's first child. If it's a string, it tries to use the string\n     * as selector and returns the first child of the new collection.\n     * @param arg {Node|String|qxWeb} The element.\n     * @return {Node|var} If a node can be extracted, the node element will be return.\n     *   If not, at given argument will be returned.\n     */\n    __getElementFromArgument : function(arg) {\n      if (arg instanceof qxWeb) {\n        return arg[0];\n      } else if (qx.Bootstrap.isString(arg)) {\n        return qxWeb(arg)[0];\n      }\n      return arg;\n    },\n\n\n\n    /**\n     * Helper that attempts to convert the given argument into a DOM node\n     * @param arg {var} object to convert\n     * @return {Node|null} DOM node or null if the conversion failed\n     */\n    __getNodeFromArgument : function(arg) {\n      if (typeof arg == \"string\") {\n        arg = qxWeb(arg);\n      }\n\n      if (arg instanceof Array || arg instanceof qxWeb) {\n        arg = arg[0];\n      }\n\n      return qxWeb.isNode(arg) ? arg : null;\n    },\n\n\n    /**\n     * Returns a map containing the given DOM node's attribute names\n     * and values\n     *\n     * @param node {Node} DOM node\n     * @return {Map} Map of attribute names/values\n     */\n    __getAttributes : function(node) {\n      var attributes = {};\n\n      for (var attr in node.attributes) {\n        if (attr == \"length\") {\n          continue;\n        }\n        var name = node.attributes[attr].name;\n        var value = node.attributes[attr].value;\n        attributes[name] = value;\n      }\n\n      return attributes;\n    },\n\n\n    /**\n     * Helper function that iterates over a set of items and applies the given\n     * qx.dom.Hierarchy method to each entry, storing the results in a new Array.\n     * Duplicates are removed and the items are filtered if a selector is\n     * provided.\n     *\n     * @attach{qxWeb}\n     * @param collection {Array} Collection to iterate over (any Array-like object)\n     * @param method {String} Name of the qx.dom.Hierarchy method to apply\n     * @param selector {String?} Optional selector that elements to be included\n     * must match\n     * @return {Array} Result array\n     * @internal\n     */\n    __hierarchyHelper : function(collection, method, selector)\n    {\n      // Iterate ourself, as we want to directly combine the result\n      var all = [];\n      var Hierarchy = qx.dom.Hierarchy;\n      for (var i=0, l=collection.length; i<l; i++) {\n        all.push.apply(all, Hierarchy[method](collection[i]));\n      }\n\n      // Remove duplicates\n      var ret = qx.lang.Array.unique(all);\n\n      // Post reduce result by selector\n      if (selector) {\n        ret = qx.bom.Selector.matches(selector, ret);\n      }\n\n      return ret;\n    },\n\n\n    /**\n     * Checks if the given object is a DOM element\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Object|String|qxWeb} Object to check\n     * @return {Boolean} <code>true</code> if the object is a DOM element\n     */\n    isElement : function(selector) {\n      return qx.dom.Node.isElement(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n\n    /**\n     * Checks if the given object is a DOM node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} Object to check\n     * @return {Boolean} <code>true</code> if the object is a DOM node\n     */\n    isNode : function(selector) {\n      return qx.dom.Node.isNode(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n\n    /**\n     * Whether the node has the given node name\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node to check\n     * @param  nodeName {String} the node name to check for\n     * @return {Boolean} <code>true</code> if the node has the given name\n     */\n    isNodeName : function(selector, nodeName) {\n      return qx.dom.Node.isNodeName(qx.module.Traversing.__getElementFromArgument(selector), nodeName);\n    },\n\n\n    /**\n     * Checks if the given object is a DOM document object\n     *\n     * @attachStatic{qxWeb}\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\n     * collection, isDocument will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a DOM document\n     */\n    isDocument : function(node) {\n      if (node instanceof qxWeb) {\n        node = node[0];\n      }\n      return qx.dom.Node.isDocument(node);\n    },\n\n\n    /**\n     * Checks if the given object is a DOM document fragment object\n     *\n     * @attachStatic{qxWeb}\n     * @param node {Object|qxWeb} Object to check. If the value is a qxWeb\n     * collection, isDocumentFragment will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a DOM document fragment\n     */\n    isDocumentFragment : function(node) {\n      if (node instanceof qxWeb) {\n        node = node[0];\n      }\n      return qx.dom.Node.isDocumentFragment(node);\n    },\n\n\n    /**\n     * Returns the DOM2 <code>defaultView</code> (window) for the given node.\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|Document|Window|String|qxWeb} Node to inspect\n     * @return {Window} the <code>defaultView</code> for the given node\n     */\n    getWindow : function(selector) {\n      return qx.dom.Node.getWindow(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n    /**\n     * Checks whether the given object is a DOM text node\n     *\n     * @attachStatic{qxWeb}\n     * @param obj {Object} the object to be tested\n     * @return {Boolean} <code>true</code> if the object is a textNode\n     */\n    isTextNode : function(obj) {\n      return qx.dom.Node.isText(obj);\n    },\n\n\n    /**\n     * Check whether the given object is a browser window object.\n     *\n     * @attachStatic{qxWeb}\n     * @param obj {Object|qxWeb} the object to be tested. If the value\n     * is a qxWeb collection, isDocument will check the first item.\n     * @return {Boolean} <code>true</code> if the object is a window object\n     */\n    isWindow : function(obj) {\n      if (obj instanceof qxWeb) {\n        obj = obj[0];\n      }\n      return qx.dom.Node.isWindow(obj);\n    },\n\n\n    /**\n     * Returns the owner document of the given node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} Node to get the document for\n     * @return {Document|null} The document of the given DOM node\n     */\n    getDocument : function(selector) {\n      return qx.dom.Node.getDocument(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n    /**\n     * Get the DOM node's name as a lowercase string\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} DOM Node\n     * @return {String} node name\n     */\n    getNodeName : function(selector) {\n      return qx.dom.Node.getName(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n    /**\n     * Returns the text content of a node where the node type may be one of\n     * NODE_ELEMENT, NODE_ATTRIBUTE, NODE_TEXT, NODE_CDATA\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node from where the search should start. If the\n     * node has subnodes the text contents are recursively retrieved and joined\n     * @return {String} the joined text content of the given node or null if not\n     * appropriate.\n     */\n    getNodeText : function(selector) {\n      return qx.dom.Node.getText(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n    /**\n     * Checks if the given node is a block node\n     *\n     * @attachStatic{qxWeb}\n     * @param selector {Node|String|qxWeb} the node to check\n     * @return {Boolean} <code>true</code> if the node is a block node\n     */\n    isBlockNode : function(selector) {\n      return qx.dom.Node.isBlockNode(qx.module.Traversing.__getElementFromArgument(selector));\n    },\n\n\n    /**\n     * Determines if two DOM nodes are equal as defined in the\n     * <a href=\"http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode\">DOM Level 3 isEqualNode spec</a>.\n     * Also works in legacy browsers without native <em>isEqualNode</em> support.\n     *\n     * @attachStatic{qxWeb}\n     * @param node1 {String|Element|Element[]|qxWeb} first object to compare\n     * @param node2 {String|Element|Element[]|qxWeb} second object to compare\n     * @return {Boolean} <code>true</code> if the nodes are equal\n     */\n    equalNodes : function(node1, node2) {\n      node1 = qx.module.Traversing.__getNodeFromArgument(node1);\n      node2 = qx.module.Traversing.__getNodeFromArgument(node2);\n\n      if (!node1 || !node2) {\n        return false;\n      }\n\n      if (qx.core.Environment.get(\"html.node.isequalnode\")) {\n        return node1.isEqualNode(node2);\n      } else {\n        if (node1 === node2) {\n          return true;\n        }\n\n        // quick attributes length check\n        var hasAttributes = node1.attributes && node2.attributes;\n        if (hasAttributes &&\n            node1.attributes.length !== node2.attributes.length) {\n          return false;\n        }\n\n        var hasChildNodes = node1.childNodes && node2.childNodes;\n        // quick childNodes length check\n        if (hasChildNodes &&\n            node1.childNodes.length !== node2.childNodes.length) {\n          return false;\n        }\n\n        // string attribute check\n        var domAttributes = qx.module.Traversing.EQUALITY_ATTRIBUTES;\n        for (var i=0, l=domAttributes.length; i<l; i++) {\n          var domAttrib = domAttributes[i];\n          if (node1[domAttrib] !== node2[domAttrib]) {\n            return false;\n          }\n        }\n\n        // attribute values\n        if (hasAttributes) {\n          var node1Attributes = qx.module.Traversing.__getAttributes(node1);\n          var node2Attributes = qx.module.Traversing.__getAttributes(node2);\n          for (var attr in node1Attributes) {\n            if (node1Attributes[attr] !== node2Attributes[attr]) {\n              return false;\n            }\n          }\n        }\n\n        // child nodes\n        if (hasChildNodes) {\n          for (var j=0, m=node1.childNodes.length; j<m; j++) {\n            var child1 = node1.childNodes[j];\n            var child2 = node2.childNodes[j];\n            if (!qx.module.Traversing.equalNodes(child1, child2)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n    }\n  },\n\n\n  members :\n  {\n\n    __getAncestors : null,\n\n    /**\n     * Adds an element to the collection\n     *\n     * @attach {qxWeb}\n     * @param el {Element|qxWeb} DOM element to add to the collection.\n     * If a collection is given, only the first element will be added\n     * @return {qxWeb} The collection for chaining\n     */\n    add : function(el) {\n      if (el instanceof qxWeb) {\n        el = el[0];\n      }\n      if (qx.module.Traversing.isElement(el) ||\n          qx.module.Traversing.isDocument(el) ||\n          qx.module.Traversing.isWindow(el) ||\n          qx.module.Traversing.isDocumentFragment(el))\n      {\n        this.push(el);\n      }\n      return this;\n    },\n\n\n    /**\n     * Gets a set of elements containing all of the unique immediate children of\n     * each of the matched set of elements.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the child elements\n     */\n    getChildren : function(selector) {\n      var children = [];\n      for (var i=0; i < this.length; i++) {\n        var found = qx.dom.Hierarchy.getChildElements(this[i]);\n        if (selector) {\n          found = qx.bom.Selector.matches(selector, found);\n        }\n        children = children.concat(found);\n      };\n      return qxWeb.$init(children, qxWeb);\n    },\n\n\n    /**\n     * Executes the provided callback function once for each item in the\n     * collection.\n     *\n     * @attach {qxWeb}\n     * @param fn {Function} Callback function which is called with two parameters\n     * <ul>\n     *  <li>current item - DOM node</li>\n     *  <li>current index - Number</li>\n     * </ul>\n     * @param ctx {Object} Context object\n     * @return {qxWeb} The collection for chaining\n     */\n    forEach : function(fn, ctx) {\n      for (var i=0; i < this.length; i++) {\n        fn.call(ctx, this[i], i, this);\n      };\n      return this;\n    },\n\n\n    /**\n     * Gets a set of elements containing the parent of each element in the\n     * collection.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the parent elements\n     */\n    getParents : function(selector) {\n      var parents = [];\n      for (var i=0; i < this.length; i++) {\n        var found = qx.dom.Element.getParentElement(this[i]);\n        if (selector) {\n          found = qx.bom.Selector.matches(selector, [found]);\n        }\n        parents = parents.concat(found);\n      };\n      return qxWeb.$init(parents, qxWeb);\n    },\n\n\n    /**\n    * Checks if any element of the current collection is child of any element of a given\n    * parent collection.\n    *\n    * @attach{qxWeb}\n    * @param parent {qxWeb | String} Collection or selector of the parent collection to check.\n    * @return {Boolean} Returns true if at least one element of the current collection is child of the parent collection\n    *\n    */\n    isChildOf : function(parent){\n      if(this.length == 0){\n        return false;\n      }\n      var ancestors = null, parentCollection = qxWeb(parent), isChildOf = false;\n      for(var i = 0, l = this.length; i < l && !isChildOf; i++){\n        ancestors = qxWeb(this[i]).getAncestors();\n        for(var j = 0, len = parentCollection.length; j < len; j++){\n          if(ancestors.indexOf(parentCollection[j]) != -1){\n            isChildOf = true;\n            break;\n          }\n        };\n      }\n      return isChildOf;\n    },\n\n\n    /**\n     * Gets a set of elements containing all ancestors of each element in the\n     * collection.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     */\n    getAncestors : function(filter) {\n      return this.__getAncestors(null, filter);\n    },\n\n\n    /**\n     * Gets a set of elements containing all ancestors of each element in the\n     * collection, up to (but not including) the element matched by the provided\n     * selector.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector that indicates where to stop including\n     * ancestor elements\n     * @param filter {String?null} Optional selector to match\n     * @return {qxWeb} Collection containing the ancestor elements\n     */\n    getAncestorsUntil : function(selector, filter) {\n      return this.__getAncestors(selector, filter);\n    },\n\n\n    /**\n     * Gets a set containing the closest matching ancestor for each item in\n     * the collection.\n     * If the item itself matches, it is added to the new set. Otherwise, the\n     * item's parent chain will be traversed until a match is found.\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression to match\n     * @return {qxWeb} New collection containing the closest matching ancestors\n     */\n    getClosest : function(selector) {\n      var closest = [];\n\n      var findClosest = function(current) {\n        var found = qx.bom.Selector.matches(selector, current);\n        if (found.length) {\n          closest.push(found[0]);\n        } else {\n          current = current.getParents(); // One up\n          if(current[0] && current[0].parentNode) {\n            findClosest(current);\n          }\n        }\n      };\n\n      for (var i=0; i < this.length; i++) {\n        findClosest(qxWeb(this[i]));\n      };\n\n      return qxWeb.$init(closest, qxWeb);\n    },\n\n\n    /**\n     * Searches the child elements of each item in the collection and returns\n     * a new collection containing the children that match the provided selector\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression to match the child elements\n     * against\n     * @return {qxWeb} New collection containing the matching child elements\n     */\n    find : function(selector) {\n      var found = [];\n      for (var i=0; i < this.length; i++) {\n        found = found.concat(qx.bom.Selector.query(selector, this[i]));\n      };\n      return qxWeb.$init(found, qxWeb);\n    },\n\n\n    /**\n     * Gets a new set of elements containing the child nodes of each item in the\n     * current set.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} New collection containing the child nodes\n     */\n    getContents : function() {\n      var found = [];\n      this._forEachElement(function(item) {\n        found = found.concat(qx.lang.Array.fromCollection(item.childNodes));\n      });\n      return qxWeb.$init(found, qxWeb);\n    },\n\n\n    /**\n     * Checks if at least one element in the collection passes the provided\n     * filter. This can be either a selector expression or a filter\n     * function\n     *\n     * @attach {qxWeb}\n     * @param selector {String|Function} Selector expression or filter function\n     * @return {Boolean} <code>true</code> if at least one element matches\n     */\n    is : function(selector) {\n      if (qx.lang.Type.isFunction(selector)) {\n        return this.filter(selector).length > 0;\n      }\n      return !!selector && qx.bom.Selector.matches(selector, this).length > 0;\n    },\n\n\n    /**\n     * Reduce the set of matched elements to a single element.\n     *\n     * @attach {qxWeb}\n     * @param index {Number} The position of the element in the collection\n     * @return {qxWeb} A new collection containing one element\n     */\n    eq : function(index) {\n      return this.slice(index, +index + 1);\n    },\n\n\n    /**\n     * Reduces the collection to the first element.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} A new collection containing one element\n     */\n    getFirst : function() {\n      return this.slice(0, 1);\n    },\n\n\n    /**\n     * Reduces the collection to the last element.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} A new collection containing one element\n     */\n    getLast : function() {\n      return this.slice(this.length - 1);\n    },\n\n\n    /**\n     * Gets a collection containing only the elements that have descendants\n     * matching the given selector\n     *\n     * @attach {qxWeb}\n     * @param selector {String} Selector expression\n     * @return {qxWeb} a new collection containing only elements with matching descendants\n     */\n    has : function(selector) {\n      var found = [];\n      this._forEachElement(function(item, index) {\n        var descendants = qx.bom.Selector.matches(selector, this.eq(index).getContents());\n        if (descendants.length > 0) {\n          found.push(item);\n        }\n      });\n\n      return qxWeb.$init(found, this.constructor);\n    },\n\n\n    /**\n     * Returns a new collection containing only those nodes that\n     * contain the given element. Also accepts a qxWeb\n     * collection or an Array of elements. In those cases, the first element\n     * in the list is used.\n     *\n     * @attach {qxWeb}\n     * @param element {Element|Window|Element[]|qxWeb} element to check for.\n     * @return {qxWeb} Collection with matching items\n     */\n    contains : function(element) {\n      // qxWeb does not inherit from Array in IE\n      if (element instanceof Array || element instanceof qxWeb) {\n        element = element[0];\n      }\n\n      if (!element) {\n        return qxWeb();\n      }\n\n      if (qx.dom.Node.isWindow(element)) {\n        element = element.document;\n      }\n\n      return this.filter(function(el) {\n        if (qx.dom.Node.isWindow(el)) {\n          el = el.document;\n        }\n        return qx.dom.Hierarchy.contains(el, element);\n      });\n    },\n\n\n    /**\n     * Gets a collection containing the next sibling element of each item in\n     * the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing next siblings\n     */\n    getNext : function(selector) {\n      var found = this.map(qx.dom.Hierarchy.getNextElementSibling, qx.dom.Hierarchy);\n      if (selector) {\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\n      }\n      return found;\n    },\n\n\n    /**\n     * Gets a collection containing all following sibling elements of each\n     * item in the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing following siblings\n     */\n    getNextAll : function(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(this, \"getNextSiblings\", selector);\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n\n    /**\n     * Gets a collection containing the following sibling elements of each\n     * item in the current set up to but not including any element that matches\n     * the given selector.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing following siblings\n     */\n    getNextUntil : function(selector) {\n      var found = [];\n      this.forEach(function(item, index) {\n        var nextSiblings = qx.dom.Hierarchy.getNextSiblings(item);\n        for (var i=0, l=nextSiblings.length; i<l; i++) {\n          if (qx.bom.Selector.matches(selector, [nextSiblings[i]]).length > 0) {\n            break;\n          }\n          found.push(nextSiblings[i]);\n        }\n      });\n\n      return qxWeb.$init(found, qxWeb);\n    },\n\n\n    /**\n     * Gets a collection containing the previous sibling element of each item in\n     * the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing previous siblings\n     */\n    getPrev : function(selector) {\n      var found = this.map(qx.dom.Hierarchy.getPreviousElementSibling, qx.dom.Hierarchy);\n      if (selector) {\n        found = qxWeb.$init(qx.bom.Selector.matches(selector, found), qxWeb);\n      }\n      return found;\n    },\n\n\n    /**\n     * Gets a collection containing all preceding sibling elements of each\n     * item in the current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing preceding siblings\n     */\n    getPrevAll : function(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(this, \"getPreviousSiblings\", selector);\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n\n    /**\n     * Gets a collection containing the preceding sibling elements of each\n     * item in the current set up to but not including any element that matches\n     * the given selector.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing preceding siblings\n     */\n    getPrevUntil : function(selector) {\n      var found = [];\n      this.forEach(function(item, index) {\n        var previousSiblings = qx.dom.Hierarchy.getPreviousSiblings(item);\n        for (var i=0, l=previousSiblings.length; i<l; i++) {\n          if (qx.bom.Selector.matches(selector, [previousSiblings[i]]).length > 0) {\n            break;\n          }\n          found.push(previousSiblings[i]);\n        }\n      });\n\n      return qxWeb.$init(found, qxWeb);\n    },\n\n\n    /**\n     * Gets a collection containing all sibling elements of the items in the\n     * current set.\n     * This set can be filtered with an optional expression that will cause only\n     * elements matching the selector to be collected.\n     *\n     * @attach {qxWeb}\n     * @param selector {String?} Optional selector expression\n     * @return {qxWeb} New set containing sibling elements\n     */\n    getSiblings : function(selector) {\n      var ret = qx.module.Traversing.__hierarchyHelper(this, \"getSiblings\", selector);\n      return qxWeb.$init(ret, qxWeb);\n    },\n\n\n    /**\n     * Remove elements from the collection that do not pass the given filter.\n     * This can be either a selector expression or a filter function\n     *\n     * @attach {qxWeb}\n     * @param selector {String|Function} Selector or filter function\n     * @return {qxWeb} Reduced collection\n     */\n    not : function(selector) {\n      if (qx.lang.Type.isFunction(selector)) {\n        return this.filter(function(item, index, obj) {\n          return !selector(item, index, obj);\n        });\n      }\n\n      var res = qx.bom.Selector.matches(selector, this);\n      return this.filter(function(value) {\n        return res.indexOf(value) === -1;\n      });\n    },\n\n\n    /**\n     * Gets a new collection containing the offset parent of each item in the\n     * current set.\n     *\n     * @attach {qxWeb}\n     * @return {qxWeb} New collection containing offset parents\n     */\n    getOffsetParent : function() {\n      return this.map(qx.bom.element.Location.getOffsetParent);\n    },\n\n\n    /**\n     * Whether the first element in the collection is inserted into\n     * the document for which it was created.\n     *\n     * @attach {qxWeb}\n     * @return {Boolean} <code>true</code> when the element is inserted\n     *    into the document.\n     */\n    isRendered : function() {\n      if (!this[0]) {\n        return false;\n      }\n      return qx.dom.Hierarchy.isRendered(this[0]);\n    }\n  },\n\n\n  defer : function(statics) {\n    qxWeb.$attachAll(this);\n    // manually attach private method which is ignored by attachAll\n    qxWeb.$attach({\n      \"__getAncestors\" : statics.__getAncestors\n    });\n  }\n});\n"
  ]
}