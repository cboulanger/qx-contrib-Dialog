{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/Interface.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "name",
    "config",
    "extend",
    "getClass",
    "__validateConfig",
    "iface",
    "$$extends",
    "properties",
    "$$properties",
    "members",
    "$$members",
    "events",
    "$$events",
    "$$type",
    "toString",
    "genericToString",
    "basename",
    "createNamespace",
    "Interface",
    "$$registry",
    "getByName",
    "isDefined",
    "undefined",
    "getTotalNumber",
    "objectGetLength",
    "flatten",
    "ifaces",
    "list",
    "concat",
    "i",
    "l",
    "length",
    "push",
    "apply",
    "__checkMembers",
    "object",
    "clazz",
    "wrap",
    "shouldThrow",
    "key",
    "isFunction",
    "isPropertyMethod",
    "__isPropertyMethod",
    "hasMemberFunction",
    "Error",
    "classname",
    "shouldWrapFunction",
    "util",
    "OOUtil",
    "hasInterface",
    "__wrapInterfaceMember",
    "methodName",
    "match",
    "propertyName",
    "firstLow",
    "getPropertyDefinition",
    "isBoolean",
    "check",
    "__checkProperties",
    "__checkEvents",
    "supportsEvent",
    "assertObject",
    "constructor",
    "assert",
    "prototype",
    "objectImplements",
    "classImplements",
    "has",
    "origFunction",
    "functionName",
    "preCondition",
    "wrappedFunction",
    "arguments",
    "wrapper",
    "__allowedKeys",
    "allowed",
    "maps",
    "indexOf",
    "a",
    "toUpperCase"
  ],
  "mappings": ";;;;;;;;;;;;;;;AAAAA,KAAGC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC,EA2BAH,GAAGC,SAAH,CAAaG,MAAb,CAAoB,cAApB,EACA;AACEC,aACA;AACE;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDAD,cAAS,gBAASE,IAAT,EAAeC,MAAf,EACT;AACE,YAAIA,MAAJ,EACA;AACE;AACA,cAAIA,OAAOC,MAAP,IAAiB,EAAER,GAAGC,SAAH,CAAaQ,QAAb,CAAsBF,OAAOC,MAA7B,MAAyC,OAA3C,CAArB,EAA0E;AACxED,mBAAOC,MAAP,GAAgB,CAACD,OAAOC,MAAR,CAAhB;AACD;;AAED;AACyC;AACvC,iBAAKE,gBAAL,CAAsBJ,IAAtB,EAA4BC,MAA5B;AACD;;AAED;AACA,cAAII,QAAQJ,OAAOF,OAAP,GAAiBE,OAAOF,OAAxB,GAAkC,EAA9C;;AAEA;AACA,cAAIE,OAAOC,MAAX,EAAmB;AACjBG,kBAAMC,SAAN,GAAkBL,OAAOC,MAAzB;AACD;;AAED,cAAID,OAAOM,UAAX,EAAuB;AACrBF,kBAAMG,YAAN,GAAqBP,OAAOM,UAA5B;AACD;;AAED,cAAIN,OAAOQ,OAAX,EAAoB;AAClBJ,kBAAMK,SAAN,GAAkBT,OAAOQ,OAAzB;AACD;;AAED,cAAIR,OAAOU,MAAX,EAAmB;AACjBN,kBAAMO,QAAN,GAAiBX,OAAOU,MAAxB;AACD;AACF,SA/BD,MAiCA;AACE;AACA,cAAIN,QAAQ,EAAZ;AACD;;AAED;AACAA,cAAMQ,MAAN,GAAe,WAAf;AACAR,cAAML,IAAN,GAAaA,IAAb;;AAEA;AACAK,cAAMS,QAAN,GAAiB,KAAKC,eAAtB;;AAEA;AACAV,cAAMW,QAAN,GAAiBtB,GAAGC,SAAH,CAAasB,eAAb,CAA6BjB,IAA7B,EAAmCK,KAAnC,CAAjB;;AAEA;AACAX,WAAGwB,SAAH,CAAaC,UAAb,CAAwBnB,IAAxB,IAAgCK,KAAhC;;AAEA;AACA,eAAOA,KAAP;AACD,OAvHH;;AA0HE;;;;;;AAMAe,iBAAY,mBAASpB,IAAT,EAAe;AACzB,eAAO,KAAKmB,UAAL,CAAgBnB,IAAhB,CAAP;AACD,OAlIH;;AAqIE;;;;;;AAMAqB,iBAAY,mBAASrB,IAAT,EAAe;AACzB,eAAO,KAAKoB,SAAL,CAAepB,IAAf,MAAyBsB,SAAhC;AACD,OA7IH;;AAgJE;;;;;AAKAC,sBAAiB,0BAAW;AAC1B,eAAO7B,GAAGC,SAAH,CAAa6B,eAAb,CAA6B,KAAKL,UAAlC,CAAP;AACD,OAvJH;;AA0JE;;;;;;;AAOAM,eAAU,iBAASC,MAAT,EACV;AACE,YAAI,CAACA,MAAL,EAAa;AACX,iBAAO,EAAP;AACD;;AAED;AACA,YAAIC,OAAOD,OAAOE,MAAP,EAAX;;AAEA,aAAK,IAAIC,IAAE,CAAN,EAASC,IAAEJ,OAAOK,MAAvB,EAA+BF,IAAEC,CAAjC,EAAoCD,GAApC,EACA;AACE,cAAIH,OAAOG,CAAP,EAAUvB,SAAd,EAAyB;AACvBqB,iBAAKK,IAAL,CAAUC,KAAV,CAAgBN,IAAhB,EAAsB,KAAKF,OAAL,CAAaC,OAAOG,CAAP,EAAUvB,SAAvB,CAAtB;AACD;AACF;;AAED,eAAOqB,IAAP;AACD,OAlLH;;AAqLE;;;;;;;;;;;;AAYAO,sBAAiB,wBAASC,MAAT,EAAiBC,KAAjB,EAAwB/B,KAAxB,EAA+BgC,IAA/B,EAAqCC,WAArC,EACjB;AACE;AACA,YAAI7B,UAAUJ,MAAMK,SAApB;AACA,YAAID,OAAJ,EAAa;AACX,eAAK,IAAI8B,GAAT,IAAgB9B,OAAhB,EAAyB;AACvB,gBAAIf,GAAGC,SAAH,CAAa6C,UAAb,CAAwB/B,QAAQ8B,GAAR,CAAxB,CAAJ,EAA2C;AACzC,kBAAIE,mBAAmB,KAAKC,kBAAL,CAAwBN,KAAxB,EAA+BG,GAA/B,CAAvB;AACA,kBAAII,oBAAoBF,oBAAoB/C,GAAGC,SAAH,CAAa6C,UAAb,CAAwBL,OAAOI,GAAP,CAAxB,CAA5C;;AAEA,kBAAI,CAACI,iBAAL,EAAwB;AACtB,oBAAIL,WAAJ,EAAiB;AACf,wBAAM,IAAIM,KAAJ,CACF,+BAA+BL,GAA/B,GACA,yBADA,GAC4BH,MAAMS,SADlC,GAEA,2BAFA,GAE8BxC,MAAML,IAFpC,GAE2C,GAHzC,CAAN;AAKD,iBAND,MAMO;AACL,yBAAO,KAAP;AACD;AACF;;AAED;AACA;AACA,kBAAI8C,qBACFT,SAAS,IAAT,IACA,CAACI,gBADD,IAEA,CAAC/C,GAAGqD,IAAH,CAAQC,MAAR,CAAeC,YAAf,CAA4Bb,KAA5B,EAAmC/B,KAAnC,CAHH;;AAKA,kBAAIyC,kBAAJ,EAAwB;AACtBX,uBAAOI,GAAP,IAAc,KAAKW,qBAAL,CACZ7C,KADY,EACL8B,OAAOI,GAAP,CADK,EACQA,GADR,EACa9B,QAAQ8B,GAAR,CADb,CAAd;AAGD;AACF,aA5BD,MA4BO;AACL;AACA;AACA,kBAAI,QAAOJ,OAAOI,GAAP,CAAP,MAAuBjB,SAA3B,EAAsC;AACpC,oBAAI,OAAOa,OAAOI,GAAP,CAAP,KAAuB,UAA3B,EAAuC;AACrC,sBAAID,WAAJ,EAAiB;AACf,0BAAM,IAAIM,KAAJ,CACJ,+BAA+BL,GAA/B,GACA,yBADA,GAC4BH,MAAMS,SADlC,GAEA,2BAFA,GAE8BxC,MAAML,IAFpC,GAE2C,GAHvC,CAAN;AAKD,mBAND,MAMO;AACL,2BAAO,KAAP;AACD;AACF;AACF;AACF;AACF;AACF;AACD,YAAI,CAACsC,WAAL,EAAkB;AAChB,iBAAO,IAAP;AACD;AACF,OAzPH;;AA4PE;;;;;;;;;;AAUAI,0BAAoB,4BAASN,KAAT,EAAgBe,UAAhB,EACpB;AACE,YAAIC,QAAQD,WAAWC,KAAX,CAAiB,iCAAjB,CAAZ;;AAEA,YAAI,CAACA,KAAL,EAAY;AACV,iBAAO,KAAP;AACD;;AAED,YAAIC,eAAe3D,GAAGC,SAAH,CAAa2D,QAAb,CAAsBF,MAAM,CAAN,CAAtB,CAAnB;AACA,YAAIX,mBAAmB/C,GAAGqD,IAAH,CAAQC,MAAR,CAAeO,qBAAf,CAAqCnB,KAArC,EAA4CiB,YAA5C,CAAvB;AACA,YAAI,CAACZ,gBAAL,EAAuB;AACrB,iBAAO,KAAP;AACD;;AAED,YAAIe,YAAYJ,MAAM,CAAN,MAAa,IAAb,IAAqBA,MAAM,CAAN,MAAa,QAAlD;AACA,YAAII,SAAJ,EAAe;AACb,iBAAO9D,GAAGqD,IAAH,CAAQC,MAAR,CAAeO,qBAAf,CAAqCnB,KAArC,EAA4CiB,YAA5C,EAA0DI,KAA1D,KAAoE,SAA3E;AACD;;AAED,eAAO,IAAP;AACD,OA1RH;;AA6RE;;;;;;;;;AASAC,yBAAoB,2BAAStB,KAAT,EAAgB/B,KAAhB,EAAuBiC,WAAvB,EACpB;AACE,YAAIjC,MAAMG,YAAV,EAAwB;AACtB,eAAK,IAAI+B,GAAT,IAAgBlC,MAAMG,YAAtB,EAAoC;AAClC,gBAAI,CAACd,GAAGqD,IAAH,CAAQC,MAAR,CAAeO,qBAAf,CAAqCnB,KAArC,EAA4CG,GAA5C,CAAL,EAAuD;AACrD,kBAAID,WAAJ,EAAiB;AACf,sBAAM,IAAIM,KAAJ,CACJ,mBAAmBL,GAAnB,GAAyB,+BAAzB,GACAH,MAAMS,SADN,GACkB,IAFd,CAAN;AAID,eALD,MAKO;AACL,uBAAO,KAAP;AACD;AACF;AACF;AACF;AACD,YAAI,CAACP,WAAL,EAAkB;AAChB,iBAAO,IAAP;AACD;AACF,OAzTH;;AA4TE;;;;;;;;;AASAqB,qBAAgB,uBAASvB,KAAT,EAAgB/B,KAAhB,EAAuBiC,WAAvB,EAChB;AACE,YAAIjC,MAAMO,QAAV,EAAoB;AAClB,eAAK,IAAI2B,GAAT,IAAgBlC,MAAMO,QAAtB,EAAgC;AAC9B,gBAAI,CAAClB,GAAGqD,IAAH,CAAQC,MAAR,CAAeY,aAAf,CAA6BxB,KAA7B,EAAoCG,GAApC,CAAL,EAA+C;AAC7C,kBAAID,WAAJ,EAAiB;AACf,sBAAM,IAAIM,KAAJ,CACJ,gBAAgBL,GAAhB,GAAsB,+BAAtB,GACAH,MAAMS,SADN,GACkB,IAFd,CAAN;AAID,eALD,MAKO;AACL,uBAAO,KAAP;AACD;AACF;AACF;AACF;AACD,YAAI,CAACP,WAAL,EAAkB;AAChB,iBAAO,IAAP;AACD;AACF,OAxVH;;AA2VE;;;;;;;;AAQAuB,oBAAe,sBAAS1B,MAAT,EAAiB9B,KAAjB,EACf;AACE,YAAI+B,QAAQD,OAAO2B,WAAnB;AACA,aAAK5B,cAAL,CAAoBC,MAApB,EAA4BC,KAA5B,EAAmC/B,KAAnC,EAA0C,KAA1C,EAAiD,IAAjD;AACA,aAAKqD,iBAAL,CAAuBtB,KAAvB,EAA8B/B,KAA9B,EAAqC,IAArC;AACA,aAAKsD,aAAL,CAAmBvB,KAAnB,EAA0B/B,KAA1B,EAAiC,IAAjC;;AAEA;AACA,YAAIH,SAASG,MAAMC,SAAnB;AACA,YAAIJ,MAAJ,EACA;AACE,eAAK,IAAI2B,IAAE,CAAN,EAASC,IAAE5B,OAAO6B,MAAvB,EAA+BF,IAAEC,CAAjC,EAAoCD,GAApC,EAAyC;AACvC,iBAAKgC,YAAL,CAAkB1B,MAAlB,EAA0BjC,OAAO2B,CAAP,CAA1B;AACD;AACF;AACF,OAlXH;;AAqXE;;;;;;;;AAQAkC,cAAS,gBAAS3B,KAAT,EAAgB/B,KAAhB,EAAuBgC,IAAvB,EACT;AACE,aAAKH,cAAL,CAAoBE,MAAM4B,SAA1B,EAAqC5B,KAArC,EAA4C/B,KAA5C,EAAmDgC,IAAnD,EAAyD,IAAzD;AACA,aAAKqB,iBAAL,CAAuBtB,KAAvB,EAA8B/B,KAA9B,EAAqC,IAArC;AACA,aAAKsD,aAAL,CAAmBvB,KAAnB,EAA0B/B,KAA1B,EAAiC,IAAjC;;AAEA;AACA,YAAIH,SAASG,MAAMC,SAAnB;AACA,YAAIJ,MAAJ,EACA;AACE,eAAK,IAAI2B,IAAE,CAAN,EAASC,IAAE5B,OAAO6B,MAAvB,EAA+BF,IAAEC,CAAjC,EAAoCD,GAApC,EAAyC;AACvC,iBAAKkC,MAAL,CAAY3B,KAAZ,EAAmBlC,OAAO2B,CAAP,CAAnB,EAA8BQ,IAA9B;AACD;AACF;AACF,OA3YH;;AA8YE;;;;;;;;AAQA4B,wBAAmB,0BAAS9B,MAAT,EAAiB9B,KAAjB,EAAwB;AACzC,YAAI+B,QAAQD,OAAO2B,WAAnB;AACA,YAAI,CAAC,KAAK5B,cAAL,CAAoBC,MAApB,EAA4BC,KAA5B,EAAmC/B,KAAnC,CAAD,IACF,CAAC,KAAKqD,iBAAL,CAAuBtB,KAAvB,EAA8B/B,KAA9B,CADC,IAEF,CAAC,KAAKsD,aAAL,CAAmBvB,KAAnB,EAA0B/B,KAA1B,CAFH,EAGA;AACE,iBAAO,KAAP;AACD;;AAED;AACA,YAAIH,SAASG,MAAMC,SAAnB;AACA,YAAIJ,MAAJ,EACA;AACE,eAAK,IAAI2B,IAAE,CAAN,EAASC,IAAE5B,OAAO6B,MAAvB,EAA+BF,IAAEC,CAAjC,EAAoCD,GAApC,EAAyC;AACvC,gBAAI,CAAC,KAAKoC,gBAAL,CAAsB9B,MAAtB,EAA8BjC,OAAO2B,CAAP,CAA9B,CAAL,EAA+C;AAC7C,qBAAO,KAAP;AACD;AACF;AACF;;AAED,eAAO,IAAP;AACD,OA3aH;;AA8aE;;;;;;;;AAQAqC,uBAAkB,yBAAS9B,KAAT,EAAgB/B,KAAhB,EAAuB;AACvC,YAAI,CAAC,KAAK6B,cAAL,CAAoBE,MAAM4B,SAA1B,EAAqC5B,KAArC,EAA4C/B,KAA5C,CAAD,IACF,CAAC,KAAKqD,iBAAL,CAAuBtB,KAAvB,EAA8B/B,KAA9B,CADC,IAEF,CAAC,KAAKsD,aAAL,CAAmBvB,KAAnB,EAA0B/B,KAA1B,CAFH,EAGA;AACE,iBAAO,KAAP;AACD;;AAED;AACA,YAAIH,SAASG,MAAMC,SAAnB;AACA,YAAIJ,MAAJ,EAAY;AACV,eAAK,IAAI2B,IAAE,CAAN,EAASC,IAAE5B,OAAO6B,MAAvB,EAA+BF,IAAEC,CAAjC,EAAoCD,GAApC,EAAyC;AACvC,gBAAI,CAAC,KAAKsC,GAAL,CAAS/B,KAAT,EAAgBlC,OAAO2B,CAAP,CAAhB,CAAL,EAAiC;AAC/B,qBAAO,KAAP;AACD;AACF;AACF;;AAED,eAAO,IAAP;AACD,OAzcH;;AA6cE;;;;;;AAMA;;;;;;;AAOAd,uBAAkB,2BAAW;AAC3B,eAAO,gBAAgB,KAAKf,IAArB,GAA4B,GAAnC;AACD,OA5dH;;AA+dE;AACAmB,kBAAa,EAhef;;AAmeE;;;;;;;;;;;;;AAaA+B,6BAEU,+BAAS7C,KAAT,EAAgB+D,YAAhB,EAA8BC,YAA9B,EAA4CC,YAA5C,EACR;AACE,iBAASC,eAAT,GACA;AACE;AACAD,uBAAarC,KAAb,CAAmB,IAAnB,EAAyBuC,SAAzB;;AAEA;AACA,iBAAOJ,aAAanC,KAAb,CAAmB,IAAnB,EAAyBuC,SAAzB,CAAP;AACD;;AAEDJ,qBAAaK,OAAb,GAAuBF,eAAvB;AACA,eAAOA,eAAP;AACD,OA/fL;;AAqgBE;AACAG,qBAGE;AACE,kBAAe,QADjB,EAC2B;AACzB,mBAAe,QAFjB,EAE2B;AACzB,mBAAe,QAHjB,EAG2B;AACzB,sBAAe,QAJjB,EAI2B;AACzB,kBAAe,QALjB,CAK2B;AAL3B,OAzgBJ;;AAqhBE;;;;;;;AAOAtE,wBAEU,0BAASJ,IAAT,EAAeC,MAAf,EACR;AAEE;AACE;AACA,cAAI0E,UAAU,KAAKD,aAAnB;;AAEA,eAAK,IAAInC,GAAT,IAAgBtC,MAAhB,EACA;AACE,gBAAI0E,QAAQpC,GAAR,MAAiBjB,SAArB,EAAgC;AAC9B,oBAAM,IAAIsB,KAAJ,CAAU,4BAA4BL,GAA5B,GAAkC,cAAlC,GAAmDvC,IAAnD,GAA0D,mBAApE,CAAN;AACD;;AAED,gBAAIC,OAAOsC,GAAP,KAAe,IAAnB,EAAyB;AACvB,oBAAM,IAAIK,KAAJ,CAAU,kBAAkBL,GAAlB,GAAwB,kBAAxB,GAA6CvC,IAA7C,GAAoD,iCAA9D,CAAN;AACD;;AAED,gBAAI2E,QAAQpC,GAAR,MAAiB,IAAjB,IAAyB,QAAOtC,OAAOsC,GAAP,CAAP,MAAuBoC,QAAQpC,GAAR,CAApD,EAAkE;AAChE,oBAAM,IAAIK,KAAJ,CAAU,0BAA0BL,GAA1B,GAAgC,kBAAhC,GAAqDvC,IAArD,GAA4D,kCAA5D,GAAiG2E,QAAQpC,GAAR,CAAjG,GAAgH,IAA1H,CAAN;AACD;AACF;;AAED;AACA,cAAIqC,OAAO,CAAE,SAAF,EAAa,SAAb,EAAwB,YAAxB,EAAsC,QAAtC,CAAX;AACA,eAAK,IAAI/C,IAAE,CAAN,EAASC,IAAE8C,KAAK7C,MAArB,EAA6BF,IAAEC,CAA/B,EAAkCD,GAAlC,EACA;AACE,gBAAIU,MAAMqC,KAAK/C,CAAL,CAAV;;AAEA,gBAAI5B,OAAOsC,GAAP,MAAgBjB,SAAhB,KACC,CACE,OADF,EAEE,QAFF,EAGE,MAHF,EAIEuD,OAJF,CAIUnF,GAAGC,SAAH,CAAaQ,QAAb,CAAsBF,OAAOsC,GAAP,CAAtB,CAJV,KAIiD,CAAC,CAJlD,IAKAtC,OAAOsC,GAAP,EAAYM,SAAZ,KAA0BvB,SAN3B,CAAJ,EAM2C;AACzC,oBAAM,IAAIsB,KAAJ,CAAU,kBAAkBL,GAAlB,GAAwB,kBAAxB,GAA6CvC,IAA7C,GAAoD,iCAA9D,CAAN;AACD;AACF;;AAED;AACA,cAAIC,OAAOC,MAAX,EACA;AACE,iBAAK,IAAI2B,IAAE,CAAN,EAASiD,IAAE7E,OAAOC,MAAlB,EAA0B4B,IAAEgD,EAAE/C,MAAnC,EAA2CF,IAAEC,CAA7C,EAAgDD,GAAhD,EACA;AACE,kBAAIiD,EAAEjD,CAAF,KAAQ,IAAZ,EAAkB;AAChB,sBAAM,IAAIe,KAAJ,CAAU,kEAAkEf,CAAlE,GAAoE,CAApE,GAAwE,kBAAxE,GAA6F7B,IAA7F,GAAoG,sBAA9G,CAAN;AACD;;AAED,kBAAI8E,EAAEjD,CAAF,EAAKhB,MAAL,KAAgB,WAApB,EAAiC;AAC/B,sBAAM,IAAI+B,KAAJ,CAAU,kEAAkEf,CAAlE,GAAoE,CAApE,GAAwE,kBAAxE,GAA6F7B,IAA7F,GAAoG,wBAA9G,CAAN;AACD;AACF;AACF;;AAED;AACA,cAAIC,OAAOF,OAAX,EACA;AACE,iBAAK,IAAIwC,GAAT,IAAgBtC,OAAOF,OAAvB,EACA;AACE,kBAAIwC,IAAIwC,WAAJ,OAAsBxC,GAA1B,EAA+B;AAC7B,sBAAM,IAAIK,KAAJ,CAAU,kBAAkBL,GAAlB,GAAwB,kBAAxB,GAA6CvC,IAA7C,GAAoD,4CAA9D,CAAN;AACD;;AAED,8BAAcC,OAAOF,OAAP,CAAewC,GAAf,CAAd;AAEE,qBAAK,SAAL;AACA,qBAAK,QAAL;AACA,qBAAK,QAAL;AACE;;AAEF;AACE,wBAAM,IAAIK,KAAJ,CAAU,kBAAkBL,GAAlB,GAAwB,kBAAxB,GAA6CvC,IAA7C,GAAoD,sDAA9D,CAAN;AARJ;AAUD;AACF;AACF;AACF;AA1mBL;AAFF,GADA,C;AA3BAN,KAAGwB,SAAH,CAAarB,aAAb,GAA6BA,aAA7B",
  "file": "Interface.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Andreas Ecker (ecker)\n\n************************************************************************ */\n\n/**\n * This class is used to define interfaces (similar to Java interfaces).\n *\n * See the description of the {@link #define} method how an interface is\n * defined.\n *\n * @require(qx.lang.normalize.Array)\n */\nqx.Bootstrap.define(\"qx.Interface\",\n{\n  statics :\n  {\n    /*\n    ---------------------------------------------------------------------------\n       PUBLIC API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Define a new interface. Interface definitions look much like class definitions.\n     *\n     * The main difference is that the bodies of functions defined in <code>members</code>\n     * and <code>statics</code> are called before the original function with the\n     * same arguments. This can be used to check the passed arguments. If the\n     * checks fail, an exception should be thrown. It is convenient to use the\n     * method defined in {@link qx.core.MAssert} to check the arguments.\n     *\n     * In the <code>build</code> version the checks are omitted.\n     *\n     * For properties only the names are required so the value of the properties\n     * can be empty maps.\n     *\n     * Example:\n     * <pre class='javascript'>\n     * qx.Interface.define(\"name\",\n     * {\n     *   extend: [SuperInterfaces],\n     *\n     *   statics:\n     *   {\n     *     PI : 3.14\n     *   },\n     *\n     *   properties: {\"color\": {}, \"name\": {} },\n     *\n     *   members:\n     *   {\n     *     meth1: function() {},\n     *     meth2: function(a, b) { this.assertArgumentsCount(arguments, 2, 2); },\n     *     meth3: function(c) { this.assertInterface(c.constructor, qx.some.Interface); }\n     *   },\n     *\n     *   events :\n     *   {\n     *     keydown : \"qx.event.type.KeySequence\"\n     *   }\n     * });\n     * </pre>\n     *\n     * @param name {String} name of the interface\n     * @param config {Map ? null} Interface definition structure. The configuration map has the following keys:\n     *   <table>\n     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>\n     *     <tr><th>extend</th><td>Interface |<br>Interface[]</td><td>Single interface or array of interfaces this interface inherits from.</td></tr>\n     *     <tr><th>members</th><td>Map</td><td>Map of members of the interface.</td></tr>\n     *     <tr><th>statics</th><td>Map</td><td>\n     *         Map of statics of the interface. The statics will not get copied into the target class.\n     *         This is the same behaviour as statics in mixins ({@link qx.Mixin#define}).\n     *     </td></tr>\n     *     <tr><th>properties</th><td>Map</td><td>Map of properties and their definitions.</td></tr>\n     *     <tr><th>events</th><td>Map</td><td>Map of event names and the corresponding event class name.</td></tr>\n     *   </table>\n     *\n     * @return {qx.Interface} The configured interface\n     */\n    define : function(name, config)\n    {\n      if (config)\n      {\n        // Normalize include\n        if (config.extend && !(qx.Bootstrap.getClass(config.extend) === \"Array\")) {\n          config.extend = [config.extend];\n        }\n\n        // Validate incoming data\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          this.__validateConfig(name, config);\n        }\n\n        // Create interface from statics\n        var iface = config.statics ? config.statics : {};\n\n        // Attach configuration\n        if (config.extend) {\n          iface.$$extends = config.extend;\n        }\n\n        if (config.properties) {\n          iface.$$properties = config.properties;\n        }\n\n        if (config.members) {\n          iface.$$members = config.members;\n        }\n\n        if (config.events) {\n          iface.$$events = config.events;\n        }\n      }\n      else\n      {\n        // Create empty interface\n        var iface = {};\n      }\n\n      // Add Basics\n      iface.$$type = \"Interface\";\n      iface.name = name;\n\n      // Attach toString\n      iface.toString = this.genericToString;\n\n      // Assign to namespace\n      iface.basename = qx.Bootstrap.createNamespace(name, iface);\n\n      // Add to registry\n      qx.Interface.$$registry[name] = iface;\n\n      // Return final interface\n      return iface;\n    },\n\n\n    /**\n     * Returns an interface by name\n     *\n     * @param name {String} class name to resolve\n     * @return {Class} the class\n     */\n    getByName : function(name) {\n      return this.$$registry[name];\n    },\n\n\n    /**\n     * Determine if interface exists\n     *\n     * @param name {String} Interface name to check\n     * @return {Boolean} true if interface exists\n     */\n    isDefined : function(name) {\n      return this.getByName(name) !== undefined;\n    },\n\n\n    /**\n     * Determine the number of interfaces which are defined\n     *\n     * @return {Number} the number of interfaces\n     */\n    getTotalNumber : function() {\n      return qx.Bootstrap.objectGetLength(this.$$registry);\n    },\n\n\n    /**\n     * Generates a list of all interfaces including their super interfaces\n     * (resolved recursively)\n     *\n     * @param ifaces {Interface[] ? []} List of interfaces to be resolved\n     * @return {Array} List of all interfaces\n     */\n    flatten : function(ifaces)\n    {\n      if (!ifaces) {\n        return [];\n      }\n\n      // we need to create a copy and not to modify the existing array\n      var list = ifaces.concat();\n\n      for (var i=0, l=ifaces.length; i<l; i++)\n      {\n        if (ifaces[i].$$extends) {\n          list.push.apply(list, this.flatten(ifaces[i].$$extends));\n        }\n      }\n\n      return list;\n    },\n\n\n    /**\n     * Assert members\n     *\n     * @param object {qx.core.Object} The object, which contains the methods\n     * @param clazz {Class} class of the object\n     * @param iface {Interface} the interface to verify\n     * @param wrap {Boolean ? false} wrap functions required by interface to\n     *     check parameters etc.\n     * @param shouldThrow {Boolean} if <code>false</code>, the method\n     *   will return a boolean instead of throwing an exception\n     * @return {Boolean} <code>true</code> if all members are supported\n     */\n    __checkMembers : function(object, clazz, iface, wrap, shouldThrow)\n    {\n      // Validate members\n      var members = iface.$$members;\n      if (members) {\n        for (var key in members) {\n          if (qx.Bootstrap.isFunction(members[key])) {\n            var isPropertyMethod = this.__isPropertyMethod(clazz, key);\n            var hasMemberFunction = isPropertyMethod || qx.Bootstrap.isFunction(object[key]);\n\n            if (!hasMemberFunction) {\n              if (shouldThrow) {\n                throw new Error(\n                    'Implementation of method \"' + key +\n                    '\" is missing in class \"' + clazz.classname +\n                    '\" required by interface \"' + iface.name + '\"'\n                );\n              } else {\n                return false;\n              }\n            }\n\n            // Only wrap members if the interface was not been applied yet. This\n            // can easily be checked by the recursive hasInterface method.\n            var shouldWrapFunction =\n              wrap === true &&\n              !isPropertyMethod &&\n              !qx.util.OOUtil.hasInterface(clazz, iface);\n\n            if (shouldWrapFunction) {\n              object[key] = this.__wrapInterfaceMember(\n                iface, object[key], key, members[key]\n              );\n            }\n          } else {\n            // Other members are not checked more detailed because of\n            // JavaScript's loose type handling\n            if (typeof object[key] === undefined) {\n              if (typeof object[key] !== \"function\") {\n                if (shouldThrow) {\n                  throw new Error(\n                    'Implementation of member \"' + key +\n                    '\" is missing in class \"' + clazz.classname +\n                    '\" required by interface \"' + iface.name + '\"'\n                  );\n                } else {\n                  return false;\n                }\n              }\n            }\n          }\n        }\n      }\n      if (!shouldThrow) {\n        return true;\n      }\n    },\n\n\n    /**\n     * Internal helper to detect if the method will be generated by the\n     * property system.\n     *\n     * @param clazz {Class} The current class.\n     * @param methodName {String} The name of the method.\n     *\n     * @return {Boolean} true, if the method will be generated by the property\n     *   system.\n     */\n    __isPropertyMethod: function(clazz, methodName)\n    {\n      var match = methodName.match(/^(is|toggle|get|set|reset)(.*)$/);\n\n      if (!match) {\n        return false;\n      }\n\n      var propertyName = qx.Bootstrap.firstLow(match[2]);\n      var isPropertyMethod = qx.util.OOUtil.getPropertyDefinition(clazz, propertyName);\n      if (!isPropertyMethod) {\n        return false;\n      }\n\n      var isBoolean = match[0] === \"is\" || match[0] === \"toggle\";\n      if (isBoolean) {\n        return qx.util.OOUtil.getPropertyDefinition(clazz, propertyName).check === \"Boolean\";\n      }\n\n      return true;\n    },\n\n\n    /**\n     * Assert properties\n     *\n     * @param clazz {Class} class to check interface for\n     * @param iface {Interface} the interface to verify\n     * @param shouldThrow {Boolean} if <code>false</code>, the method\n     *   will return a boolean instead of throwing an exception\n     * @return {Boolean} <code>true</code> if all properties are supported\n     */\n    __checkProperties : function(clazz, iface, shouldThrow)\n    {\n      if (iface.$$properties) {\n        for (var key in iface.$$properties) {\n          if (!qx.util.OOUtil.getPropertyDefinition(clazz, key)) {\n            if (shouldThrow) {\n              throw new Error(\n                'The property \"' + key + '\" is not supported by Class \"' +\n                clazz.classname + '\"!'\n              );\n            } else {\n              return false;\n            }\n          }\n        }\n      }\n      if (!shouldThrow) {\n        return true;\n      }\n    },\n\n\n    /**\n     * Assert events\n     *\n     * @param clazz {Class} class to check interface for\n     * @param iface {Interface} the interface to verify\n     * @param shouldThrow {Boolean} if <code>false</code>, the method\n     *   will return a boolean instead of throwing an exception\n     * @return {Boolean} <code>true</code> if all events are supported\n     */\n    __checkEvents : function(clazz, iface, shouldThrow)\n    {\n      if (iface.$$events) {\n        for (var key in iface.$$events) {\n          if (!qx.util.OOUtil.supportsEvent(clazz, key)) {\n            if (shouldThrow) {\n              throw new Error(\n                'The event \"' + key + '\" is not supported by Class \"' +\n                clazz.classname + '\"!'\n              );\n            } else {\n              return false;\n            }\n          }\n        }\n      }\n      if (!shouldThrow) {\n        return true;\n      }\n    },\n\n\n    /**\n     * Asserts that the given object implements all the methods defined in the\n     * interface. This method throws an exception if the object does not\n     * implement the interface.\n     *\n     *  @param object {qx.core.Object} Object to check interface for\n     *  @param iface {Interface} The interface to verify\n     */\n    assertObject : function(object, iface)\n    {\n      var clazz = object.constructor;\n      this.__checkMembers(object, clazz, iface, false, true);\n      this.__checkProperties(clazz, iface, true);\n      this.__checkEvents(clazz, iface, true);\n\n      // Validate extends, recursive\n      var extend = iface.$$extends;\n      if (extend)\n      {\n        for (var i=0, l=extend.length; i<l; i++) {\n          this.assertObject(object, extend[i]);\n        }\n      }\n    },\n\n\n    /**\n     * Checks if an interface is implemented by a class\n     *\n     * @param clazz {Class} class to check interface for\n     * @param iface {Interface} the interface to verify\n     * @param wrap {Boolean ? false} wrap functions required by interface to\n     *     check parameters etc.\n     */\n    assert : function(clazz, iface, wrap)\n    {\n      this.__checkMembers(clazz.prototype, clazz, iface, wrap, true);\n      this.__checkProperties(clazz, iface, true);\n      this.__checkEvents(clazz, iface, true);\n\n      // Validate extends, recursive\n      var extend = iface.$$extends;\n      if (extend)\n      {\n        for (var i=0, l=extend.length; i<l; i++) {\n          this.assert(clazz, extend[i], wrap);\n        }\n      }\n    },\n\n\n    /**\n     * Asserts that the given object implements all the methods defined in the\n     * interface.\n     *\n     *  @param object {qx.core.Object} Object to check interface for\n     *  @param iface {Interface} The interface to verify\n     * @return {Boolean} <code>true</code> if the objects implements the interface\n     */\n    objectImplements : function(object, iface) {\n      var clazz = object.constructor;\n      if (!this.__checkMembers(object, clazz, iface) ||\n        !this.__checkProperties(clazz, iface) ||\n        !this.__checkEvents(clazz, iface))\n      {\n        return false;\n      }\n\n      // Validate extends, recursive\n      var extend = iface.$$extends;\n      if (extend)\n      {\n        for (var i=0, l=extend.length; i<l; i++) {\n          if (!this.objectImplements(object, extend[i])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n\n\n    /**\n     * Tests whether an interface is implemented by a class, without throwing an\n     * exception when it doesn't.\n     *\n     * @param clazz {Class} class to check interface for\n     * @param iface {Interface} the interface to verify\n     * @return {Boolean} <code>true</code> if interface is implemented\n     */\n    classImplements : function(clazz, iface) {\n      if (!this.__checkMembers(clazz.prototype, clazz, iface) ||\n        !this.__checkProperties(clazz, iface) ||\n        !this.__checkEvents(clazz, iface))\n      {\n        return false;\n      }\n\n      // Validate extends, recursive\n      var extend = iface.$$extends;\n      if (extend) {\n        for (var i=0, l=extend.length; i<l; i++) {\n          if (!this.has(clazz, extend[i])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n       PRIVATE/INTERNAL API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * This method will be attached to all interface to return\n     * a nice identifier for them.\n     *\n     * @internal\n     * @return {String} The interface identifier\n     */\n    genericToString : function() {\n      return \"[Interface \" + this.name + \"]\";\n    },\n\n\n    /** Registry of all defined interfaces */\n    $$registry : {},\n\n\n    /**\n     * Wrap a method with a precondition check.\n     *\n     * @signature function(iface, origFunction, functionName, preCondition)\n     * @param iface {String} Name of the interface, where the pre condition\n     *   was defined. (Used in error messages).\n     * @param origFunction {Function} function to wrap.\n     * @param functionName {String} name of the function. (Used in error messages).\n     * @param preCondition {Function}. This function gets called with the arguments of the\n     *   original function. If this function return true the original function is called.\n     *   Otherwise an exception is thrown.\n     * @return {Function} wrapped function\n     */\n    __wrapInterfaceMember : qx.core.Environment.select(\"qx.debug\",\n    {\n      \"true\": function(iface, origFunction, functionName, preCondition)\n      {\n        function wrappedFunction()\n        {\n          // call precondition\n          preCondition.apply(this, arguments);\n\n          // call original function\n          return origFunction.apply(this, arguments);\n        }\n\n        origFunction.wrapper = wrappedFunction;\n        return wrappedFunction;\n      },\n\n      \"default\" : function(iface, origFunction, functionName, preCondition) {}\n    }),\n\n\n    /** @type {Map} allowed keys in interface definition */\n    __allowedKeys : qx.core.Environment.select(\"qx.debug\",\n    {\n      \"true\":\n      {\n        \"extend\"     : \"object\", // Interface | Interface[]\n        \"statics\"    : \"object\", // Map\n        \"members\"    : \"object\", // Map\n        \"properties\" : \"object\", // Map\n        \"events\"     : \"object\"  // Map\n      },\n\n      \"default\" : null\n    }),\n\n\n    /**\n     * Validates incoming configuration and checks keys and values\n     *\n     * @signature function(name, config)\n     * @param name {String} The name of the class\n     * @param config {Map} Configuration map\n     */\n    __validateConfig : qx.core.Environment.select(\"qx.debug\",\n    {\n      \"true\": function(name, config)\n      {\n        if (qx.core.Environment.get(\"qx.debug\"))\n        {\n          // Validate keys\n          var allowed = this.__allowedKeys;\n\n          for (var key in config)\n          {\n            if (allowed[key] === undefined) {\n              throw new Error('The configuration key \"' + key + '\" in class \"' + name + '\" is not allowed!');\n            }\n\n            if (config[key] == null) {\n              throw new Error(\"Invalid key '\" + key + \"' in interface '\" + name + \"'! The value is undefined/null!\");\n            }\n\n            if (allowed[key] !== null && typeof config[key] !== allowed[key]) {\n              throw new Error('Invalid type of key \"' + key + '\" in interface \"' + name + '\"! The type of the key must be \"' + allowed[key] + '\"!');\n            }\n          }\n\n          // Validate maps\n          var maps = [ \"statics\", \"members\", \"properties\", \"events\" ];\n          for (var i=0, l=maps.length; i<l; i++)\n          {\n            var key = maps[i];\n\n            if (config[key] !== undefined &&\n                ([\n                   \"Array\",\n                   \"RegExp\",\n                   \"Date\"\n                 ].indexOf(qx.Bootstrap.getClass(config[key])) != -1 ||\n                 config[key].classname !== undefined)) {\n              throw new Error('Invalid key \"' + key + '\" in interface \"' + name + '\"! The value needs to be a map!');\n            }\n          }\n\n          // Validate extends\n          if (config.extend)\n          {\n            for (var i=0, a=config.extend, l=a.length; i<l; i++)\n            {\n              if (a[i] == null) {\n                throw new Error(\"Extends of interfaces must be interfaces. The extend number '\" + i+1 + \"' in interface '\" + name + \"' is undefined/null!\");\n              }\n\n              if (a[i].$$type !== \"Interface\") {\n                throw new Error(\"Extends of interfaces must be interfaces. The extend number '\" + i+1 + \"' in interface '\" + name + \"' is not an interface!\");\n              }\n            }\n          }\n\n          // Validate statics\n          if (config.statics)\n          {\n            for (var key in config.statics)\n            {\n              if (key.toUpperCase() !== key) {\n                throw new Error('Invalid key \"' + key + '\" in interface \"' + name + '\"! Static constants must be all uppercase.');\n              }\n\n              switch(typeof config.statics[key])\n              {\n                case \"boolean\":\n                case \"string\":\n                case \"number\":\n                  break;\n\n                default:\n                  throw new Error('Invalid key \"' + key + '\" in interface \"' + name + '\"! Static constants must be all of a primitive type.');\n              }\n            }\n          }\n        }\n      },\n\n      \"default\" : function(name, config) {}\n    })\n  }\n});\n"
  ]
}