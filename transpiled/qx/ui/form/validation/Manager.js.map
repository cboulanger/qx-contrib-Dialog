{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/form/validation/Manager.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "__formItems",
    "__asyncResults",
    "setRequiredFieldMessage",
    "locale",
    "Manager",
    "tr",
    "events",
    "properties",
    "validator",
    "check",
    "init",
    "nullable",
    "invalidMessage",
    "requiredFieldMessage",
    "context",
    "members",
    "__valid",
    "__syncValid",
    "add",
    "formItem",
    "__supportsInvalid",
    "Error",
    "__supportsSingleSelection",
    "getValue",
    "dataEntry",
    "item",
    "valid",
    "push",
    "remove",
    "items",
    "i",
    "len",
    "length",
    "splice",
    "getItems",
    "validate",
    "validatorResult",
    "_validateRequired",
    "_validateItem",
    "formValid",
    "__validateForm",
    "lang",
    "Type",
    "isBoolean",
    "_setValid",
    "isEmpty",
    "fireEvent",
    "getRequired",
    "getSelection",
    "__supportsDataBindingSelection",
    "getLength",
    "value",
    "setValid",
    "individualMessage",
    "getRequiredInvalidMessage",
    "message",
    "getRequiredFieldMessage",
    "setInvalidMessage",
    "__isAsyncValidator",
    "toHashCode",
    "call",
    "undefined",
    "e",
    "ValidationError",
    "type",
    "BaseError",
    "DEFAULTMESSAGE",
    "getComment",
    "formValidator",
    "getValidator",
    "getContext",
    "validateForm",
    "async",
    "isFunction",
    "isSubClassOf",
    "constructor",
    "ui",
    "form",
    "validation",
    "AsyncValidator",
    "clazz",
    "hasInterface",
    "IForm",
    "ISingleSelection",
    "data",
    "controller",
    "ISelection",
    "_showToolTip",
    "oldValue",
    "fireDataEvent",
    "tooltip",
    "getInstance",
    "getSharedErrorTooltip",
    "firstInvalid",
    "isValid",
    "getContentLocation",
    "isSeeable",
    "setLabel",
    "getInvalidMessage",
    "getPlaceMethod",
    "location",
    "top",
    "getOffsetTop",
    "placeToPoint",
    "left",
    "right",
    "placeToWidget",
    "show",
    "exclude",
    "getValid",
    "getInvalidMessages",
    "messages",
    "getInvalidFormItems",
    "res",
    "reset",
    "setItemValid",
    "__checkValidationComplete",
    "setFormValid",
    "hash",
    "currentResult",
    "destruct"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAAA,KAAGC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC,EAuBAH,GAAGI,KAAH,CAASC,MAAT,CAAgB,+BAAhB,EACA;AACEC,YAASN,GAAGO,IAAH,CAAQC,MADnB;;AAGEC,eAAY,qBACZ;AACE;;AAEA;AACA,WAAKC,WAAL,GAAmB,EAAnB;AACA;AACA,WAAKC,cAAL,GAAsB,EAAtB;AACA;AACA,WAAKC,uBAAL,CAA6BZ,GAAGa,MAAH,CAAUC,OAAV,CAAkBC,EAAlB,CAAqB,wBAArB,CAA7B;AACD,KAbH;;AAgBEC,YACA;AACE;;;AAGA,qBAAgB,oBAJlB;;AAME;;;;;AAKA,kBAAa;AAXf,KAjBF;;AAgCEC,gBACA;AACE;;;;;;;;;;;AAWAC,iBACA;AACEC,eAAQ,6GADV;AAEEC,cAAO,IAFT;AAGEC,kBAAW;AAHb,OAbF;;AAmBE;;;;;AAKAC,sBACA;AACEH,eAAQ,QADV;AAEEC,cAAM;AAFR,OAzBF;;AA+BE;;;;AAIAG,4BACA;AACEJ,eAAQ,QADV;AAEEC,cAAO;AAFT,OApCF;;AA0CE;;;AAGAI,eACA;AACEH,kBAAW;AADb;AA9CF,KAjCF;;AAqFEI,aACA;AACEf,mBAAc,IADhB;AAEEgB,eAAU,IAFZ;AAGEf,sBAAiB,IAHnB;AAIEgB,mBAAc,IAJhB;;AAOE;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BAC,WAAK,aAASC,QAAT,EAAmBX,SAAnB,EAA8BM,OAA9B,EAAuC;AAC1C;AACA,YAAI,CAAC,KAAKM,iBAAL,CAAuBD,QAAvB,CAAL,EAAuC;AACrC,gBAAM,IAAIE,KAAJ,CAAU,6BAAV,CAAN;AACD;AACD;AACA,YAAI,KAAKC,yBAAL,CAA+BH,QAA/B,KAA4C,CAACA,SAASI,QAA1D,EAAoE;AAClE;AACA,cAAIf,aAAa,IAAjB,EAAuB;AACrB,kBAAM,IAAIa,KAAJ,4EAAN;AAED;AACF;AACD,YAAIG,YACJ;AACEC,gBAAON,QADT;AAEEX,qBAAYA,SAFd;AAGEkB,iBAAQ,IAHV;AAIEZ,mBAAUA;AAJZ,SADA;AAOA,aAAKd,WAAL,CAAiB2B,IAAjB,CAAsBH,SAAtB;AACD,OAxDH;;AA2DE;;;;;;;AAOAI,cAAS,gBAAST,QAAT,EACT;AACE,YAAIU,QAAQ,KAAK7B,WAAjB;;AAEA,aAAK,IAAI8B,IAAI,CAAR,EAAWC,MAAMF,MAAMG,MAA5B,EAAoCF,IAAIC,GAAxC,EAA6CD,GAA7C,EACA;AACE,cAAIX,aAAaU,MAAMC,CAAN,EAASL,IAA1B,EACA;AACEI,kBAAMI,MAAN,CAAaH,CAAb,EAAgB,CAAhB;AACA,mBAAOX,QAAP;AACD;AACF;;AAED,eAAO,IAAP;AACD,OAhFH;;AAmFE;;;;;AAKAe,gBAAW,oBACX;AACE,YAAIL,QAAQ,EAAZ;AACA,aAAK,IAAIC,IAAE,CAAX,EAAcA,IAAI,KAAK9B,WAAL,CAAiBgC,MAAnC,EAA2CF,GAA3C,EAAgD;AAC9CD,gBAAMF,IAAN,CAAW,KAAK3B,WAAL,CAAiB8B,CAAjB,EAAoBL,IAA/B;AACD;AACD,eAAOI,KAAP;AACD,OA/FH;;AAkGE;;;;;;;;;;;AAWAM,gBAAW,oBAAW;AACpB,YAAIT,QAAQ,IAAZ;AACA,aAAKT,WAAL,GAAmB,IAAnB,CAFoB,CAEK;AACzB,YAAIY,QAAQ,EAAZ;;AAEA;AACA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,KAAK9B,WAAL,CAAiBgC,MAArC,EAA6CF,GAA7C,EAAkD;AAChD,cAAIX,WAAW,KAAKnB,WAAL,CAAiB8B,CAAjB,EAAoBL,IAAnC;AACA,cAAIjB,YAAY,KAAKR,WAAL,CAAiB8B,CAAjB,EAAoBtB,SAApC;;AAEA;AACAqB,gBAAMF,IAAN,CAAWR,QAAX;;AAEA;AACA,cAAIX,aAAa,IAAjB,EAAuB;AACrB;AACA,gBAAI4B,kBAAkB,KAAKC,iBAAL,CAAuBlB,QAAvB,CAAtB;AACAO,oBAAQA,SAASU,eAAjB;AACA,iBAAKnB,WAAL,GAAmBmB,mBAAmB,KAAKnB,WAA3C;AACA;AACD;;AAED,cAAImB,kBAAkB,KAAKE,aAAL,CACpB,KAAKtC,WAAL,CAAiB8B,CAAjB,CADoB,EACCX,SAASI,QAAT,EADD,CAAtB;AAGA;AACAG,kBAAQU,mBAAmBV,KAA3B;AACA,cAAIU,mBAAmB,IAAvB,EAA6B;AAC3B,iBAAKnB,WAAL,GAAmBmB,mBAAmB,KAAKnB,WAA3C;AACD;AACF;;AAED;AACA;AACA,YAAIsB,YAAY,KAAKC,cAAL,CAAoBX,KAApB,CAAhB;AACA,YAAIvC,GAAGmD,IAAH,CAAQC,IAAR,CAAaC,SAAb,CAAuBJ,SAAvB,CAAJ,EAAuC;AACrC,eAAKtB,WAAL,GAAmBsB,aAAa,KAAKtB,WAArC;AACD;AACDS,gBAAQa,aAAab,KAArB;;AAEA,aAAKkB,SAAL,CAAelB,KAAf;;AAEA,YAAIpC,GAAGmD,IAAH,CAAQ3C,MAAR,CAAe+C,OAAf,CAAuB,KAAK5C,cAA5B,CAAJ,EAAiD;AAC/C,eAAK6C,SAAL,CAAe,UAAf;AACD;AACD,eAAOpB,KAAP;AACD,OA3JH;;AA8JE;;;;;;;;AAQAW,yBAAoB,2BAASlB,QAAT,EAAmB;AACrC,YAAIA,SAAS4B,WAAT,EAAJ,EAA4B;AAC1B,cAAIX,eAAJ;AACA;AACA,cAAI,KAAKd,yBAAL,CAA+BH,QAA/B,CAAJ,EAA8C;AAC5CiB,8BAAkB,CAAC,CAACjB,SAAS6B,YAAT,GAAwB,CAAxB,CAApB;AAED,WAHD,MAGO,IAAI,KAAKC,8BAAL,CAAoC9B,QAApC,CAAJ,EAAmD;AACxDiB,8BAAmBjB,SAAS6B,YAAT,GAAwBE,SAAxB,KAAsC,CAAzD;AAED,WAHM,MAGA;AACL,gBAAIC,QAAQhC,SAASI,QAAT,EAAZ;AACAa,8BAAkB,CAAC,CAACe,KAAF,IAAWA,UAAU,CAAvC;AACD;AACDhC,mBAASiC,QAAT,CAAkBhB,eAAlB;AACA,cAAIiB,oBAAoBlC,SAASmC,yBAAT,EAAxB;AACA,cAAIC,UAAUF,oBAAoBA,iBAApB,GAAwC,KAAKG,uBAAL,EAAtD;AACArC,mBAASsC,iBAAT,CAA2BF,OAA3B;AACA,iBAAOnB,eAAP;AACD;AACD,eAAO,IAAP;AACD,OA3LH;;AA8LE;;;;;;;;;;;AAWAE,qBAAgB,uBAASd,SAAT,EAAoB2B,KAApB,EAA2B;AACzC,YAAIhC,WAAWK,UAAUC,IAAzB;AACA,YAAIX,UAAUU,UAAUV,OAAxB;AACA,YAAIN,YAAYgB,UAAUhB,SAA1B;;AAEA;AACA,YAAI,KAAKkD,kBAAL,CAAwBlD,SAAxB,CAAJ,EAAwC;AACtC;AACA,eAAKP,cAAL,CAAoBkB,SAASwC,UAAT,EAApB,IAA6C,IAA7C;AACAnD,oBAAU2B,QAAV,CAAmBhB,QAAnB,EAA6BA,SAASI,QAAT,EAA7B,EAAkD,IAAlD,EAAwDT,OAAxD;AACA,iBAAO,IAAP;AACD;;AAED,YAAIsB,kBAAkB,IAAtB;;AAEA,YAAI;AACF,cAAIA,kBAAkB5B,UAAUoD,IAAV,CAAe9C,WAAW,IAA1B,EAAgCqC,KAAhC,EAAuChC,QAAvC,CAAtB;AACA,cAAIiB,oBAAoByB,SAAxB,EAAmC;AACjCzB,8BAAkB,IAAlB;AACD;AAEF,SAND,CAME,OAAO0B,CAAP,EAAU;AACV,cAAIA,aAAaxE,GAAGO,IAAH,CAAQkE,eAAzB,EAA0C;AACxC3B,8BAAkB,KAAlB;AACA,gBAAI0B,EAAEP,OAAF,IAAaO,EAAEP,OAAF,IAAajE,GAAG0E,IAAH,CAAQC,SAAR,CAAkBC,cAAhD,EAAgE;AAC9D,kBAAItD,iBAAiBkD,EAAEP,OAAvB;AACD,aAFD,MAEO;AACL,kBAAI3C,iBAAiBkD,EAAEK,UAAF,EAArB;AACD;AACDhD,qBAASsC,iBAAT,CAA2B7C,cAA3B;AACD,WARD,MAQO;AACL,kBAAMkD,CAAN;AACD;AACF;;AAED3C,iBAASiC,QAAT,CAAkBhB,eAAlB;AACAZ,kBAAUE,KAAV,GAAkBU,eAAlB;;AAEA,eAAOA,eAAP;AACD,OAhPH;;AAmPE;;;;;;;;;;AAUAI,sBAAgB,wBAASX,KAAT,EAAgB;AAC9B,YAAIuC,gBAAgB,KAAKC,YAAL,EAApB;AACA,YAAIvD,UAAU,KAAKwD,UAAL,MAAqB,IAAnC;;AAEA,YAAIF,iBAAiB,IAArB,EAA2B;AACzB,iBAAO,IAAP;AACD;;AAED;AACA,aAAKX,iBAAL,CAAuB,EAAvB;;AAEA,YAAI,KAAKC,kBAAL,CAAwBU,aAAxB,CAAJ,EAA4C;AAC1C,eAAKnE,cAAL,CAAoB,KAAK0D,UAAL,EAApB,IAAyC,IAAzC;AACAS,wBAAcG,YAAd,CAA2B1C,KAA3B,EAAkC,IAAlC,EAAwCf,OAAxC;AACA,iBAAO,IAAP;AACD;;AAED,YAAI;AACF,cAAIyB,YAAY6B,cAAcR,IAAd,CAAmB9C,OAAnB,EAA4Be,KAA5B,EAAmC,IAAnC,CAAhB;AACA,cAAIU,cAAcsB,SAAlB,EAA6B;AAC3BtB,wBAAY,IAAZ;AACD;AACF,SALD,CAKE,OAAOuB,CAAP,EAAU;AACV,cAAIA,aAAaxE,GAAGO,IAAH,CAAQkE,eAAzB,EAA0C;AACxCxB,wBAAY,KAAZ;;AAEA,gBAAIuB,EAAEP,OAAF,IAAaO,EAAEP,OAAF,IAAajE,GAAG0E,IAAH,CAAQC,SAAR,CAAkBC,cAAhD,EAAgE;AAC9D,kBAAItD,iBAAiBkD,EAAEP,OAAvB;AACD,aAFD,MAEO;AACL,kBAAI3C,iBAAiBkD,EAAEK,UAAF,EAArB;AACD;AACD,iBAAKV,iBAAL,CAAuB7C,cAAvB;AACD,WATD,MASO;AACL,kBAAMkD,CAAN;AACD;AACF;AACD,eAAOvB,SAAP;AACD,OAlSH;;AAqSE;;;;;;;;AAQAmB,0BAAqB,4BAASlD,SAAT,EAAoB;AACvC,YAAIgE,QAAQ,KAAZ;AACA,YAAI,CAAClF,GAAGmD,IAAH,CAAQC,IAAR,CAAa+B,UAAb,CAAwBjE,SAAxB,CAAL,EAAyC;AACvCgE,kBAAQlF,GAAGI,KAAH,CAASgF,YAAT,CACNlE,UAAUmE,WADJ,EACiBrF,GAAGsF,EAAH,CAAMC,IAAN,CAAWC,UAAX,CAAsBC,cADvC,CAAR;AAGD;AACD,eAAOP,KAAP;AACD,OArTH;;AAwTE;;;;;;;;AAQApD,yBAAoB,2BAASD,QAAT,EAAmB;AACrC,YAAI6D,QAAQ7D,SAASwD,WAArB;AACA,eAAOrF,GAAGI,KAAH,CAASuF,YAAT,CAAsBD,KAAtB,EAA6B1F,GAAGsF,EAAH,CAAMC,IAAN,CAAWK,KAAxC,CAAP;AACD,OAnUH;;AAsUE;;;;;;;;AAQA5D,iCAA4B,mCAASH,QAAT,EAAmB;AAC7C,YAAI6D,QAAQ7D,SAASwD,WAArB;AACA,eAAOrF,GAAGI,KAAH,CAASuF,YAAT,CAAsBD,KAAtB,EAA6B1F,GAAGsF,EAAH,CAAM/E,IAAN,CAAWsF,gBAAxC,CAAP;AACD,OAjVH;;AAoVE;;;;;;;;AAQAlC,sCAAiC,wCAAS9B,QAAT,EAAmB;AAClD,YAAI6D,QAAQ7D,SAASwD,WAArB;AACA,eAAOrF,GAAGI,KAAH,CAASuF,YAAT,CAAsBD,KAAtB,EAA6B1F,GAAG8F,IAAH,CAAQC,UAAR,CAAmBC,UAAhD,CAAP;AACD,OA/VH;;AAkWE;;;;;;AAMA1C,iBAAW,mBAASO,KAAT,EAAgB;AACzB,aAAKoC,YAAL,CAAkBpC,KAAlB;AACA,YAAIqC,WAAW,KAAKxE,OAApB;AACA,aAAKA,OAAL,GAAemC,KAAf;AACA;AACA,YAAIqC,YAAYrC,KAAhB,EAAuB;AACrB,eAAKsC,aAAL,CAAmB,aAAnB,EAAkCtC,KAAlC,EAAyCqC,QAAzC;AACD;AACF,OAhXH;;AAmXE;;;;;AAKAD,oBAAe,sBAAS7D,KAAT,EAAgB;AAC7B;AACA,YAAI,CAACpC,GAAGsF,EAAH,CAAMc,OAAP,IAAkB,CAACpG,GAAGsF,EAAH,CAAMc,OAAN,CAActF,OAArC,EAA8C;AAC5C;AACD;AACD,YAAIsF,UAAUpG,GAAGsF,EAAH,CAAMc,OAAN,CAActF,OAAd,CAAsBuF,WAAtB,GAAoCC,qBAApC,EAAd;;AAEA,YAAI,CAAClE,KAAL,EAAY;AACV,cAAImE,YAAJ;AACA,eAAK,IAAI/D,IAAI,CAAb,EAAgBA,IAAI,KAAK9B,WAAL,CAAiBgC,MAArC,EAA6CF,GAA7C,EAAkD;AAChD,gBAAIL,OAAO,KAAKzB,WAAL,CAAiB8B,CAAjB,EAAoBL,IAA/B;AACA,gBAAI,CAACA,KAAKqE,OAAL,EAAL,EAAqB;AACnBD,6BAAepE,IAAf;AACA;AACA,kBAAI,CAAEA,KAAKsE,kBAAX,EAAgC;AAC9B;AACD;AACD;AACA,kBAAItE,KAAKuE,SAAL,OAAqB,KAAzB,EAAgC;AAC9B;AACD;;AAEDN,sBAAQO,QAAR,CAAiBxE,KAAKyE,iBAAL,EAAjB;;AAEA,kBAAIR,QAAQS,cAAR,MAA4B,OAAhC,EAAyC;AACvC,oBAAIC,WAAW3E,KAAKsE,kBAAL,EAAf;AACA,oBAAIM,MAAMD,SAASC,GAAT,GAAeX,QAAQY,YAAR,EAAzB;AACAZ,wBAAQa,YAAR,CAAqB,EAACC,MAAMJ,SAASK,KAAhB,EAAuBJ,KAAKA,GAA5B,EAArB;AACD,eAJD,MAIO;AACLX,wBAAQgB,aAAR,CAAsBjF,IAAtB;AACD;;AAEDiE,sBAAQiB,IAAR;AACA;AACD;AACF;AACF,SA7BD,MA6BO;AACLjB,kBAAQkB,OAAR;AACD;AACF,OA/ZH;;AAkaE;;;;;AAKAC,gBAAU,oBAAW;AACnB,eAAO,KAAK7F,OAAZ;AACD,OAzaH;;AA4aE;;;;;AAKA8E,eAAS,mBAAW;AAClB,eAAO,KAAKe,QAAL,EAAP;AACD,OAnbH;;AAsbE;;;;;;AAMAC,0BAAoB,8BAAW;AAC7B,YAAIC,WAAW,EAAf;AACA;AACA,aAAK,IAAIjF,IAAI,CAAb,EAAgBA,IAAI,KAAK9B,WAAL,CAAiBgC,MAArC,EAA6CF,GAA7C,EAAkD;AAChD,cAAIX,WAAW,KAAKnB,WAAL,CAAiB8B,CAAjB,EAAoBL,IAAnC;AACA,cAAI,CAACN,SAAS0F,QAAT,EAAL,EAA0B;AACxBE,qBAASpF,IAAT,CAAcR,SAAS+E,iBAAT,EAAd;AACD;AACF;AACD;AACA,YAAI,KAAKA,iBAAL,MAA4B,EAAhC,EAAoC;AAClCa,mBAASpF,IAAT,CAAc,KAAKuE,iBAAL,EAAd;AACD;;AAED,eAAOa,QAAP;AACD,OA3cH;;AA8cE;;;;;AAKAC,2BAAsB,+BAAW;AAC/B,YAAIC,MAAM,EAAV;AACA,aAAK,IAAInF,IAAI,CAAb,EAAgBA,IAAI,KAAK9B,WAAL,CAAiBgC,MAArC,EAA6CF,GAA7C,EAAkD;AAChD,cAAIX,WAAW,KAAKnB,WAAL,CAAiB8B,CAAjB,EAAoBL,IAAnC;AACA,cAAI,CAACN,SAAS0F,QAAT,EAAL,EAA0B;AACxBI,gBAAItF,IAAJ,CAASR,QAAT;AACD;AACF;;AAED,eAAO8F,GAAP;AACD,OA7dH;;AAgeE;;;AAGAC,aAAO,iBAAW;AAChB;AACA,aAAK,IAAIpF,IAAI,CAAb,EAAgBA,IAAI,KAAK9B,WAAL,CAAiBgC,MAArC,EAA6CF,GAA7C,EAAkD;AAChD,cAAIN,YAAY,KAAKxB,WAAL,CAAiB8B,CAAjB,CAAhB;AACA;AACAN,oBAAUC,IAAV,CAAe2B,QAAf,CAAwB,IAAxB;AACD;AACD;AACA,aAAKpC,OAAL,GAAe,IAAf;AACA,aAAKuE,YAAL,CAAkB,IAAlB;AACD,OA7eH;;AAgfE;;;;;;;;;;;;AAYA4B,oBAAc,sBAAShG,QAAT,EAAmBO,KAAnB,EAA0B;AACtC;AACA,aAAKzB,cAAL,CAAoBkB,SAASwC,UAAT,EAApB,IAA6CjC,KAA7C;AACAP,iBAASiC,QAAT,CAAkB1B,KAAlB;AACA,aAAK0F,yBAAL;AACD,OAjgBH;;AAogBE;;;;;;;;;;;AAWAC,oBAAe,sBAAS3F,KAAT,EAAgB;AAC7B,aAAKzB,cAAL,CAAoB,KAAK0D,UAAL,EAApB,IAAyCjC,KAAzC;AACA,aAAK0F,yBAAL;AACD,OAlhBH;;AAqhBE;;;;;AAKAA,iCAA4B,qCAAW;AACrC,YAAI1F,QAAQ,KAAKT,WAAjB;;AAEA;AACA,aAAK,IAAIqG,IAAT,IAAiB,KAAKrH,cAAtB,EAAsC;AACpC,cAAIsH,gBAAgB,KAAKtH,cAAL,CAAoBqH,IAApB,CAApB;AACA5F,kBAAQ6F,iBAAiB7F,KAAzB;AACA;AACA,cAAI6F,iBAAiB,IAArB,EAA2B;AACzB;AACD;AACF;AACD;AACA,aAAK3E,SAAL,CAAelB,KAAf;AACA;AACA,aAAKzB,cAAL,GAAsB,EAAtB;AACA;AACA,aAAK6C,SAAL,CAAe,UAAf;AACD;AA5iBH,KAtFF;;AAsoBE;;;;;AAKA0E,cAAW,oBACX;AACE,WAAKjC,YAAL,CAAkB,IAAlB;AACA,WAAKvF,WAAL,GAAmB,IAAnB;AACD;AA/oBH,GADA,C;AAvBAV,KAAGsF,EAAH,CAAMC,IAAN,CAAWC,UAAX,CAAsB1E,OAAtB,CAA8BX,aAA9B,GAA8CA,aAA9C",
  "file": "Manager.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (martinwittemann)\n\n************************************************************************ */\n/**\n * This validation manager is responsible for validation of forms.\n *\n * @ignore(qx.ui.tooltip)\n * @ignore(qx.ui.tooltip.Manager.*)\n */\nqx.Class.define(\"qx.ui.form.validation.Manager\",\n{\n  extend : qx.core.Object,\n\n  construct : function()\n  {\n    this.base(arguments);\n\n    // storage for all form items\n    this.__formItems = [];\n    // storage for all results of async validation calls\n    this.__asyncResults = {};\n    // set the default required field message\n    this.setRequiredFieldMessage(qx.locale.Manager.tr(\"This field is required\"));\n  },\n\n\n  events :\n  {\n    /**\n     * Change event for the valid state.\n     */\n    \"changeValid\" : \"qx.event.type.Data\",\n\n    /**\n     * Signals that the validation is done. This is not needed on synchronous\n     * validation (validation is done right after the call) but very important\n     * in the case an asynchronous validator will be used.\n     */\n    \"complete\" : \"qx.event.type.Event\"\n  },\n\n\n  properties :\n  {\n    /**\n     * The validator of the form itself. You can set a function (for\n     * synchronous validation) or a {@link qx.ui.form.validation.AsyncValidator}.\n     * In both cases, the function can have all added form items as first\n     * argument and the manager as a second argument. The manager should be used\n     * to set the {@link #invalidMessage}.\n     *\n     * Keep in mind that the validator is optional if you don't need the\n     * validation in the context of the whole form.\n     * @type {Function | AsyncValidator}\n     */\n    validator :\n    {\n      check : \"value instanceof Function || qx.Class.isSubClassOf(value.constructor, qx.ui.form.validation.AsyncValidator)\",\n      init : null,\n      nullable : true\n    },\n\n    /**\n     * The invalid message should store the message why the form validation\n     * failed. It will be added to the array returned by\n     * {@link #getInvalidMessages}.\n     */\n    invalidMessage :\n    {\n      check : \"String\",\n      init: \"\"\n    },\n\n\n    /**\n     * This message will be shown if a required field is empty and no individual\n     * {@link qx.ui.form.MForm#requiredInvalidMessage} is given.\n     */\n    requiredFieldMessage :\n    {\n      check : \"String\",\n      init : \"\"\n    },\n\n\n    /**\n     * The context for the form validation.\n     */\n    context :\n    {\n      nullable : true\n    }\n  },\n\n\n  members :\n  {\n    __formItems : null,\n    __valid : null,\n    __asyncResults : null,\n    __syncValid : null,\n\n\n    /**\n     * Add a form item to the validation manager.\n     *\n     * The form item has to implement at least two interfaces:\n     * <ol>\n     *   <li>The {@link qx.ui.form.IForm} Interface</li>\n     *   <li>One of the following interfaces:\n     *     <ul>\n     *       <li>{@link qx.ui.form.IBooleanForm}</li>\n     *       <li>{@link qx.ui.form.IColorForm}</li>\n     *       <li>{@link qx.ui.form.IDateForm}</li>\n     *       <li>{@link qx.ui.form.INumberForm}</li>\n     *       <li>{@link qx.ui.form.IStringForm}</li>\n     *     </ul>\n     *   </li>\n     * </ol>\n     * The validator can be a synchronous or asynchronous validator. In\n     * both cases the validator can either returns a boolean or fire an\n     * {@link qx.core.ValidationError}. For synchronous validation, a plain\n     * JavaScript function should be used. For all asynchronous validations,\n     * a {@link qx.ui.form.validation.AsyncValidator} is needed to wrap the\n     * plain function.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to add.\n     * @param validator {Function | qx.ui.form.validation.AsyncValidator}\n     *   The validator.\n     * @param context {var?null} The context of the validator.\n     */\n    add: function(formItem, validator, context) {\n      // check for the form API\n      if (!this.__supportsInvalid(formItem)) {\n        throw new Error(\"Added widget not supported.\");\n      }\n      // check for the data type\n      if (this.__supportsSingleSelection(formItem) && !formItem.getValue) {\n        // check for a validator\n        if (validator != null) {\n          throw new Error(\"Widgets supporting selection can only be validated \" +\n          \"in the form validator\");\n        }\n      }\n      var dataEntry =\n      {\n        item : formItem,\n        validator : validator,\n        valid : null,\n        context : context\n      };\n      this.__formItems.push(dataEntry);\n    },\n\n\n    /**\n     * Remove a form item from the validation manager.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to remove.\n     * @return {qx.ui.core.Widget?null} The removed form item or\n     *  <code>null</code> if the item could not be found.\n     */\n    remove : function(formItem)\n    {\n      var items = this.__formItems;\n\n      for (var i = 0, len = items.length; i < len; i++)\n      {\n        if (formItem === items[i].item)\n        {\n          items.splice(i, 1);\n          return formItem;\n        }\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Returns registered form items from the validation manager.\n     *\n     * @return {Array} The form items which will be validated.\n     */\n    getItems : function()\n    {\n      var items = [];\n      for (var i=0; i < this.__formItems.length; i++) {\n        items.push(this.__formItems[i].item);\n      };\n      return items;\n    },\n\n\n    /**\n     * Invokes the validation. If only synchronous validators are set, the\n     * result of the whole validation is available at the end of the method\n     * and can be returned. If an asynchronous validator is set, the result\n     * is still unknown at the end of this method so nothing will be returned.\n     * In both cases, a {@link #complete} event will be fired if the validation\n     * has ended. The result of the validation can then be accessed with the\n     * {@link #getValid} method.\n     *\n     * @return {Boolean|undefined} The validation result, if available.\n     */\n    validate : function() {\n      var valid = true;\n      this.__syncValid = true; // collaboration of all synchronous validations\n      var items = [];\n\n      // check all validators for the added form items\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var formItem = this.__formItems[i].item;\n        var validator = this.__formItems[i].validator;\n\n        // store the items in case of form validation\n        items.push(formItem);\n\n        // ignore all form items without a validator\n        if (validator == null) {\n          // check for the required property\n          var validatorResult = this._validateRequired(formItem);\n          valid = valid && validatorResult;\n          this.__syncValid = validatorResult && this.__syncValid;\n          continue;\n        }\n\n        var validatorResult = this._validateItem(\n          this.__formItems[i], formItem.getValue()\n        );\n        // keep that order to ensure that null is returned on async cases\n        valid = validatorResult && valid;\n        if (validatorResult != null) {\n          this.__syncValid = validatorResult && this.__syncValid;\n        }\n      }\n\n      // check the form validator (be sure to invoke it even if the form\n      // items are already false, so keep the order!)\n      var formValid = this.__validateForm(items);\n      if (qx.lang.Type.isBoolean(formValid)) {\n        this.__syncValid = formValid && this.__syncValid;\n      }\n      valid = formValid && valid;\n\n      this._setValid(valid);\n\n      if (qx.lang.Object.isEmpty(this.__asyncResults)) {\n        this.fireEvent(\"complete\");\n      }\n      return valid;\n    },\n\n\n    /**\n     * Checks if the form item is required. If so, the value is checked\n     * and the result will be returned. If the form item is not required, true\n     * will be returned.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to check.\n     * @return {var} Validation result\n     */\n    _validateRequired : function(formItem) {\n      if (formItem.getRequired()) {\n        var validatorResult;\n        // if its a widget supporting the selection\n        if (this.__supportsSingleSelection(formItem)) {\n          validatorResult = !!formItem.getSelection()[0];\n\n        } else if (this.__supportsDataBindingSelection(formItem)) {\n          validatorResult = (formItem.getSelection().getLength() > 0);\n\n        } else {\n          var value = formItem.getValue();\n          validatorResult = !!value || value === 0;\n        }\n        formItem.setValid(validatorResult);\n        var individualMessage = formItem.getRequiredInvalidMessage();\n        var message = individualMessage ? individualMessage : this.getRequiredFieldMessage();\n        formItem.setInvalidMessage(message);\n        return validatorResult;\n      }\n      return true;\n    },\n\n\n    /**\n     * Validates a form item. This method handles the differences of\n     * synchronous and asynchronous validation and returns the result of the\n     * validation if possible (synchronous cases). If the validation is\n     * asynchronous, null will be returned.\n     *\n     * @param dataEntry {Object} The map stored in {@link #add}\n     * @param value {var} The currently set value\n     * @return {Boolean|null} Validation result or <code>null</code> for async\n     * validation\n     */\n    _validateItem : function(dataEntry, value) {\n      var formItem = dataEntry.item;\n      var context = dataEntry.context;\n      var validator = dataEntry.validator;\n\n      // check for asynchronous validation\n      if (this.__isAsyncValidator(validator)) {\n        // used to check if all async validations are done\n        this.__asyncResults[formItem.toHashCode()] = null;\n        validator.validate(formItem, formItem.getValue(), this, context);\n        return null;\n      }\n\n      var validatorResult = null;\n\n      try {\n        var validatorResult = validator.call(context || this, value, formItem);\n        if (validatorResult === undefined) {\n          validatorResult = true;\n        }\n\n      } catch (e) {\n        if (e instanceof qx.core.ValidationError) {\n          validatorResult = false;\n          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {\n            var invalidMessage = e.message;\n          } else {\n            var invalidMessage = e.getComment();\n          }\n          formItem.setInvalidMessage(invalidMessage);\n        } else {\n          throw e;\n        }\n      }\n\n      formItem.setValid(validatorResult);\n      dataEntry.valid = validatorResult;\n\n      return validatorResult;\n    },\n\n\n    /**\n     * Validates the form. It checks for asynchronous validation and handles\n     * the differences to synchronous validation. If no form validator is given,\n     * true will be returned. If a synchronous validator is given, the\n     * validation result will be returned. In asynchronous cases, null will be\n     * returned cause the result is not available.\n     *\n     * @param items {qx.ui.core.Widget[]} An array of all form items.\n     * @return {Boolean|null} description\n     */\n    __validateForm: function(items) {\n      var formValidator = this.getValidator();\n      var context = this.getContext() || this;\n\n      if (formValidator == null) {\n        return true;\n      }\n\n      // reset the invalidMessage\n      this.setInvalidMessage(\"\");\n\n      if (this.__isAsyncValidator(formValidator)) {\n        this.__asyncResults[this.toHashCode()] = null;\n        formValidator.validateForm(items, this, context);\n        return null;\n      }\n\n      try {\n        var formValid = formValidator.call(context, items, this);\n        if (formValid === undefined) {\n          formValid = true;\n        }\n      } catch (e) {\n        if (e instanceof qx.core.ValidationError) {\n          formValid = false;\n\n          if (e.message && e.message != qx.type.BaseError.DEFAULTMESSAGE) {\n            var invalidMessage = e.message;\n          } else {\n            var invalidMessage = e.getComment();\n          }\n          this.setInvalidMessage(invalidMessage);\n        } else {\n          throw e;\n        }\n      }\n      return formValid;\n    },\n\n\n    /**\n     * Helper function which checks, if the given validator is synchronous\n     * or asynchronous.\n     *\n     * @param validator {Function|qx.ui.form.validation.AsyncValidator}\n     *   The validator to check.\n     * @return {Boolean} True, if the given validator is asynchronous.\n     */\n    __isAsyncValidator : function(validator) {\n      var async = false;\n      if (!qx.lang.Type.isFunction(validator)) {\n        async = qx.Class.isSubClassOf(\n          validator.constructor, qx.ui.form.validation.AsyncValidator\n        );\n      }\n      return async;\n    },\n\n\n    /**\n     * Returns true, if the given item implements the {@link qx.ui.form.IForm}\n     * interface.\n     *\n     * @param formItem {qx.core.Object} The item to check.\n     * @return {Boolean} true, if the given item implements the\n     *   necessary interface.\n     */\n    __supportsInvalid : function(formItem) {\n      var clazz = formItem.constructor;\n      return qx.Class.hasInterface(clazz, qx.ui.form.IForm);\n    },\n\n\n    /**\n     * Returns true, if the given item implements the\n     * {@link qx.ui.core.ISingleSelection} interface.\n     *\n     * @param formItem {qx.core.Object} The item to check.\n     * @return {Boolean} true, if the given item implements the\n     *   necessary interface.\n     */\n    __supportsSingleSelection : function(formItem) {\n      var clazz = formItem.constructor;\n      return qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection);\n    },\n\n\n    /**\n     * Returns true, if the given item implements the\n     * {@link qx.data.controller.ISelection} interface.\n     *\n     * @param formItem {qx.core.Object} The item to check.\n     * @return {Boolean} true, if the given item implements the\n     *   necessary interface.\n     */\n    __supportsDataBindingSelection : function(formItem) {\n      var clazz = formItem.constructor;\n      return qx.Class.hasInterface(clazz, qx.data.controller.ISelection);\n    },\n\n\n    /**\n     * Sets the valid state of the manager. It generates the event if\n     * necessary and stores the new value.\n     *\n     * @param value {Boolean|null} The new valid state of the manager.\n     */\n    _setValid: function(value) {\n      this._showToolTip(value);\n      var oldValue = this.__valid;\n      this.__valid = value;\n      // check for the change event\n      if (oldValue != value) {\n        this.fireDataEvent(\"changeValid\", value, oldValue);\n      }\n    },\n\n\n    /**\n     * Responsible for showing a tooltip in case the validation is done for\n     * widgets based on qx.ui.core.Widget.\n     * @param valid {Boolean} <code>false</code>, if the tooltip should be shown\n     */\n    _showToolTip : function(valid) {\n      // ignore if we don't have a tooltip manager e.g. mobile apps\n      if (!qx.ui.tooltip || !qx.ui.tooltip.Manager) {\n        return;\n      }\n      var tooltip = qx.ui.tooltip.Manager.getInstance().getSharedErrorTooltip();\n\n      if (!valid) {\n        var firstInvalid;\n        for (var i = 0; i < this.__formItems.length; i++) {\n          var item = this.__formItems[i].item;\n          if (!item.isValid()) {\n            firstInvalid = item;\n            // only for desktop widgets\n            if (!(item.getContentLocation)) {\n              return;\n            }\n            // only consider items on the screen\n            if (item.isSeeable() === false) {\n              continue;\n            }\n\n            tooltip.setLabel(item.getInvalidMessage());\n\n            if (tooltip.getPlaceMethod() == \"mouse\") {\n              var location = item.getContentLocation();\n              var top = location.top - tooltip.getOffsetTop();\n              tooltip.placeToPoint({left: location.right, top: top});\n            } else {\n              tooltip.placeToWidget(item);\n            }\n\n            tooltip.show();\n            return;\n          }\n        }\n      } else {\n        tooltip.exclude();\n      }\n    },\n\n\n    /**\n     * Returns the valid state of the manager.\n     *\n     * @return {Boolean|null} The valid state of the manager.\n     */\n    getValid: function() {\n      return this.__valid;\n    },\n\n\n    /**\n     * Returns the valid state of the manager.\n     *\n     * @return {Boolean|null} The valid state of the manager.\n     */\n    isValid: function() {\n      return this.getValid();\n    },\n\n\n    /**\n     * Returns an array of all invalid messages of the invalid form items and\n     * the form manager itself.\n     *\n     * @return {String[]} All invalid messages.\n     */\n    getInvalidMessages: function() {\n      var messages = [];\n      // combine the messages of all form items\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var formItem = this.__formItems[i].item;\n        if (!formItem.getValid()) {\n          messages.push(formItem.getInvalidMessage());\n        }\n      }\n      // add the forms fail message\n      if (this.getInvalidMessage() != \"\") {\n        messages.push(this.getInvalidMessage());\n      }\n\n      return messages;\n    },\n\n\n    /**\n     * Selects invalid form items\n     *\n     * @return {Array} invalid form items\n     */\n    getInvalidFormItems : function() {\n      var res = [];\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var formItem = this.__formItems[i].item;\n        if (!formItem.getValid()) {\n          res.push(formItem);\n        }\n      }\n\n      return res;\n    },\n\n\n    /**\n     * Resets the validator.\n     */\n    reset: function() {\n      // reset all form items\n      for (var i = 0; i < this.__formItems.length; i++) {\n        var dataEntry = this.__formItems[i];\n        // set the field to valid\n        dataEntry.item.setValid(true);\n      }\n      // set the manager to its initial valid value\n      this.__valid = null;\n      this._showToolTip(true);\n    },\n\n\n    /**\n     * Internal helper method to set the given item to valid for asynchronous\n     * validation calls. This indirection is used to determinate if the\n     * validation process is completed or if other asynchronous validators\n     * are still validating. {@link #__checkValidationComplete} checks if the\n     * validation is complete and will be called at the end of this method.\n     *\n     * @param formItem {qx.ui.core.Widget} The form item to set the valid state.\n     * @param valid {Boolean} The valid state for the form item.\n     *\n     * @internal\n     */\n    setItemValid: function(formItem, valid) {\n      // store the result\n      this.__asyncResults[formItem.toHashCode()] = valid;\n      formItem.setValid(valid);\n      this.__checkValidationComplete();\n    },\n\n\n    /**\n     * Internal helper method to set the form manager to valid for asynchronous\n     * validation calls. This indirection is used to determinate if the\n     * validation process is completed or if other asynchronous validators\n     * are still validating. {@link #__checkValidationComplete} checks if the\n     * validation is complete and will be called at the end of this method.\n     *\n     * @param valid {Boolean} The valid state for the form manager.\n     *\n     * @internal\n     */\n    setFormValid : function(valid) {\n      this.__asyncResults[this.toHashCode()] = valid;\n      this.__checkValidationComplete();\n    },\n\n\n    /**\n     * Checks if all asynchronous validators have validated so the result\n     * is final and the {@link #complete} event can be fired. If that's not\n     * the case, nothing will happen in the method.\n     */\n    __checkValidationComplete : function() {\n      var valid = this.__syncValid;\n\n      // check if all async validators are done\n      for (var hash in this.__asyncResults) {\n        var currentResult = this.__asyncResults[hash];\n        valid = currentResult && valid;\n        // the validation is not done so just do nothing\n        if (currentResult == null) {\n          return;\n        }\n      }\n      // set the actual valid state of the manager\n      this._setValid(valid);\n      // reset the results\n      this.__asyncResults = {};\n      // fire the complete event (no entry in the results with null)\n      this.fireEvent(\"complete\");\n    }\n  },\n\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n  destruct : function()\n  {\n    this._showToolTip(true);\n    this.__formItems = null;\n  }\n});\n"
  ]
}