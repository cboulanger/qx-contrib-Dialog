{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/treevirtual/SimpleTreeDataModel.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "table",
    "model",
    "Abstract",
    "include",
    "treevirtual",
    "MTreePrimitive",
    "construct",
    "_rowArr",
    "_nodeArr",
    "_nodeRowMap",
    "_treeColumn",
    "_selections",
    "push",
    "_getEmptyTree",
    "__editableColArr",
    "properties",
    "filter",
    "check",
    "nullable",
    "apply",
    "members",
    "__tree",
    "__tempTreeData",
    "__recalculateLastChildFlags",
    "setTree",
    "tree",
    "getTree",
    "setEditable",
    "editable",
    "col",
    "getColumnCount",
    "fireEvent",
    "setColumnEditable",
    "columnIndex",
    "isColumnEditable",
    "isColumnSortable",
    "sortByColumn",
    "ascending",
    "Error",
    "getSortColumnIndex",
    "setTreeColumn",
    "getTreeColumn",
    "getRowCount",
    "length",
    "getRowData",
    "rowIndex",
    "getValue",
    "setValue",
    "value",
    "node",
    "getNodeFromRow",
    "columnData",
    "setData",
    "hasListener",
    "data",
    "firstRow",
    "lastRow",
    "firstColumn",
    "lastColumn",
    "fireDataEvent",
    "getNode",
    "addBranch",
    "parentNodeId",
    "label",
    "bOpened",
    "bHideOpenCloseButton",
    "icon",
    "iconSelected",
    "_addNode",
    "Type",
    "BRANCH",
    "addLeaf",
    "LEAF",
    "prune",
    "nodeReference",
    "bSelfAlso",
    "nodeId",
    "i",
    "children",
    "lang",
    "Array",
    "remove",
    "move",
    "moveNodeReference",
    "parentNodeReference",
    "moveNode",
    "moveNodeId",
    "parentNode",
    "type",
    "oldParent",
    "__inorder",
    "level",
    "getFilter",
    "child",
    "childNodeId",
    "numChildren",
    "index",
    "call",
    "bFirstChild",
    "__setLastChildFlag",
    "rowData",
    "j",
    "bSelected",
    "selected",
    "__calculateLastChildFlags",
    "tempTreeData",
    "hasChildren",
    "isLastChild",
    "lastChild",
    "parent",
    "bLast",
    "unshift",
    "__render",
    "nodeArr",
    "undefined",
    "selectionModel",
    "getSelectionModel",
    "selections",
    "nRowIndex",
    "getRowFromNodeId",
    "setSelectionInterval",
    "getData",
    "clearData",
    "_clearSelections",
    "setColumnData",
    "getColumnData",
    "setState",
    "attributes",
    "attribute",
    "TV",
    "TreeVirtual",
    "bChangeSelection",
    "getSelectionMode",
    "SelectionMode",
    "NONE",
    "isSelectedIndex",
    "removeSelectionInterval",
    "bHideOpenClose",
    "_resetSelection",
    "getNodeRowMap",
    "selection",
    "getSelectedNodes",
    "nodes",
    "_applyFilter",
    "old",
    "destruct",
    "defer",
    "statics",
    "SimpleTreeDataModel"
  ],
  "mappings": "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",
  "file": "SimpleTreeDataModel.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2010 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * A simple tree data model used as the table model\n *\n * The object structure of a single node of the tree is:\n *\n * <pre class='javascript'>\n * {\n *   // USER-PROVIDED ATTRIBUTES\n *   // ------------------------\n *   type           : qx.ui.treevirtual.MTreePrimitive.Type.LEAF,\n *   parentNodeId   : 23,    // index of the parent node in _nodeArr\n *\n *   label          : \"My Documents\",\n *   bSelected      : true,  // true if node is selected; false otherwise.\n *   bOpened        : true,  // true (-), false (+)\n *   bHideOpenClose : false, // whether to hide the open/close button\n *   icon           : \"images/folder.gif\",\n *   iconSelected   : \"images/folder_selected.gif\",\n *\n *   cellStyle      : \"background-color:cyan\"\n *   labelStyle     : \"background-color:red;color:white\"\n *\n *   // USER-PROVIDED COLUMN DATA\n *   columnData     : [\n *                      null, // null at index of tree column (typically 0)\n *                      \"text of column 1\",\n *                      \"text of column 2\"\n *                    ],\n *\n *   // APPLICATION-, MIXIN-, and SUBCLASS-PROVIDED CUSTOM DATA\n *   data           : {\n *                      application :\n *                      {\n *                          // application-specific user data goes in here\n *                          foo: \"bar\",\n *                          ...\n *                      },\n *                      MDragAndDropSupport :\n *                      {\n *                          // Data required for the Drag & Drop mixin.\n *                          // When a mixin is included, its constructor\n *                          // should create this object, named according\n *                          // to the mixin or subclass name (empty or\n *                          // otherwise)\n *                      },\n *                      ... // Additional mixins or subclasses.\n *                    },\n *\n *   // INTERNALLY-CALCULATED ATTRIBUTES\n *   // --------------------------------\n *   // The following properties need not (and should not) be set by the\n *   // caller, but are automatically calculated.  Some are used internally,\n *   // while others may be of use to event listeners.\n *\n *   nodeId         : 42,   // The index in _nodeArr, useful to event listeners.\n *   children       : [ ],  // each value is an index into _nodeArr\n *\n *   level          : 2,    // The indentation level of this tree node\n *\n *   bFirstChild    : true,\n *   lastChild      : [ false ],  // Array where the index is the column of\n *                                // indentation, and the value is a boolean.\n *                                // These are used to locate the\n *                                // appropriate \"tree line\" icon.\n * }\n * </pre>\n */\nqx.Class.define(\"qx.ui.treevirtual.SimpleTreeDataModel\",\n{\n  extend : qx.ui.table.model.Abstract,\n\n  include : qx.ui.treevirtual.MTreePrimitive,\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct : function()\n  {\n    this.base(arguments);\n\n    this._rowArr = []; // rows, resorted into tree order as necessary\n    this._nodeArr = []; // tree nodes, organized with hierarchy\n\n    this._nodeRowMap = []; // map nodeArr index to rowArr index.  The\n                           // index of this array is the index of\n                           // _nodeArr, and the values in this array are\n                           // the indexes into _rowArr.\n\n    this._treeColumn = 0; // default column for tree nodes\n\n    this._selections = {}; // list of indexes of selected nodes\n\n    // the root node, needed to store its children\n    this._nodeArr.push(qx.ui.treevirtual.MTreePrimitive._getEmptyTree());\n\n    // Track which columns are editable\n    this.__editableColArr = null;\n  },\n\n\n  properties :\n  {\n    /**\n     * Gives the user the opportunity to filter the model. The filter\n     * function is called for every node in the model. It gets as an argument the\n     * <code>node</code> object and has to return\n     * <code>true</code> if the given data should be shown and\n     * <code>false</code> if the given data should be ignored.\n     */\n    filter :\n    {\n      check : \"Function\",\n      nullable : true,\n      apply : \"_applyFilter\"\n    }\n  },\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    __tree           : null,\n    __editableColArr : null,\n    __tempTreeData : null,\n    __recalculateLastChildFlags : null,\n\n    /** Rows, resorted into tree order as necessary */\n    _rowArr : null,\n\n    /** Tree nodes, organized with hierarchy */\n    _nodeArr : null,\n\n    /**\n     * Map nodeArr index to rowArr index.  The index of this array is the\n     * index of _nodeArr, and the values in this array are the indexes into\n     * _rowArr.\n     */\n    _nodeRowMap : null,\n\n    /** Column for tree nodes */\n    _treeColumn : null,\n\n    /** list of indexes of selected nodes */\n    _selections : null,\n\n    /**\n     * Set the tree object for which this data model is used.\n     *\n     * @param tree {qx.ui.treevirtual.TreeVirtual}\n     *    The tree used to render the data in this model.\n     *\n     */\n    setTree : function(tree)\n    {\n      this.__tree = tree;\n    },\n\n    /**\n     * Get the tree object for which this data model is used.\n     *\n     * @return {qx.ui.treevirtual.TreeVirtual}\n     */\n    getTree : function()\n    {\n      return this.__tree;\n    },\n\n    /**\n     * Sets all columns editable or not editable.\n     *\n     * @param editable {Boolean}\n     *   Whether all columns are editable.\n     *\n     */\n    setEditable : function(editable)\n    {\n      this.__editableColArr = [];\n\n      for (var col=0; col<this.getColumnCount(); col++)\n      {\n        this.__editableColArr[col] = editable;\n      }\n\n      this.fireEvent(\"metaDataChanged\");\n    },\n\n\n    /**\n     * Sets whether a column is editable.\n     *\n     * @param columnIndex {Integer}\n     *   The column of which to set the editable state.\n     *\n     * @param editable {Boolean}\n     *   Whether the column should be editable.\n     *\n     */\n    setColumnEditable : function(columnIndex, editable)\n    {\n      if (editable != this.isColumnEditable(columnIndex))\n      {\n        if (this.__editableColArr == null)\n        {\n          this.__editableColArr = [];\n        }\n\n        this.__editableColArr[columnIndex] = editable;\n\n        this.fireEvent(\"metaDataChanged\");\n      }\n    },\n\n    // overridden\n    isColumnEditable : function(columnIndex)\n    {\n      // The tree column is not editable\n      if (columnIndex == this._treeColumn)\n      {\n        return false;\n      }\n\n      return(this.__editableColArr\n             ? this.__editableColArr[columnIndex] == true\n             : false);\n    },\n\n\n    // overridden\n    isColumnSortable : function(columnIndex)\n    {\n      return false;\n    },\n\n\n    /**\n     * Sorts the model by a column.\n     *\n     * @param columnIndex {Integer} the column to sort by.\n     * @param ascending {Boolean} whether to sort ascending.\n     * @throws {Error} If one tries to sort the tree by column\n     */\n    sortByColumn : function(columnIndex, ascending)\n    {\n      throw new Error(\"Trees can not be sorted by column\");\n    },\n\n\n    /**\n     * Returns the column index the model is sorted by. This model is never\n     * sorted, so -1 is returned.\n     *\n     * @return {Integer}\n     *   -1, to indicate that the model is not sorted.\n     */\n    getSortColumnIndex : function()\n    {\n      return -1;\n    },\n\n\n    /**\n     * Specifies which column the tree is to be displayed in.  The tree is\n     * displayed using the SimpleTreeDataCellRenderer.  Other columns may be\n     * provided which use different cell renderers.\n     *\n     * Setting the tree column involves more than simply setting this column\n     * index; it also requires setting an appropriate cell renderer for this\n     * column, that knows how to render a tree. The expected and typical\n     * method of setting the tree column is to provide it in the 'custom'\n     * parameter to the TreeVirtual constructor, which also initializes the\n     * proper cell renderers. This method does not set any cell renderers. If\n     * you wish to call this method on your own, you should also manually set\n     * the cell renderer for the specified column, and likely also set the\n     * cell renderer for column 0 (the former tree column) to something\n     * appropriate to your data.\n     *\n     *\n     * @param columnIndex {Integer}\n     *   The index of the column in which the tree should be displayed.\n     *\n     */\n    setTreeColumn : function(columnIndex)\n    {\n      this._treeColumn = columnIndex;\n    },\n\n\n    /**\n     * Get the column in which the tree is to be displayed.\n     *\n     * @return {Integer}\n     *   The column in which the tree is to be displayed\n     */\n    getTreeColumn : function()\n    {\n      return this._treeColumn;\n    },\n\n    // overridden\n    getRowCount : function()\n    {\n      return this._rowArr.length;\n    },\n\n    // overridden\n    getRowData : function(rowIndex)\n    {\n      return this._rowArr[rowIndex];\n    },\n\n\n    /**\n     * Returns a cell value by column index.\n     *\n     * @throws {Error} if the row index is out of bounds.\n     * @param columnIndex {Integer} the index of the column.\n     * @param rowIndex {Integer} the index of the row.\n     * @return {var} The value of the cell.\n     * @see #getValueById\n     */\n    getValue : function(columnIndex, rowIndex)\n    {\n      if (rowIndex < 0 || rowIndex >= this._rowArr.length)\n      {\n        throw new Error(\"this._rowArr row \" +\n                        \"(\" + rowIndex + \") out of bounds: \" +\n                        this._rowArr +\n                        \" (0..\" + (this._rowArr.length - 1) + \")\");\n      }\n\n      if (columnIndex < 0 || columnIndex >= this._rowArr[rowIndex].length)\n      {\n        throw new Error(\"this._rowArr column \" +\n                        \"(\" + columnIndex + \") out of bounds: \" +\n                        this._rowArr[rowIndex] +\n                        \" (0..\" + (this._rowArr[rowIndex].length - 1) + \")\");\n      }\n\n      return this._rowArr[rowIndex][columnIndex];\n    },\n\n\n    // overridden\n    setValue : function(columnIndex, rowIndex, value)\n    {\n      if (columnIndex == this._treeColumn)\n      {\n        // Ignore requests to set the tree column data using this method\n        return;\n      }\n\n      // convert from rowArr to nodeArr, and get the requested node\n      var node = this.getNodeFromRow(rowIndex);\n\n      if (node.columnData[columnIndex] != value)\n      {\n        node.columnData[columnIndex] = value;\n        this.setData();\n\n        // Inform the listeners\n        if (this.hasListener(\"dataChanged\"))\n        {\n          var data =\n          {\n            firstRow    : rowIndex,\n            lastRow     : rowIndex,\n            firstColumn : columnIndex,\n            lastColumn  : columnIndex\n          };\n\n          this.fireDataEvent(\"dataChanged\", data);\n        }\n      }\n    },\n\n\n    /**\n     * Returns the node object specific to a currently visible row. In this\n     * simple tree data model, that's the same as retrieving the value of the\n     * tree column of the specified row.\n     *\n     * @throws {Error}\n     *   Thrown if the row index is out of bounds.\n     *\n     * @param rowIndex {Integer}\n     *   The index of the row.\n     *\n     * @return {Object}\n     *   The node object associated with the specified row.\n     */\n    getNode : function(rowIndex)\n    {\n      if (rowIndex < 0 || rowIndex >= this._rowArr.length)\n      {\n        throw new Error(\"this._rowArr row \" +\n                        \"(\" + rowIndex + \") out of bounds: \" +\n                        this._rowArr +\n                        \" (0..\" + (this._rowArr.length - 1) + \")\");\n      }\n\n      return this._rowArr[rowIndex][this._treeColumn];\n    },\n\n\n    /**\n     * Add a branch to the tree.\n     *\n     * @param parentNodeId {Integer}\n     *   The node id of the parent of the node being added\n     *\n     * @param label {String}\n     *   The string to display as the label for this node\n     *\n     * @param bOpened {Boolean}\n     *   <i>True</i> if the branch should be rendered in its opened state;\n     *   <i>false</i> otherwise.\n     *\n     * @param bHideOpenCloseButton {Boolean}\n     *   <i>True</i> if the open/close button should not be displayed;\n     *   <i>false</i> if the open/close button should be displayed\n     *\n     * @param icon {String}\n     *   The relative (subject to alias expansion) or full path of the icon to\n     *   display for this node when it is not a selected node.\n     *\n     * @param iconSelected {String}\n     *   The relative (subject to alias expansion) or full path of the icon to\n     *   display for this node when it is a selected node.\n     *\n     * @return {Integer}\n     *   The node id of the newly-added branch.\n     */\n    addBranch : function(parentNodeId,\n                         label,\n                         bOpened,\n                         bHideOpenCloseButton,\n                         icon,\n                         iconSelected)\n    {\n      return qx.ui.treevirtual.MTreePrimitive._addNode(\n        this._nodeArr,\n        parentNodeId,\n        label,\n        bOpened,\n        bHideOpenCloseButton,\n        qx.ui.treevirtual.MTreePrimitive.Type.BRANCH,\n        icon,\n        iconSelected);\n    },\n\n\n    /**\n     * Add a leaf to the tree.\n     *\n     * @param parentNodeId {Integer}\n     *   The node id of the parent of the node being added\n     *\n     * @param label {String}\n     *   The string to display as the label for this node\n     *\n     * @param icon {String}\n     *   The relative (subject to alias expansion) or full path of the icon to\n     *   display for this node when it is not a selected node.\n     *\n     * @param iconSelected {String}\n     *   The relative (subject to alias expansion) or full path of the icon to\n     *   display for this node when it is a selected node.\n     *\n     * @return {Integer} The node id of the newly-added leaf.\n     */\n    addLeaf : function(parentNodeId,\n                       label,\n                       icon,\n                       iconSelected)\n    {\n      return qx.ui.treevirtual.MTreePrimitive._addNode(\n        this._nodeArr,\n        parentNodeId,\n        label,\n        false,\n        false,\n        qx.ui.treevirtual.MTreePrimitive.Type.LEAF,\n        icon,\n        iconSelected);\n    },\n\n\n    /**\n     * Prune the tree by removing, recursively, all of a node's children.  If\n     * requested, also remove the node itself.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node to be pruned from the tree.  The node can be represented\n     *   either by the node object, or the node id (as would have been\n     *   returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param bSelfAlso {Boolean}\n     *   If <i>true</i> then remove the node identified by <i>nodeId</i> as\n     *   well as all of the children.\n     *\n     * @throws {Error} If the node object or id is not valid.\n     *\n     */\n    prune : function(nodeReference, bSelfAlso)\n    {\n      var node;\n      var nodeId;\n\n      if (typeof(nodeReference) == \"object\")\n      {\n        node = nodeReference;\n        nodeId = node.nodeId;\n      }\n      else if (typeof(nodeReference) == \"number\")\n      {\n        nodeId = nodeReference;\n      }\n      else\n      {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      // First, recursively remove all children\n      for (var i=this._nodeArr[nodeId].children.length-1; i>=0; i--)\n      {\n        this.prune(this._nodeArr[nodeId].children[i], true);\n      }\n\n      // Now remove ourself, if requested. (Don't try to remove the root node)\n      if (bSelfAlso && nodeId != 0)\n      {\n        // Delete ourself from our parent's children list\n        node = this._nodeArr[nodeId];\n        qx.lang.Array.remove(this._nodeArr[node.parentNodeId].children,\n                             nodeId);\n\n        // Delete ourself from the selections list, if we're in it.\n        if (this._selections[nodeId])\n        {\n          delete this._selections[nodeId];\n        }\n\n        // We can't splice the node itself out, because that would muck up the\n        // nodeId == index correspondence.  Instead, just replace the node\n        // with null so its index just becomes unused.\n        this._nodeArr[nodeId] = null;\n      }\n    },\n\n\n    /**\n     * Move a node in the tree.\n     *\n     * @param moveNodeReference {Object | Integer}\n     *   The node to be moved.  The node can be represented\n     *   either by the node object, or the node id (as would have been\n     *   returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param parentNodeReference {Object | Integer}\n     *   The new parent node, which must not be a LEAF.  The node can be\n     *   represented either by the node object, or the node id (as would have\n     *   been returned by addBranch(), addLeaf(), etc.)\n     *\n     * @throws {Error} If the node object or id is not valid.\n     * @throws {Error} If one tries to add a child to a non-existent parent.\n     * @throws {Error} If one tries to add a node to a leaf.\n     */\n    move : function(moveNodeReference,\n                    parentNodeReference)\n    {\n      var moveNode;\n      var moveNodeId;\n      var parentNode;\n      var parentNodeId;\n\n      // Replace null parent with node id 0\n      parentNodeReference = parentNodeReference || 0;\n\n      if (typeof(moveNodeReference) == \"object\")\n      {\n        moveNode = moveNodeReference;\n        moveNodeId = moveNode.nodeId;\n      }\n      else if (typeof(moveNodeReference) == \"number\")\n      {\n        moveNodeId = moveNodeReference;\n        moveNode = this._nodeArr[moveNodeId];\n      }\n      else\n      {\n        throw new Error(\"Expected move node object or node id\");\n      }\n\n      if (typeof(parentNodeReference) == \"object\")\n      {\n        parentNode = parentNodeReference;\n        parentNodeId = parentNode.nodeId;\n      }\n      else if (typeof(parentNodeReference) == \"number\")\n      {\n        parentNodeId = parentNodeReference;\n        parentNode = this._nodeArr[parentNodeId];\n      }\n      else\n      {\n        throw new Error(\"Expected parent node object or node id\");\n      }\n\n      // Ensure parent isn't a leaf\n      if (parentNode.type == qx.ui.treevirtual.MTreePrimitive.Type.LEAF)\n      {\n        throw new Error(\"Sorry, a LEAF may not have children.\");\n      }\n\n      // Remove the node from its current parent's children list\n      var oldParent = this._nodeArr[moveNode.parentNodeId];\n      qx.lang.Array.remove(oldParent.children, moveNodeId);\n\n      // Add the node to its new parent's children list\n      parentNode.children.push(moveNodeId);\n\n      // Replace this node's parent reference\n      this._nodeArr[moveNodeId].parentNodeId = parentNodeId;\n    },\n\n\n    /**\n     * Orders the node and creates all data needed to render the tree.\n     *\n     * @param nodeId {Integer}\n     *   A node identifier, as previously returned by {@link #addBranch} or\n     *   {@link #addLeaf}.\n     * @param level {Integer} the level in the hierarchy\n     */\n    __inorder : function(nodeId, level)\n    {\n      var filter = this.getFilter();\n      var child = null;\n      var childNodeId;\n\n      // For each child of the specified node...\n      var numChildren = this._nodeArr[nodeId].children.length;\n      var index = 0;\n      var children = this.__tempTreeData[nodeId] = [];\n      for (var i=0; i<numChildren; i++)\n      {\n        // Determine the node id of this child\n        childNodeId = this._nodeArr[nodeId].children[i];\n\n        // Get the child node\n        child = this._nodeArr[childNodeId];\n\n        // Skip deleted nodes or apply the filter\n        if (child == null || (filter && !filter.call(this, child))) {\n          this.__recalculateLastChildFlags = true;\n          continue;\n        }\n\n        // Remember the children so that we can add the lastChild flags later\n        children.push(child);\n\n        // (Re-)assign this node's level\n        child.level = level;\n\n        // Determine if we're the first child of our parent\n        child.bFirstChild = (index == 0);\n\n        // Set the last child flag of the node only when no node was skipped.\n        // Otherwise we will have to recalculate the last child flags, as\n        // the parent or sibling node might become the first child.\n        if (!this.__recalculateLastChildFlags) {\n          this.__setLastChildFlag(child, i == numChildren - 1);\n        }\n\n        // Ensure there's an entry in the columnData array for each column\n        if (!child.columnData)\n        {\n          child.columnData = [ ];\n        }\n\n        if (child.columnData.length < this.getColumnCount())\n        {\n          child.columnData[this.getColumnCount() - 1] = null;\n        }\n\n        // Add this node to the row array.  Initialize a row data array.\n        var rowData = [ ];\n\n        // If additional column data is provided...\n        if (child.columnData)\n        {\n          // ... then add each column data.\n          for (var j=0; j<child.columnData.length; j++)\n          {\n            // Is this the tree column?\n            if (j == this._treeColumn)\n            {\n              // Yup.  Add the tree node data\n              rowData.push(child);\n            }\n            else\n            {\n              // Otherwise, add the column data verbatim.\n              rowData.push(child.columnData[j]);\n            }\n          }\n        }\n        else\n        {\n          // No column data.  Just add the tree node.\n          rowData.push(child);\n        }\n\n        // Track the _rowArr index for each node so we can handle\n        // selections.\n        this._nodeRowMap[child.nodeId] = this._rowArr.length;\n\n        // Add the row data to the row array\n        this._rowArr.push(rowData);\n\n        // If this node is selected, ...\n        if (child.bSelected)\n        {\n          // ... indicate so for the row.\n          rowData.selected = true;\n          this._selections[child.nodeId] = true;\n        }\n\n        // If this child is opened, ...\n        if (child.bOpened)\n        {\n          // ... then add its children too.\n          this.__inorder(childNodeId, level + 1);\n        }\n        index++;\n      }\n    },\n\n\n    /**\n     * Calculates the lastChild flags to the nodes, so that the tree can render the\n     * tree lines right.\n     *\n     * @param nodeId {Integer}\n     *   A node identifier, as previously returned by {@link #addBranch} or\n     *   {@link #addLeaf}.\n     */\n    __calculateLastChildFlags : function(nodeId)\n    {\n      var tempTreeData = this.__tempTreeData;\n      var children =  tempTreeData[nodeId];\n      var numChildren = children.length;\n      for (var i = 0; i < numChildren; i++)\n      {\n        var child = children[i];\n\n        this.__setLastChildFlag(child, i == numChildren - 1);\n\n        var hasChildren = tempTreeData[child.nodeId] && tempTreeData[child.nodeId].length > 0;\n        if (hasChildren) {\n          this.__calculateLastChildFlags(child.nodeId);\n        }\n      }\n    },\n\n\n    /**\n     * Sets the last child flag for a node and all it's parents.\n     *\n     * @param node {Object} the node object\n     * @param isLastChild {Boolean} whether the node is the last child\n     */\n    __setLastChildFlag : function(node, isLastChild)\n    {\n      // Determine if we're the last child of our parent\n      node.lastChild = [ isLastChild ];\n\n      // Get our parent.\n      var parent =  this._nodeArr[node.parentNodeId];\n\n      // For each parent node, determine if it is a last child\n      while (parent.nodeId)\n      {\n        var bLast = parent.lastChild[parent.lastChild.length - 1];\n        node.lastChild.unshift(bLast);\n        parent = this._nodeArr[parent.parentNodeId];\n      }\n    },\n\n\n    /**\n     * Renders the tree data.\n     */\n    __render : function()\n    {\n      // Reset the __tempTreeData\n      this.__tempTreeData = [];\n      this.__recalculateLastChildFlags = false;\n\n      // Reset the row array\n      this._rowArr = [];\n\n      // Reset the _nodeArr -> _rowArr map\n      this._nodeRowMap = [];\n\n      // Reset the set of selections\n      this._selections = {};\n\n      // Begin in-order traversal of the tree from the root to regenerate\n      // _rowArr.\n      this.__inorder(0, 1);\n\n      // Reset the lastChild flags when needed, so that the tree can render the\n      // tree lines right.\n      if (this.__recalculateLastChildFlags) {\n        this.__calculateLastChildFlags(0);\n      }\n\n      // Give the memory free\n      this.__tempTreeData = null;\n\n      // Inform the listeners\n      if (this.hasListener(\"dataChanged\"))\n      {\n        var data =\n        {\n          firstRow    : 0,\n          lastRow     : this._rowArr.length - 1,\n          firstColumn : 0,\n          lastColumn  : this.getColumnCount() - 1\n        };\n\n        this.fireDataEvent(\"dataChanged\", data);\n      }\n    },\n\n\n    /**\n     * Sets the whole data en bulk, or notifies the data model that node\n     * modifications are complete.\n     *\n     * @param nodeArr {Array | null}\n     *   Pass either an Array of node objects, or null.\n     *\n     *   If non-null, nodeArr is an array of node objects containing the\n     *   entire tree to be displayed.  If loading the whole data en bulk in\n     *   this way, it is assumed that the data is correct!  No error checking\n     *   or validation is done.  You'd better know what you're doing!  Caveat\n     *   emptor.\n     *\n     *\n     *   If nodeArr is null, then this call is a notification that the user\n     *   has completed building or modifying a tree by issuing a series of\n     *   calls to {@link #addBranch} and/or {@link #addLeaf}.\n     *\n     *\n     * @throws {Error} If the parameter has the wrong type.\n     */\n    setData : function(nodeArr)\n    {\n      if (nodeArr instanceof Array)\n      {\n        // Save the user-supplied data.\n        this._nodeArr = nodeArr;\n      }\n      else if (nodeArr !== null && nodeArr !== undefined)\n      {\n        throw new Error(\"Expected array of node objects or null/undefined; \" +\n                        \"got \" + typeof (nodeArr));\n      }\n\n      // Re-render the row array\n      this.__render();\n\n      // Set selections in the selection model now\n      var selectionModel = this.getTree().getSelectionModel();\n      var selections = this._selections;\n      for (var nodeId in selections)\n      {\n        var nRowIndex = this.getRowFromNodeId(nodeId);\n        selectionModel.setSelectionInterval(nRowIndex, nRowIndex);\n      }\n    },\n\n\n    /**\n     * Return the array of node data.\n     *\n     * @return {Array}\n     *  Array of node objects.\n     *  See {@link qx.ui.treevirtual.SimpleTreeDataModel} for a description\n     *  nodes in this array.\n     */\n    getData : function()\n    {\n      return this._nodeArr;\n    },\n\n\n    /**\n     * Clears the tree of all nodes\n     *\n     */\n    clearData : function ()\n    {\n      this._clearSelections();\n      this.setData([ qx.ui.treevirtual.MTreePrimitive._getEmptyTree() ]);\n    },\n\n\n    /**\n     * Add data to an additional column (a column other than the tree column)\n     * of the tree.\n     *\n     * @param nodeId {Integer}\n     *   A node identifier, as previously returned by {@link #addBranch} or\n     *   {@link #addLeaf}.\n     *\n     * @param columnIndex {Integer}\n     *   The column number to which the provided data applies\n     *\n     * @param data {var}\n     *   The cell data for the specified column\n     *\n     */\n    setColumnData : function(nodeId, columnIndex, data)\n    {\n      this._nodeArr[nodeId].columnData[columnIndex] = data;\n    },\n\n\n    /**\n     * Retrieve the data from an additional column (a column other than the\n     * tree column) of the tree.\n     *\n     * @param nodeId {Integer}\n     *   A node identifier, as previously returned by {@link #addBranch} or\n     *   {@link #addLeaf}.\n     *\n     * @param columnIndex {Integer}\n     *   The column number to which the provided data applies\n     *\n     * @return {var} The cell data for the specified column\n     */\n    getColumnData : function(nodeId, columnIndex)\n    {\n      return this._nodeArr[nodeId].columnData[columnIndex];\n    },\n\n\n    /**\n     * Set state attributes of a node.\n     *\n     * @param nodeReference {Object | Integer}\n     *   The node to have its attributes set.  The node can be represented\n     *   either by the node object, or the node id (as would have been\n     *   returned by addBranch(), addLeaf(), etc.)\n     *\n     * @param attributes {Map}\n     *   Each property name in the map may correspond to the property names of\n     *   a node which are specified as <i>USER-PROVIDED ATTRIBUTES</i> in\n     *   {@link SimpleTreeDataModel}.  Each property value will be assigned\n     *   to the corresponding property of the node specified by nodeId.\n     *\n     * @throws {Error} If the node object or id is not valid.\n     */\n    setState : function(nodeReference, attributes)\n    {\n      var node;\n      var nodeId;\n\n      if (typeof(nodeReference) == \"object\")\n      {\n        node = nodeReference;\n        nodeId = node.nodeId;\n      }\n      else if (typeof(nodeReference) == \"number\")\n      {\n        nodeId = nodeReference;\n        node = this._nodeArr[nodeId];\n      }\n      else\n      {\n        throw new Error(\"Expected node object or node id\");\n      }\n\n      for (var attribute in attributes)\n      {\n        // Do any attribute-specific processing\n        switch(attribute)\n        {\n        case \"bSelected\":\n          var nRowIndex = this.getRowFromNodeId(nodeId);\n          var selectionModel = this.getTree().getSelectionModel();\n          var TV = qx.ui.treevirtual.TreeVirtual;\n          var bChangeSelection =\n            (typeof(nRowIndex) === \"number\" &&\n             this.getTree().getSelectionMode() != TV.SelectionMode.NONE);\n\n          // The selected state is changing. Keep track of what is selected\n          if (attributes[attribute])\n          {\n            this._selections[nodeId] = true;\n\n            // Add selection range for node\n            if (bChangeSelection &&\n                ! selectionModel.isSelectedIndex(nRowIndex))\n            {\n              selectionModel.setSelectionInterval(nRowIndex, nRowIndex);\n            }\n          }\n          else\n          {\n            delete this._selections[nodeId];\n\n            // Delete selection range for node\n            if (bChangeSelection &&\n                selectionModel.isSelectedIndex(nRowIndex))\n            {\n              selectionModel.removeSelectionInterval(nRowIndex, nRowIndex);\n            }\n          }\n          break;\n\n        case \"bOpened\":\n          // Don't do anything if the requested state is the same as the\n          // current state.\n          if (attributes[attribute] == node.bOpened)\n          {\n            break;\n          }\n\n          // Get the tree to which this data model is attached\n          var tree = this.__tree;\n\n          // Are we opening or closing?\n          if (node.bOpened)\n          {\n            // We're closing.  If there are listeners, generate a treeClose\n            // event.\n            tree.fireDataEvent(\"treeClose\", node);\n          }\n          else\n          {\n            // We're opening.  Are there any children?\n            if (node.children.length > 0)\n            {\n              // Yup.  If there any listeners, generate a \"treeOpenWithContent\"\n              // event.\n              tree.fireDataEvent(\"treeOpenWithContent\", node);\n            }\n            else\n            {\n              // No children.  If there are listeners, generate a\n              // \"treeOpenWhileEmpty\" event.\n              tree.fireDataEvent(\"treeOpenWhileEmpty\", node);\n            }\n          }\n\n          // Event handler may have modified the opened state.  Check before\n          // toggling.\n          if (!node.bHideOpenClose)\n          {\n            // It's still boolean.  Toggle the state\n            node.bOpened = !node.bOpened;\n\n            // Clear the old selections in the tree\n            tree.getSelectionModel()._resetSelection();\n          }\n\n          // Re-render the row data since formerly visible rows may now be\n          // invisible, or vice versa.\n          this.setData();\n          break;\n\n        default:\n          // no attribute-specific processing required\n          break;\n        }\n\n        // Set the new attribute value\n        node[attribute] = attributes[attribute];\n      }\n    },\n\n\n    /**\n     * Return the mapping of nodes to rendered rows.  This function is intended\n     * for use by the cell renderer, not by users of this class.\n     * It is also useful to select a node.\n     *\n     * @return {Array}\n     *   The array containing mappings of nodes to rendered rows.\n     */\n    getNodeRowMap : function()\n    {\n      return this._nodeRowMap;\n    },\n\n    /**\n     * This operation maps nodes to rowIndexes.  It does the opposite job to {@link #getNodeFromRow}.\n     *\n     * @param nodeId {Integer}\n     *   The id of the node (as would have been returned by addBranch(),\n     *   addLeaf(), etc.) to get the row index for.\n     * @return {Integer} row index for the given node ID\n     */\n    getRowFromNodeId : function(nodeId)\n    {\n      return this._nodeRowMap[nodeId];\n    },\n\n    /**\n     * This operation maps rowIndexes to nodes.  It does the opposite job to {@link #getRowFromNodeId}.\n     * This function is useful to map selection (row based) to nodes.\n     *\n     * @param rowIndex {Integer} zero-based row index.\n     * @return {Object} node associated to <tt>rowIndex</tt>.\n     */\n    getNodeFromRow : function(rowIndex)\n    {\n      return this._nodeArr[this._rowArr[rowIndex][this._treeColumn].nodeId];\n    },\n\n\n    /**\n     * Clear all selections in the data model.  This method does not clear\n     * selections displayed in the widget, and is intended for internal use,\n     * not by users of this class.\n     *\n     */\n    _clearSelections : function()\n    {\n      // Clear selected state for any selected nodes.\n      for (var selection in this._selections)\n      {\n        this._nodeArr[selection].bSelected = false;\n      }\n\n      // Reinitialize selections array.\n      this._selections = { };\n    },\n\n\n    /**\n     * Return the nodes that are currently selected.\n     *\n     * @return {Array}\n     *   An array containing the nodes that are currently selected.\n     */\n    getSelectedNodes : function()\n    {\n      var nodes = [ ];\n\n      for (var nodeId in this._selections)\n      {\n        nodes.push(this._nodeArr[nodeId]);\n      }\n\n      return nodes;\n    },\n\n\n    // property apply\n    _applyFilter : function(value, old)\n    {\n      this.setData();\n    }\n  },\n\n  destruct : function()\n  {\n    this._rowArr = this._nodeArr = this._nodeRowMap = this._selections =\n      this.__tree = this.__tempTreeData = null;\n  },\n\n  defer : function(statics)\n  {\n    // For backward compatibility, ensure the Type values are available from\n    // this class as well as from the mixin.\n    statics.Type = qx.ui.treevirtual.MTreePrimitive.Type;\n  }\n});\n"
  ]
}