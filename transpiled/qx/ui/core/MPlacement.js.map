{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/core/MPlacement.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Mixin",
    "define",
    "statics",
    "__visible",
    "__direction",
    "setVisibleElement",
    "elem",
    "getVisibleElement",
    "setMoveDirection",
    "direction",
    "Error",
    "getMoveDirection",
    "properties",
    "position",
    "check",
    "init",
    "themeable",
    "placeMethod",
    "domMove",
    "placementModeX",
    "placementModeY",
    "offsetLeft",
    "offsetTop",
    "offsetRight",
    "offsetBottom",
    "offset",
    "group",
    "mode",
    "members",
    "__ptwLiveUpdater",
    "__ptwLiveDisappearListener",
    "__ptwLiveUpdateDisappearListener",
    "getLayoutLocation",
    "widget",
    "insets",
    "bounds",
    "left",
    "top",
    "getBounds",
    "size",
    "getLayoutParent",
    "isRootWidget",
    "getInsets",
    "rootCoords",
    "getContentLocation",
    "right",
    "width",
    "bottom",
    "height",
    "moveTo",
    "visible",
    "ui",
    "core",
    "MPlacement",
    "elemLocation",
    "Math",
    "max",
    "getDomMove",
    "setDomPosition",
    "setLayoutProperties",
    "placeToWidget",
    "target",
    "liveupdate",
    "__cleanupFromLastPlaceToWidgetLiveUpdate",
    "lang",
    "Function",
    "bind",
    "event",
    "Idle",
    "getInstance",
    "addListener",
    "coords",
    "_place",
    "removeListener",
    "placeToPointer",
    "round",
    "getDocumentLeft",
    "getDocumentTop",
    "placeToElement",
    "location",
    "bom",
    "element",
    "Location",
    "get",
    "offsetWidth",
    "offsetHeight",
    "placeToPoint",
    "point",
    "_getPlacementOffsets",
    "getOffsetLeft",
    "getOffsetTop",
    "getOffsetRight",
    "getOffsetBottom",
    "__getPlacementSize",
    "callback",
    "_computePlacementSize",
    "isVisible",
    "addListenerOnce",
    "call",
    "result",
    "util",
    "placement",
    "Placement",
    "compute",
    "getPosition",
    "getPlacementModeX",
    "getPlacementModeY",
    "removeState",
    "addState",
    "destruct"
  ],
  "mappings": "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",
  "file": "MPlacement.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Martin Wittemann (martinwittemann)\n     * Christian Hagendorn (chris_schmidt)\n\n************************************************************************ */\n\n/**\n * Methods to place popup like widgets to other widgets, points,\n * pointer event coordinates, etc.\n */\nqx.Mixin.define(\"qx.ui.core.MPlacement\",\n{\n\n  statics : {\n    __visible : null,\n    __direction : \"left\",\n\n    /**\n     * Set the always visible element. If an element is set, the\n     * {@link #moveTo} method takes care of every move and tries not to cover\n     * the given element with a movable widget like a popup or context menu.\n     *\n     * @param elem {qx.ui.core.Widget} The widget which should always be visible.\n     */\n    setVisibleElement : function(elem) {\n      this.__visible = elem;\n    },\n\n    /**\n     * Returns the given always visible element. See {@link #setVisibleElement}\n     * for more details.\n     *\n     * @return {qx.ui.core.Widget|null} The given widget.\n     */\n    getVisibleElement : function() {\n      return this.__visible;\n    },\n\n    /**\n     * Set the move direction for an element which hides always visible element.\n     * The value has only an effect when the {@link #setVisibleElement} is set.\n     *\n     * @param direction {String} The direction <code>left</code> or <code>top</code>.\n     */\n    setMoveDirection : function(direction)\n    {\n      if (direction === \"top\" || direction === \"left\") {\n        this.__direction = direction;\n      } else {\n        throw new Error(\"Invalid value for the parameter 'direction' \" +\n          \"[qx.ui.core.MPlacement.setMoveDirection()], the value was '\" + direction + \"' \" +\n          \"but 'top' or 'left' are allowed.\");\n      }\n    },\n\n    /**\n     * Returns the move direction for an element which hides always visible element.\n     * See {@link #setMoveDirection} for more details.\n     *\n     * @return {String} The move direction.\n     */\n    getMoveDirection : function() {\n      return this.__direction;\n    }\n  },\n\n\n  properties :\n  {\n    /**\n     * Position of the aligned object in relation to the opener.\n     *\n     * Please note than changes to this property are only applied\n     * when re-aligning the widget.\n     *\n     * The first part of the value is the edge to attach to. The second\n     * part the alignment of the orthogonal edge after the widget\n     * has been attached.\n     *\n     * The default value \"bottom-left\" for example means that the\n     * widget should be shown directly under the given target and\n     * then should be aligned to be left edge:\n     *\n     * <pre>\n     * +--------+\n     * | target |\n     * +--------+\n     * +-------------+\n     * |   widget    |\n     * +-------------+\n     * </pre>\n     */\n    position :\n    {\n      check :\n      [\n        \"top-left\", \"top-center\", \"top-right\",\n        \"bottom-left\", \"bottom-center\", \"bottom-right\",\n        \"left-top\", \"left-middle\", \"left-bottom\",\n        \"right-top\", \"right-middle\", \"right-bottom\"\n      ],\n      init : \"bottom-left\",\n      themeable : true\n    },\n\n    /**\n     * Whether the widget should be placed relative to an other widget or to\n     * the pointer.\n     */\n    placeMethod :\n    {\n      check : [\"widget\", \"pointer\"],\n      init : \"pointer\",\n      themeable: true\n    },\n\n    /** Whether the widget should moved using DOM methods. */\n    domMove :\n    {\n      check : \"Boolean\",\n      init : false\n    },\n\n    /**\n     * Selects the algorithm to place the widget horizontally. <code>direct</code>\n     * uses {@link qx.util.placement.DirectAxis}, <code>keep-align</code>\n     * uses {@link qx.util.placement.KeepAlignAxis} and <code>best-fit</code>\n     * uses {@link qx.util.placement.BestFitAxis}.\n     */\n    placementModeX :\n    {\n      check : [\"direct\", \"keep-align\", \"best-fit\"],\n      init : \"keep-align\",\n      themeable : true\n    },\n\n    /**\n     * Selects the algorithm to place the widget vertically. <code>direct</code>\n     * uses {@link qx.util.placement.DirectAxis}, <code>keep-align</code>\n     * uses {@link qx.util.placement.KeepAlignAxis} and <code>best-fit</code>\n     * uses {@link qx.util.placement.BestFitAxis}.\n     */\n    placementModeY :\n    {\n      check : [\"direct\", \"keep-align\", \"best-fit\"],\n      init : \"keep-align\",\n      themeable : true\n    },\n\n    /** Left offset of the pointer (in pixel) */\n    offsetLeft :\n    {\n      check : \"Integer\",\n      init : 0,\n      themeable : true\n    },\n\n    /** Top offset of the pointer (in pixel) */\n    offsetTop :\n    {\n      check : \"Integer\",\n      init : 0,\n      themeable : true\n    },\n\n    /** Right offset of the pointer (in pixel) */\n    offsetRight :\n    {\n      check : \"Integer\",\n      init : 0,\n      themeable : true\n    },\n\n    /** Bottom offset of the pointer (in pixel) */\n    offsetBottom :\n    {\n      check : \"Integer\",\n      init : 0,\n      themeable : true\n    },\n\n    /** Offsets in one group */\n    offset :\n    {\n      group : [ \"offsetTop\", \"offsetRight\", \"offsetBottom\", \"offsetLeft\" ],\n      mode  : \"shorthand\",\n      themeable : true\n    }\n  },\n\n\n  members :\n  {\n    __ptwLiveUpdater : null,\n    __ptwLiveDisappearListener : null,\n    __ptwLiveUpdateDisappearListener : null,\n\n\n    /**\n     * Returns the location data like {qx.bom.element.Location#get} does,\n     * but does not rely on DOM elements coordinates to be rendered. Instead,\n     * this method works with the available layout data available in the moment\n     * when it is executed.\n     * This works best when called in some type of <code>resize</code> or\n     * <code>move</code> event which are supported by all widgets out of the\n     * box.\n     *\n     * @param widget {qx.ui.core.Widget} Any widget\n     * @return {Map|null} Returns a map with <code>left</code>, <code>top</code>,\n     *   <code>right</code> and <code>bottom</code> which contains the distance\n     *   of the widget relative coords the document.\n     */\n    getLayoutLocation : function(widget)\n    {\n      // Use post-layout dimensions\n      // which do not rely on the final rendered DOM element\n      var insets, bounds, left, top;\n\n      // Add bounds of the widget itself\n      bounds = widget.getBounds();\n\n      if (!bounds) {\n        return null;\n      }\n\n      left = bounds.left;\n      top = bounds.top;\n\n      // Keep size to protect it for loop\n      var size = bounds;\n\n      // Now loop up with parents until reaching the root\n      widget = widget.getLayoutParent();\n      while (widget && !widget.isRootWidget())\n      {\n        // Add coordinates\n        bounds = widget.getBounds();\n        left += bounds.left;\n        top += bounds.top;\n\n        // Add insets\n        insets = widget.getInsets();\n        left += insets.left;\n        top += insets.top;\n\n        // Next parent\n        widget = widget.getLayoutParent();\n      }\n\n      // Add the rendered location of the root widget\n      if (widget && widget.isRootWidget())\n      {\n        var rootCoords = widget.getContentLocation();\n        if (rootCoords)\n        {\n          left += rootCoords.left;\n          top += rootCoords.top;\n        }\n      }\n\n      // Build location data\n      return {\n        left : left,\n        top : top,\n        right : left + size.width,\n        bottom : top + size.height\n      };\n    },\n\n\n    /**\n     * Sets the position. Uses low-level, high-performance DOM\n     * methods when the property {@link #domMove} is enabled.\n     * Checks if an always visible element is set and moves the widget to not\n     * overlay the always visible widget if possible. The algorithm tries to\n     * move the widget as far left as necessary but not of the screen.\n     * ({@link #setVisibleElement})\n     *\n     * @param left {Integer} The left position\n     * @param top {Integer} The top position\n     */\n    moveTo : function(left, top)\n    {\n      var visible = qx.ui.core.MPlacement.getVisibleElement();\n\n      // if we have an always visible element\n      if (visible) {\n\n        var bounds = this.getBounds();\n        var elemLocation = visible.getContentLocation();\n\n        // if we have bounds for both elements\n        if (bounds && elemLocation) {\n          var bottom = top + bounds.height;\n          var right = left + bounds.width;\n\n          // horizontal placement wrong\n          // each number is for the upcomming check (huge element is\n          // the always visible, eleme prefixed)\n          //     | 3 |\n          //   ---------\n          //   | |---| |\n          //   |       |\n          // --|-|   |-|--\n          // 1 | |   | | 2\n          // --|-|   |-|--\n          //   |       |\n          //   | |---| |\n          //   ---------\n          //     | 4 |\n          if (\n            (right > elemLocation.left && left < elemLocation.right) &&\n            (bottom > elemLocation.top && top < elemLocation.bottom)\n          ) {\n            var direction = qx.ui.core.MPlacement.getMoveDirection();\n\n            if (direction === \"left\") {\n              left = Math.max(elemLocation.left - bounds.width, 0);\n            } else {\n              top = Math.max(elemLocation.top - bounds.height, 0);\n            }\n          }\n        }\n      }\n\n      if (this.getDomMove()) {\n        this.setDomPosition(left, top);\n      } else {\n        this.setLayoutProperties({left: left, top: top});\n      }\n    },\n\n\n    /**\n     * Places the widget to another (at least laid out) widget. The DOM\n     * element is not needed, but the bounds are needed to compute the\n     * location of the widget to align to.\n     *\n     * @param target {qx.ui.core.Widget} Target coords align coords\n     * @param liveupdate {Boolean} Flag indicating if the position of the\n     * widget should be checked and corrected automatically.\n     * @return {Boolean} true if the widget was successfully placed\n     */\n    placeToWidget : function(target, liveupdate)\n    {\n\n      // Use the idle event to make sure that the widget's position gets\n      // updated automatically (e.g. the widget gets scrolled).\n      if (liveupdate)\n      {\n        this.__cleanupFromLastPlaceToWidgetLiveUpdate();\n\n        // Bind target and livupdate to placeToWidget\n        this.__ptwLiveUpdater = qx.lang.Function.bind(this.placeToWidget, this, target, false);\n\n        qx.event.Idle.getInstance().addListener(\"interval\", this.__ptwLiveUpdater);\n\n        // Remove the listener when the element disappears.\n        this.__ptwLiveUpdateDisappearListener = function()\n        {\n          this.__cleanupFromLastPlaceToWidgetLiveUpdate();\n        };\n\n        this.addListener(\"disappear\", this.__ptwLiveUpdateDisappearListener, this);\n\n      }\n\n      var coords = target.getContentLocation() || this.getLayoutLocation(target);\n\n      if(coords != null) {\n        this._place(coords);\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n\n    /**\n     * Removes all resources allocated by the last run of placeToWidget with liveupdate=true\n     */\n    __cleanupFromLastPlaceToWidgetLiveUpdate : function()\n    {\n      if (this.__ptwLiveUpdater)\n      {\n        qx.event.Idle.getInstance().removeListener(\"interval\", this.__ptwLiveUpdater);\n        this.__ptwLiveUpdater = null;\n      }\n\n      if (this.__ptwLiveUpdateDisappearListener){\n        this.removeListener(\"disappear\", this.__ptwLiveUpdateDisappearListener, this);\n        this.__ptwLiveUpdateDisappearListener = null;\n      }\n\n    },\n\n\n    /**\n     * Places the widget to the pointer position.\n     *\n     * @param event {qx.event.type.Pointer} Pointer event to align to\n     */\n    placeToPointer : function(event)\n    {\n      var left = Math.round(event.getDocumentLeft());\n      var top = Math.round(event.getDocumentTop());\n\n      var coords =\n      {\n        left: left,\n        top: top,\n        right: left,\n        bottom: top\n      };\n\n      this._place(coords);\n    },\n\n\n    /**\n     * Places the widget to any (rendered) DOM element.\n     *\n     * @param elem {Element} DOM element to align to\n     * @param liveupdate {Boolean} Flag indicating if the position of the\n     * widget should be checked and corrected automatically.\n     */\n    placeToElement : function(elem, liveupdate)\n    {\n      var location = qx.bom.element.Location.get(elem);\n      var coords =\n      {\n        left: location.left,\n        top: location.top,\n        right: location.left + elem.offsetWidth,\n        bottom: location.top + elem.offsetHeight\n      };\n\n      // Use the idle event to make sure that the widget's position gets\n      // updated automatically (e.g. the widget gets scrolled).\n      if (liveupdate)\n      {\n        // Bind target and livupdate to placeToWidget\n        this.__ptwLiveUpdater = qx.lang.Function.bind(this.placeToElement, this, elem, false);\n\n        qx.event.Idle.getInstance().addListener(\"interval\", this.__ptwLiveUpdater);\n\n        // Remove the listener when the element disappears.\n        this.addListener(\"disappear\", function()\n        {\n          if (this.__ptwLiveUpdater)\n          {\n            qx.event.Idle.getInstance().removeListener(\"interval\", this.__ptwLiveUpdater);\n            this.__ptwLiveUpdater = null;\n          }\n        }, this);\n      }\n\n      this._place(coords);\n    },\n\n\n    /**\n     * Places the widget in relation to the given point\n     *\n     * @param point {Map} Coordinate of any point with the keys <code>left</code>\n     *   and <code>top</code>.\n     */\n    placeToPoint : function(point)\n    {\n      var coords =\n      {\n        left: point.left,\n        top: point.top,\n        right: point.left,\n        bottom: point.top\n      };\n\n      this._place(coords);\n    },\n\n\n    /**\n     * Returns the placement offsets as a map\n     *\n     * @return {Map} The placement offsets\n     */\n    _getPlacementOffsets : function()\n    {\n      return {\n        left : this.getOffsetLeft(),\n        top : this.getOffsetTop(),\n        right : this.getOffsetRight(),\n        bottom : this.getOffsetBottom()\n      };\n    },\n\n\n    /**\n     * Get the size of the object to place. The callback will be called with\n     * the size as first argument. This methods works asynchronously.\n     *\n     * The size of the object to place is the size of the widget. If a widget\n     * including this mixin needs a different size it can implement the method\n     * <code>_computePlacementSize</code>, which returns the size.\n     *\n     *  @param callback {Function} This function will be called with the size as\n     *    first argument\n     */\n    __getPlacementSize : function(callback)\n    {\n      var size = null;\n\n      if (this._computePlacementSize) {\n        var size = this._computePlacementSize();\n      } else if (this.isVisible()) {\n        var size = this.getBounds();\n      }\n\n      if (size == null)\n      {\n        this.addListenerOnce(\"appear\", function() {\n          this.__getPlacementSize(callback);\n        }, this);\n      } else {\n        callback.call(this, size);\n      }\n    },\n\n\n    /**\n     * Internal method to read specific this properties and\n     * apply the results to the this afterwards.\n     *\n     * @param coords {Map} Location of the object to align the this to. This map\n     *   should have the keys <code>left</code>, <code>top</code>, <code>right</code>\n     *   and <code>bottom</code>.\n     */\n    _place : function(coords)\n    {\n      this.__getPlacementSize(function(size)\n      {\n        var result = qx.util.placement.Placement.compute(\n          size,\n          this.getLayoutParent().getBounds(),\n          coords,\n          this._getPlacementOffsets(),\n          this.getPosition(),\n          this.getPlacementModeX(),\n          this.getPlacementModeY()\n        );\n\n        // state handling for tooltips e.g.\n        this.removeState(\"placementLeft\");\n        this.removeState(\"placementRight\");\n        this.addState(coords.left < result.left ? \"placementRight\" : \"placementLeft\");\n\n        this.moveTo(result.left, result.top);\n      });\n    }\n  },\n\n\n  destruct : function()\n  {\n    this.__cleanupFromLastPlaceToWidgetLiveUpdate();\n  }\n});\n"
  ]
}