{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/core/queue/Layout.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__queue",
    "__nesting",
    "remove",
    "widget",
    "$$hash",
    "add",
    "ui",
    "core",
    "queue",
    "Manager",
    "scheduleFlush",
    "isScheduled",
    "flush",
    "__getSortedQueue",
    "i",
    "length",
    "hasValidLayout",
    "isRootWidget",
    "hasUserBounds",
    "hint",
    "getSizeHint",
    "renderLayout",
    "width",
    "height",
    "bounds",
    "getBounds",
    "left",
    "top",
    "getNestingLevel",
    "cache",
    "level",
    "parent",
    "$$parent",
    "leveldown",
    "__getLevelGroupedWidgets",
    "VisibilityQueue",
    "Visibility",
    "levels",
    "hash",
    "isVisible",
    "sortedQueue",
    "push",
    "invalidateLayoutCache",
    "oldSizeHint",
    "newSizeHint",
    "hintChanged",
    "minWidth",
    "maxWidth",
    "minHeight",
    "maxHeight",
    "getLayoutParent",
    "Layout"
  ],
  "mappings": "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",
  "file": "Layout.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * The layout queue manages all widgets, which need a recalculation of their\n * layout. The {@link #flush} method computes the layout of all queued widgets\n * and their dependent widgets.\n */\nqx.Class.define(\"qx.ui.core.queue.Layout\",\n{\n  statics :\n  {\n    /** @type {Map} This contains all the queued widgets for the next flush. */\n    __queue : {},\n\n\n    /** Nesting level cache **/\n    __nesting : {},\n\n\n    /**\n     * Clears the widget from the internal queue. Normally only used\n     * during interims disposes of one or a few widgets.\n     *\n     * @param widget {qx.ui.core.Widget} The widget to clear\n     */\n    remove : function(widget) {\n      delete this.__queue[widget.$$hash];\n    },\n\n\n    /**\n     * Mark a widget's layout as invalid and add its layout root to\n     * the queue.\n     *\n     * Should only be used by {@link qx.ui.core.Widget}.\n     *\n     * @param widget {qx.ui.core.Widget} Widget to add.\n     */\n    add : function(widget)\n    {\n      this.__queue[widget.$$hash] = widget;\n      qx.ui.core.queue.Manager.scheduleFlush(\"layout\");\n    },\n\n    /**\n    * Check whether the queue has scheduled changes for a widget.\n    * Note that the layout parent can have changes scheduled that\n    * affect the children widgets.\n    *\n    * @param widget {qx.ui.core.Widget} Widget to check.\n    * @return {Boolean} Whether the widget given has layout changes queued.\n    */\n    isScheduled : function(widget) {\n      return !!this.__queue[widget.$$hash];\n    },\n\n    /**\n     * Update the layout of all widgets, which layout is marked as invalid.\n     *\n     * This is used exclusively by the {@link qx.ui.core.queue.Manager}.\n     *\n     */\n    flush : function()\n    {\n      // get sorted widgets to (re-)layout\n      var queue = this.__getSortedQueue();\n\n      // iterate in reversed order to process widgets with the smallest nesting\n      // level first because these may affect the inner lying children\n      for (var i=queue.length-1; i>=0; i--)\n      {\n        var widget = queue[i];\n\n        // continue if a relayout of one of the root's parents has made the\n        // layout valid\n        if (widget.hasValidLayout()) {\n          continue;\n        }\n\n        // overflow areas or qx.ui.root.*\n        if (widget.isRootWidget() && !widget.hasUserBounds())\n        {\n          // This is a real root widget. Set its size to its preferred size.\n          var hint = widget.getSizeHint();\n          widget.renderLayout(0, 0, hint.width, hint.height);\n        }\n        else\n        {\n          // This is an inner item of layout changes. Do a relayout of its\n          // children without changing its position and size.\n          var bounds = widget.getBounds();\n          widget.renderLayout(bounds.left, bounds.top, bounds.width, bounds.height);\n        }\n      }\n    },\n\n\n    /**\n     * Get the widget's nesting level. Top level widgets have a nesting level\n     * of <code>0</code>.\n     *\n     * @param widget {qx.ui.core.Widget} The widget to query.\n     * @return {Integer} The nesting level\n     */\n    getNestingLevel : function(widget)\n    {\n      var cache = this.__nesting;\n      var level = 0;\n      var parent = widget;\n\n      // Detecting level\n      while (true)\n      {\n        if (cache[parent.$$hash] != null)\n        {\n          level += cache[parent.$$hash];\n          break;\n        }\n\n        if (!parent.$$parent) {\n          break;\n        }\n\n        parent = parent.$$parent;\n        level += 1;\n      }\n\n      // Update the processed hierarchy (runs from inner to outer)\n      var leveldown = level;\n      while (widget && widget !== parent)\n      {\n        cache[widget.$$hash] = leveldown--;\n        widget = widget.$$parent;\n      }\n\n      return level;\n    },\n\n\n    /**\n     * Group widget by their nesting level.\n     *\n     * @return {Map[]} A sparse array. Each entry of the array contains a widget\n     *     map with all widgets of the same level as the array index.\n     */\n    __getLevelGroupedWidgets : function()\n    {\n      var VisibilityQueue = qx.ui.core.queue.Visibility;\n\n      // clear cache\n      this.__nesting = {};\n\n      // sparse level array\n      var levels = [];\n      var queue = this.__queue;\n      var widget, level;\n\n      for (var hash in queue)\n      {\n        widget = queue[hash];\n\n        if (VisibilityQueue.isVisible(widget))\n        {\n          level = this.getNestingLevel(widget);\n\n          // create hierarchy\n          if (!levels[level]) {\n            levels[level] = {};\n          }\n\n          // store widget in level map\n          levels[level][hash] = widget;\n\n          // remove widget from layout queue\n          delete queue[hash];\n        }\n      }\n\n      return levels;\n    },\n\n\n    /**\n     * Compute all layout roots of the given widgets. Layout roots are either\n     * root widgets or widgets, which preferred size has not changed by the\n     * layout changes of its children.\n     *\n     * This function returns the roots ordered by their nesting factors. The\n     * layout with the largest nesting level comes first.\n     *\n     * @return {qx.ui.core.Widget[]} Ordered list or layout roots.\n     */\n    __getSortedQueue : function()\n    {\n      var sortedQueue = [];\n      var levels = this.__getLevelGroupedWidgets();\n\n      for (var level=levels.length-1; level>=0; level--)\n      {\n        // Ignore empty levels (levels is an sparse array)\n        if (!levels[level]) {\n          continue;\n        }\n\n        for (var hash in levels[level])\n        {\n          var widget = levels[level][hash];\n\n          // This is a real layout root. Add it directly to the list\n          if (level == 0 || widget.isRootWidget() || widget.hasUserBounds())\n          {\n            sortedQueue.push(widget);\n            widget.invalidateLayoutCache();\n            continue;\n          }\n\n          // compare old size hint to new size hint\n          var oldSizeHint = widget.getSizeHint(false);\n\n          if (oldSizeHint)\n          {\n            widget.invalidateLayoutCache();\n            var newSizeHint = widget.getSizeHint();\n\n            var hintChanged = (\n              !widget.getBounds() ||\n              oldSizeHint.minWidth !== newSizeHint.minWidth ||\n              oldSizeHint.width !== newSizeHint.width ||\n              oldSizeHint.maxWidth !== newSizeHint.maxWidth ||\n              oldSizeHint.minHeight !== newSizeHint.minHeight ||\n              oldSizeHint.height !== newSizeHint.height ||\n              oldSizeHint.maxHeight !== newSizeHint.maxHeight\n            );\n          }\n          else\n          {\n            hintChanged = true;\n          }\n\n          if (hintChanged)\n          {\n            // Since the level is > 0, the widget must\n            // have a parent != null.\n            var parent = widget.getLayoutParent();\n            if (!levels[level-1]) {\n              levels[level-1] = {};\n            }\n\n            levels[level-1][parent.$$hash] = parent;\n          }\n          else\n          {\n            // this is an internal layout root since its own preferred size\n            // has not changed.\n            sortedQueue.push(widget);\n          }\n        }\n      }\n\n      return sortedQueue;\n    }\n  }\n});\n"
  ]
}