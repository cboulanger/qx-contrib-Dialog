{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/virtual/layer/CellSpanManager.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "rowConfig",
    "columnConfig",
    "assertInstance",
    "ui",
    "virtual",
    "Axis",
    "_cells",
    "_invalidateSortCache",
    "_invalidatePositionCache",
    "addListener",
    "_onRowConfigChange",
    "_onColumnConfigChange",
    "_rowConfig",
    "_columnConfig",
    "members",
    "addCell",
    "id",
    "row",
    "column",
    "rowSpan",
    "columnSpan",
    "firstRow",
    "lastRow",
    "firstColumn",
    "lastColumn",
    "removeCell",
    "_sorted",
    "_getSortedCells",
    "key",
    "sorted",
    "values",
    "sort",
    "a",
    "b",
    "_findCellsInRange",
    "min",
    "max",
    "cells",
    "length",
    "start",
    "end",
    "pivot",
    "cell",
    "result",
    "findCellsInWindow",
    "rowCount",
    "columnCount",
    "verticalInWindow",
    "lang",
    "mergeWith",
    "horizontalInWindow",
    "__intersectionAsArray",
    "setA",
    "setB",
    "intersection",
    "push",
    "e",
    "_rowPos",
    "_columnPos",
    "_getRowPosition",
    "pos",
    "undefined",
    "getItemPosition",
    "_getColumnPosition",
    "_getSingleCellBounds",
    "firstVisibleRow",
    "firstVisibleColumn",
    "bounds",
    "left",
    "top",
    "width",
    "height",
    "getItemSize",
    "getCellBounds",
    "i",
    "l",
    "computeCellSpanMap",
    "map",
    "rowStartIndex",
    "Math",
    "rowEndIndex",
    "rowIndex",
    "columnStartIndex",
    "columnEndIndex",
    "columnIndex",
    "destruct",
    "removeListener",
    "layer",
    "CellSpanManager"
  ],
  "mappings": "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",
  "file": "CellSpanManager.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * EXPERIMENTAL!\n *\n * The CellSpanManager manages cells, which span several rows or columns.\n *\n * It provides functionality to compute, which spanning cells are visible\n * in a given view port and how they have to be placed.\n */\nqx.Class.define(\"qx.ui.virtual.layer.CellSpanManager\",\n{\n  extend : qx.core.Object,\n\n  /**\n   * @param rowConfig {qx.ui.virtual.core.Axis} The row configuration of the pane\n   *    in which the cells will be rendered\n   * @param columnConfig {qx.ui.virtual.core.Axis} The column configuration of the pane\n   *    in which the cells will be rendered\n   */\n  construct : function(rowConfig, columnConfig)\n  {\n    this.base(arguments);\n\n    if (qx.core.Environment.get(\"qx.debug\"))\n    {\n      this.assertInstance(rowConfig, qx.ui.virtual.core.Axis);\n      this.assertInstance(columnConfig, qx.ui.virtual.core.Axis);\n    }\n\n    this._cells = {};\n    this._invalidateSortCache();\n    this._invalidatePositionCache();\n\n    rowConfig.addListener(\"change\", this._onRowConfigChange, this);\n    columnConfig.addListener(\"change\", this._onColumnConfigChange, this);\n\n    this._rowConfig = rowConfig;\n    this._columnConfig = columnConfig;\n  },\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    /**\n     * Add a spanning cell to the manager.\n     *\n     * @param id {String} Unique id for the cell definition. This id is required\n     *    for removing the cell from the manager\n     * @param row {PositiveInteger} The cell's row\n     * @param column {PositiveInteger} The cell's column\n     * @param rowSpan {PositiveInteger} The number of rows the cells spans\n     * @param columnSpan {PositiveInteger} The number of columns the cells spans\n     */\n    addCell : function(id, row, column, rowSpan, columnSpan)\n    {\n      this._cells[id] = {\n        firstRow: row,\n        lastRow : row + rowSpan - 1,\n        firstColumn: column,\n        lastColumn: column + columnSpan - 1,\n        id: id\n      };\n      this._invalidateSortCache();\n    },\n\n\n    /**\n     * Remove a cell from the manager\n     *\n     * @param id {String} The id of the cell to remove\n     */\n    removeCell : function(id)\n    {\n      delete(this._cells[id]);\n      this._invalidateSortCache();\n    },\n\n\n    /**\n     * Invalidate the sort cache\n     */\n    _invalidateSortCache : function() {\n      this._sorted = {};\n    },\n\n\n    /**\n     * Get the cell array sorted by the given key (ascending)\n     *\n     * @param key {String} The sort key. One of <code>firstRow</code>,\n     *     <code>lastRow</code>, <code>firstColumn</code> or <code>lastColumn</code>\n     * @return {Map[]} sorted array of cell descriptions\n     */\n    _getSortedCells : function(key)\n    {\n      if (this._sorted[key]) {\n        return this._sorted[key];\n      }\n      var sorted = this._sorted[key] = Object.values(this._cells);\n      sorted.sort(function(a, b) {\n        return a[key] < b[key] ? -1 : 1;\n      });\n      return sorted;\n    },\n\n\n    /**\n     * Finds all cells with a sort key within the given range.\n     *\n     * Complexity: O(log n)\n     *\n     * @param key {String} The key to search for\n     * @param min {Integer} minimum value\n     * @param max {Integer} maximum value (inclusive)\n     * @return {Map} Map, which will contain the search results\n     */\n    _findCellsInRange : function(key, min, max)\n    {\n      var cells = this._getSortedCells(key);\n      if (cells.length == 0) {\n        return {};\n      }\n\n      var start = 0;\n      var end = cells.length-1;\n\n      // find first cell, which is >= \"min\"\n      while (true)\n      {\n        var pivot = start + ((end - start) >> 1);\n\n        var cell = cells[pivot];\n        if (\n          cell[key] >= min &&\n          (pivot == 0 || cells[pivot-1][key] < min)\n        ) {\n          // the start cell was found\n          break;\n        }\n\n        if (cell[key] >= min) {\n          end = pivot - 1;\n        } else {\n          start = pivot + 1;\n        }\n        if (start > end) {\n          // nothing found\n          return {};\n        }\n      }\n\n      var result = {};\n      var cell = cells[pivot];\n      while (cell && cell[key] >= min && cell[key] <= max)\n      {\n        result[cell.id] = cell;\n        cell = cells[pivot++];\n      }\n      return result;\n    },\n\n\n    /**\n     * Find all cells, which are visible in the given grid window.\n     *\n     * @param firstRow {PositiveInteger} first visible row\n     * @param firstColumn {PositiveInteger} first visible column\n     * @param rowCount {PositiveInteger} number of rows in the window\n     * @param columnCount {PositiveInteger} number of columns in the window\n     * @return {Map[]} The array of found cell descriptions. A cell description\n     *    contains the keys <code>firstRow</code>, <code>lastRow</code>,\n     *    <code>firstColumn</code> or <code>lastColumn</code>\n     */\n    findCellsInWindow : function(firstRow, firstColumn, rowCount, columnCount)\n    {\n      var verticalInWindow = {};\n\n      if (rowCount > 0)\n      {\n        var lastRow = firstRow + rowCount - 1;\n        qx.lang.Object.mergeWith(\n          verticalInWindow,\n          this._findCellsInRange(\"firstRow\", firstRow, lastRow)\n        );\n        qx.lang.Object.mergeWith(\n          verticalInWindow,\n          this._findCellsInRange(\"lastRow\", firstRow, lastRow)\n        );\n\n      }\n\n      var horizontalInWindow = {};\n\n      if (columnCount > 0)\n      {\n        var lastColumn = firstColumn + columnCount - 1;\n        qx.lang.Object.mergeWith(\n            horizontalInWindow,\n            this._findCellsInRange(\"firstColumn\", firstColumn, lastColumn)\n        );\n        qx.lang.Object.mergeWith(\n            horizontalInWindow,\n            this._findCellsInRange(\"lastColumn\", firstColumn, lastColumn)\n        );\n\n      }\n\n      return this.__intersectionAsArray(horizontalInWindow, verticalInWindow);\n    },\n\n\n    /**\n     * Return the intersection of two maps as an array. The objects intersect if\n     * they have the same keys.\n     *\n     * @param setA {Object} The first map\n     * @param setB {Object} The second map\n     * @return {String[]} An array keys found in both maps\n     */\n    __intersectionAsArray : function(setA, setB)\n    {\n      var intersection = [];\n      for (var key in setA)\n      {\n        if (setB[key]) {\n          intersection.push(setB[key]);\n        }\n      }\n      return intersection;\n    },\n\n\n    /**\n     * Event handler for row configuration changes\n     *\n     * @param e {qx.event.type.Event} the event object\n     */\n    _onRowConfigChange : function(e) {\n      this._rowPos = [];\n    },\n\n\n    /**\n     * Event handler for column configuration changes\n     *\n     * @param e {qx.event.type.Event} the event object\n     */\n    _onColumnConfigChange : function(e) {\n      this._columnPos = [];\n    },\n\n\n    /**\n     * Invalidates the row/column position cache\n     */\n    _invalidatePositionCache : function()\n    {\n      this._rowPos = [];\n      this._columnPos = [];\n    },\n\n\n    /**\n     * Get the pixel start position of the given row\n     *\n     * @param row {Integer} The row index\n     * @return {Integer} The pixel start position of the given row\n     */\n    _getRowPosition : function(row)\n    {\n      var pos = this._rowPos[row];\n      if (pos !== undefined) {\n        return pos;\n      }\n\n      pos = this._rowPos[row] = this._rowConfig.getItemPosition(row);\n      return pos;\n    },\n\n\n    /**\n     * Get the pixel start position of the given column\n     *\n     * @param column {Integer} The column index\n     * @return {Integer} The pixel start position of the given column\n     */\n    _getColumnPosition : function(column)\n    {\n      var pos = this._columnPos[column];\n      if (pos !== undefined) {\n        return pos;\n      }\n\n      pos = this._columnPos[column] = this._columnConfig.getItemPosition(column);\n      return pos;\n    },\n\n\n    /**\n     * Get the bounds of a single cell\n     *\n     * @param cell {Map} the cell description as returned by\n     *    {@link #findCellsInWindow} to get the bounds for\n     * @param firstVisibleRow {Map} The pane's first visible row\n     * @param firstVisibleColumn {Map} The pane's first visible column\n     * @return {Map} Boundaries map with the keys <code>left</code>,\n     * <code>top</code>, <code>width</code> and <code>height</code>\n     */\n    _getSingleCellBounds : function(cell, firstVisibleRow, firstVisibleColumn)\n    {\n      var bounds = {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      };\n\n      bounds.height =\n        this._getRowPosition(cell.lastRow) +\n        this._rowConfig.getItemSize(cell.lastRow) -\n        this._getRowPosition(cell.firstRow);\n\n      bounds.top =\n        this._getRowPosition(cell.firstRow) -\n        this._getRowPosition(firstVisibleRow);\n\n      bounds.width =\n        this._getColumnPosition(cell.lastColumn) +\n        this._columnConfig.getItemSize(cell.lastColumn) -\n        this._getColumnPosition(cell.firstColumn);\n\n      bounds.left =\n        this._getColumnPosition(cell.firstColumn) -\n        this._getColumnPosition(firstVisibleColumn);\n\n      return bounds;\n    },\n\n\n    /**\n     * Get the bounds of a list of cells as returned by {@link #findCellsInWindow}\n     *\n     * @param cells {Map[]} Array of cell descriptions\n     * @param firstVisibleRow {Map} The pane's first visible row\n     * @param firstVisibleColumn {Map} The pane's first visible column\n     * @return {Map[]} Array, which contains a bounds map for each cell.\n     */\n    getCellBounds : function(cells, firstVisibleRow, firstVisibleColumn)\n    {\n      var bounds = [];\n      for (var i=0, l=cells.length; i<l; i++)\n      {\n        bounds.push(this._getSingleCellBounds(\n          cells[i], firstVisibleRow, firstVisibleColumn)\n        );\n      }\n      return bounds;\n    },\n\n\n    /**\n     * Compute a bitmap, which marks for each visible cell, whether the cell\n     * is covered by a spanning cell.\n     *\n     * @param cells {Map[]} Array of cell descriptions as returned by\n     *     {@link #findCellsInWindow}.\n     * @param firstRow {PositiveInteger} first visible row\n     * @param firstColumn {PositiveInteger} first visible column\n     * @param rowCount {PositiveInteger} number of rows in the window\n     * @param columnCount {PositiveInteger} number of columns in the window\n     * @return {Map[][]} Two dimensional array, which contains a <code>1</code>\n     *    for each visible cell, which is covered by a spanned cell.\n     */\n    computeCellSpanMap : function(cells, firstRow, firstColumn, rowCount, columnCount)\n    {\n      var map = [];\n\n      if (rowCount <= 0) {\n        return map;\n      }\n      var lastRow = firstRow + rowCount - 1;\n\n      for (var i=firstRow; i<= lastRow; i++) {\n        map[i] = [];\n      }\n\n      if (columnCount <= 0) {\n        return map;\n      }\n      var lastColumn = firstColumn + columnCount - 1;\n\n      for (var i=0, l=cells.length; i<l; i++)\n      {\n        var cell = cells[i];\n\n        var rowStartIndex = Math.max(firstRow, cell.firstRow);\n        var rowEndIndex = Math.min(lastRow, cell.lastRow);\n        var row;\n\n        for (var rowIndex=rowStartIndex; rowIndex <= rowEndIndex; rowIndex++)\n        {\n          row = map[rowIndex];\n\n          var columnStartIndex = Math.max(firstColumn, cell.firstColumn);\n          var columnEndIndex = Math.min(lastColumn, cell.lastColumn);\n          for (var columnIndex=columnStartIndex; columnIndex <= columnEndIndex; columnIndex++)\n          {\n            row[columnIndex] = 1;\n          }\n        }\n      }\n\n      return map;\n    }\n  },\n\n\n  destruct : function()\n  {\n    this._rowConfig.removeListener(\"change\", this._onRowConfigChange, this);\n    this._columnConfig.removeListener(\"change\", this._onColumnConfigChange, this);\n\n    this._cells = this._sorted = this._rowPos = this._columnPos =\n      this._rowConfig = this._columnConfig = null;\n  }\n});\n"
  ]
}