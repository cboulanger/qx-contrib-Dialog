{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/virtual/core/Pane.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "core",
    "Widget",
    "construct",
    "rowCount",
    "columnCount",
    "cellHeight",
    "cellWidth",
    "__rowConfig",
    "virtual",
    "Axis",
    "__columnConfig",
    "__scrollTop",
    "__scrollLeft",
    "__paneHeight",
    "__paneWidth",
    "__layerWindow",
    "__jobs",
    "__layerContainer",
    "container",
    "Composite",
    "setUserBounds",
    "_add",
    "__layers",
    "addListener",
    "fullUpdate",
    "_onResize",
    "addListenerOnce",
    "_onAppear",
    "_onPointerDown",
    "_onTap",
    "_onDbltap",
    "_onContextmenu",
    "events",
    "cellTap",
    "cellContextmenu",
    "cellDbltap",
    "update",
    "scrollX",
    "scrollY",
    "properties",
    "width",
    "refine",
    "init",
    "height",
    "members",
    "__dontFireUpdate",
    "__columnSizes",
    "__rowSizes",
    "__pointerDownCoords",
    "getRowConfig",
    "getColumnConfig",
    "getChildren",
    "addLayer",
    "layer",
    "assertInterface",
    "ILayer",
    "push",
    "add",
    "getLayers",
    "getVisibleLayers",
    "layers",
    "i",
    "length",
    "isVisible",
    "getScrollMaxX",
    "paneSize",
    "getInnerSize",
    "Math",
    "max",
    "getTotalSize",
    "getScrollMaxY",
    "setScrollY",
    "value",
    "old",
    "_deferredUpdateScrollPosition",
    "fireDataEvent",
    "getScrollY",
    "setScrollX",
    "getScrollX",
    "getScrollSize",
    "scrollRowIntoView",
    "row",
    "bounds",
    "getBounds",
    "event",
    "Timer",
    "once",
    "itemTop",
    "getItemPosition",
    "itemBottom",
    "getItemSize",
    "scrollTop",
    "scrollColumnIntoView",
    "column",
    "itemLeft",
    "itemRight",
    "scrollLeft",
    "scrollCellIntoView",
    "getCellAtPosition",
    "documentX",
    "documentY",
    "rowData",
    "columnData",
    "paneLocation",
    "getContentLocation",
    "top",
    "bottom",
    "left",
    "right",
    "getItemAtPosition",
    "index",
    "prefetchX",
    "minLeft",
    "maxLeft",
    "minRight",
    "maxRight",
    "paneRight",
    "rightAvailable",
    "min",
    "_setLayerWindow",
    "prefetchY",
    "minAbove",
    "maxAbove",
    "minBelow",
    "maxBelow",
    "paneBottom",
    "belowAvailable",
    "above",
    "below",
    "getContentElement",
    "getDomElement",
    "_updateScrollPosition",
    "fireEvent",
    "e",
    "getDocumentLeft",
    "getDocumentTop",
    "__handlePointerCellEvent",
    "_checkScrollBounds",
    "maxx",
    "maxy",
    "cellEventType",
    "coords",
    "pointerDownCoords",
    "fireNonBubblingEvent",
    "CellEvent",
    "syncWidget",
    "jobs",
    "_fullUpdate",
    "minWidth",
    "minHeight",
    "doFullUpdate",
    "rowCellData",
    "firstRow",
    "rowSizes",
    "getItemSizes",
    "offset",
    "layerHeight",
    "lang",
    "Array",
    "sum",
    "layerTop",
    "layerBottom",
    "columnCellData",
    "firstColumn",
    "columnSizes",
    "layerWidth",
    "layerLeft",
    "layerRight",
    "getPaddingLeft",
    "getPaddingTop",
    "updateLayerWindow",
    "__checkPaneResize",
    "scrollSize",
    "queue",
    "isUpdatePending",
    "paneWindow",
    "destruct",
    "_disposeArray",
    "_disposeObjects",
    "Pane"
  ],
  "mappings": "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",
  "file": "Pane.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n     * Jonathan Wei√ü (jonathan_rass)\n\n************************************************************************ */\n\n/**\n * EXPERIMENTAL!\n *\n * The Pane provides a window of a larger virtual grid.\n *\n * The actual rendering is performed by one or several layers ({@link ILayer}.\n * The pane computes, which cells of the virtual area is visible and instructs\n * the layers to render these cells.\n */\nqx.Class.define(\"qx.ui.virtual.core.Pane\",\n{\n  extend : qx.ui.core.Widget,\n\n\n  /**\n   * @param rowCount {Integer?0} The number of rows of the virtual grid.\n   * @param columnCount {Integer?0} The number of columns of the virtual grid.\n   * @param cellHeight {Integer?10} The default cell height.\n   * @param cellWidth {Integer?10} The default cell width.\n   */\n  construct : function(rowCount, columnCount, cellHeight, cellWidth)\n  {\n    this.base(arguments);\n\n    this.__rowConfig = new qx.ui.virtual.core.Axis(cellHeight, rowCount);\n    this.__columnConfig = new qx.ui.virtual.core.Axis(cellWidth, columnCount);\n\n    this.__scrollTop = 0;\n    this.__scrollLeft = 0;\n\n\n    this.__paneHeight = 0;\n    this.__paneWidth = 0;\n\n    this.__layerWindow = {};\n    this.__jobs = {};\n\n    // create layer container. The container does not have a layout manager\n    // layers are positioned using \"setUserBounds\"\n    this.__layerContainer = new qx.ui.container.Composite();\n    this.__layerContainer.setUserBounds(0, 0, 0, 0);\n    this._add(this.__layerContainer);\n\n    this.__layers = [];\n\n    this.__rowConfig.addListener(\"change\", this.fullUpdate, this);\n    this.__columnConfig.addListener(\"change\", this.fullUpdate, this);\n\n    this.addListener(\"resize\", this._onResize, this);\n    this.addListenerOnce(\"appear\", this._onAppear, this);\n\n    this.addListener(\"pointerdown\", this._onPointerDown, this);\n    this.addListener(\"tap\", this._onTap, this);\n    this.addListener(\"dbltap\", this._onDbltap, this);\n    this.addListener(\"contextmenu\", this._onContextmenu, this);\n  },\n\n\n  events :\n  {\n    /** Fired if a cell is tapped. */\n    cellTap : \"qx.ui.virtual.core.CellEvent\",\n\n    /** Fired if a cell is right-clicked. */\n    cellContextmenu : \"qx.ui.virtual.core.CellEvent\",\n\n    /** Fired if a cell is double-tapped. */\n    cellDbltap : \"qx.ui.virtual.core.CellEvent\",\n\n    /** Fired on resize of either the container or the (virtual) content. */\n    update : \"qx.event.type.Event\",\n\n    /** Fired if the pane is scrolled horizontally. */\n    scrollX : \"qx.event.type.Data\",\n\n    /** Fired if the pane is scrolled vertically. */\n    scrollY : \"qx.event.type.Data\"\n  },\n\n\n  properties :\n  {\n    // overridden\n    width :\n    {\n      refine : true,\n      init : 400\n    },\n\n\n    // overridden\n    height :\n    {\n      refine : true,\n      init : 300\n    }\n  },\n\n\n  members :\n  {\n    __rowConfig : null,\n    __columnConfig : null,\n    __scrollTop : null,\n    __scrollLeft : null,\n    __paneHeight : null,\n    __paneWidth : null,\n    __layerWindow : null,\n    __jobs : null,\n    __layerContainer : null,\n    __layers : null,\n    __dontFireUpdate : null,\n    __columnSizes : null,\n    __rowSizes : null,\n    __pointerDownCoords : null,\n\n\n    /*\n    ---------------------------------------------------------------------------\n      ACCESSOR METHODS\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Get the axis object, which defines the row numbers and the row sizes.\n     *\n     * @return {qx.ui.virtual.core.Axis} The row configuration.\n     */\n    getRowConfig : function() {\n      return this.__rowConfig;\n    },\n\n\n    /**\n     * Get the axis object, which defines the column numbers and the column sizes.\n     *\n     * @return {qx.ui.virtual.core.Axis} The column configuration.\n     */\n    getColumnConfig : function() {\n      return this.__columnConfig;\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      LAYER MANAGEMENT\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Returns an array containing the layer container.\n     *\n     * @return {Object[]} The layer container array.\n     */\n    getChildren : function() {\n      return [this.__layerContainer];\n    },\n\n\n    /**\n     * Add a layer to the layer container.\n     *\n     * @param layer {qx.ui.virtual.core.ILayer} The layer to add.\n     */\n    addLayer : function(layer)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        this.assertInterface(layer, qx.ui.virtual.core.ILayer);\n      }\n\n      this.__layers.push(layer);\n      layer.setUserBounds(0, 0, 0, 0);\n      this.__layerContainer.add(layer);\n    },\n\n\n    /**\n     * Get a list of all layers.\n     *\n     * @return {qx.ui.virtual.core.ILayer[]} List of the pane's layers.\n     */\n    getLayers : function() {\n      return this.__layers;\n    },\n\n\n    /**\n     * Get a list of all visible layers.\n     *\n     * @return {qx.ui.virtual.core.ILayer[]} List of the pane's visible layers.\n     */\n    getVisibleLayers : function()\n    {\n      var layers = [];\n      for (var i=0; i<this.__layers.length; i++)\n      {\n        var layer = this.__layers[i];\n        if (layer.isVisible()) {\n          layers.push(layer);\n        }\n      }\n      return layers;\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      SCROLL SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * The maximum horizontal scroll position.\n     *\n     * @return {Integer} Maximum horizontal scroll position.\n     */\n    getScrollMaxX : function()\n    {\n      var paneSize = this.getInnerSize();\n\n      if (paneSize) {\n        return Math.max(0, this.__columnConfig.getTotalSize() - paneSize.width);\n      }\n\n      return 0;\n    },\n\n\n    /**\n     * The maximum vertical scroll position.\n     *\n     * @return {Integer} Maximum vertical scroll position.\n     */\n    getScrollMaxY : function()\n    {\n      var paneSize = this.getInnerSize();\n\n      if (paneSize) {\n        return Math.max(0, this.__rowConfig.getTotalSize() - paneSize.height);\n      }\n\n      return 0;\n    },\n\n\n    /**\n     * Scrolls the content to the given left coordinate.\n     *\n     * @param value {Integer} The vertical position to scroll to.\n     */\n    setScrollY : function(value)\n    {\n      var max = this.getScrollMaxY();\n\n      if (value < 0) {\n        value = 0;\n      } else if (value > max) {\n        value = max;\n      }\n\n      if (this.__scrollTop !== value)\n      {\n        var old = this.__scrollTop;\n        this.__scrollTop = value;\n        this._deferredUpdateScrollPosition();\n        this.fireDataEvent(\"scrollY\", value, old);\n      }\n    },\n\n\n    /**\n     * Returns the vertical scroll offset.\n     *\n     * @return {Integer} The vertical scroll offset.\n     */\n    getScrollY : function() {\n      return this.__scrollTop;\n    },\n\n\n    /**\n     * Scrolls the content to the given top coordinate.\n     *\n     * @param value {Integer} The horizontal position to scroll to.\n     */\n    setScrollX : function(value)\n    {\n      var max = this.getScrollMaxX();\n\n      if (value < 0) {\n        value = 0;\n      } else if (value > max) {\n        value = max;\n      }\n\n      if (value !== this.__scrollLeft)\n      {\n        var old = this.__scrollLeft;\n        this.__scrollLeft = value;\n        this._deferredUpdateScrollPosition();\n\n        this.fireDataEvent(\"scrollX\", value, old);\n      }\n    },\n\n\n    /**\n     * Returns the horizontal scroll offset.\n     *\n     * @return {Integer} The horizontal scroll offset.\n     */\n    getScrollX : function() {\n      return this.__scrollLeft;\n    },\n\n\n    /**\n     * The (virtual) size of the content.\n     *\n     * @return {Map} Size of the content (keys: <code>width</code> and\n     *     <code>height</code>).\n     */\n    getScrollSize : function()\n    {\n      return {\n        width: this.__columnConfig.getTotalSize(),\n        height: this.__rowConfig.getTotalSize()\n      };\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      SCROLL INTO VIEW SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Scrolls a row into the visible area of the pane.\n     *\n     * @param row {Integer} The row's index.\n     */\n    scrollRowIntoView : function(row)\n    {\n      var bounds = this.getBounds();\n      if (!bounds)\n      {\n        this.addListenerOnce(\"appear\", function()\n        {\n          // It's important that the registered events are first dispatched.\n          qx.event.Timer.once(function() {\n            this.scrollRowIntoView(row);\n          }, this, 0);\n        }, this);\n        return;\n      }\n\n      var itemTop = this.__rowConfig.getItemPosition(row);\n      var itemBottom = itemTop + this.__rowConfig.getItemSize(row);\n      var scrollTop = this.getScrollY();\n\n      if (itemTop < scrollTop) {\n        this.setScrollY(itemTop);\n      } else if (itemBottom > scrollTop + bounds.height) {\n        this.setScrollY(itemBottom - bounds.height);\n      }\n    },\n\n\n    /**\n     * Scrolls a column into the visible area of the pane.\n     *\n     * @param column {Integer} The column's index.\n     */\n    scrollColumnIntoView : function(column)\n    {\n      var bounds = this.getBounds();\n      if (!bounds)\n      {\n        this.addListenerOnce(\"appear\", function()\n        {\n          // It's important that the registered events are first dispatched.\n          qx.event.Timer.once(function() {\n            this.scrollColumnIntoView(column);\n          }, this, 0);\n        }, this);\n        return;\n      }\n\n      var itemLeft = this.__columnConfig.getItemPosition(column);\n      var itemRight = itemLeft + this.__columnConfig.getItemSize(column);\n      var scrollLeft = this.getScrollX();\n\n      if (itemLeft < scrollLeft) {\n        this.setScrollX(itemLeft);\n      } else if (itemRight > scrollLeft + bounds.width) {\n        this.setScrollX(itemRight - bounds.width);\n      }\n    },\n\n\n    /**\n     * Scrolls a grid cell into the visible area of the pane.\n     *\n     * @param row {Integer} The cell's row index.\n     * @param column {Integer} The cell's column index.\n     */\n    scrollCellIntoView : function(column, row)\n    {\n      var bounds = this.getBounds();\n      if (!bounds)\n      {\n        this.addListenerOnce(\"appear\", function()\n        {\n          // It's important that the registered events are first dispatched.\n          qx.event.Timer.once(function() {\n            this.scrollCellIntoView(column, row);\n          }, this, 0);\n        }, this);\n        return;\n      }\n\n      this.scrollColumnIntoView(column);\n      this.scrollRowIntoView(row);\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      CELL SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Get the grid cell at the given absolute document coordinates. This method\n     * can be used to convert the pointer position returned by\n     * {@link qx.event.type.Pointer#getDocumentLeft} and\n     * {@link qx.event.type.Pointer#getDocumentLeft} into cell coordinates.\n     *\n     * @param documentX {Integer} The x coordinate relative to the viewport\n     *    origin.\n     * @param documentY {Integer} The y coordinate relative to the viewport\n     *    origin.\n     * @return {Map|null} A map containing the <code>row</code> and <code>column</code>\n     *    of the found cell. If the coordinate is outside of the pane's bounds\n     *    or there is no cell at the coordinate <code>null</code> is returned.\n     */\n    getCellAtPosition: function(documentX, documentY)\n    {\n      var rowData, columnData;\n      var paneLocation = this.getContentLocation();\n\n      if (\n        !paneLocation ||\n        documentY < paneLocation.top ||\n        documentY >= paneLocation.bottom ||\n        documentX < paneLocation.left ||\n        documentX >= paneLocation.right\n      ) {\n        return null;\n      }\n\n      rowData = this.__rowConfig.getItemAtPosition(\n        this.getScrollY() + documentY - paneLocation.top\n      );\n\n      columnData = this.__columnConfig.getItemAtPosition(\n        this.getScrollX() + documentX - paneLocation.left\n      );\n\n      if (!rowData || !columnData) {\n        return null;\n      }\n\n      return {\n        row : rowData.index,\n        column : columnData.index\n      };\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      PREFETCH SUPPORT\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Increase the layers width beyond the needed width to improve\n     * horizontal scrolling. The layers are only resized if invisible parts\n     * left/right of the pane window are smaller than minLeft/minRight.\n     *\n     * @param minLeft {Integer} Only prefetch if the invisible part left of the\n     *    pane window if smaller than this (pixel) value.\n     * @param maxLeft {Integer} The amount of pixel the layers should reach\n     *    left of the pane window.\n     * @param minRight {Integer} Only prefetch if the invisible part right of the\n     *    pane window if smaller than this (pixel) value.\n     * @param maxRight {Integer} The amount of pixel the layers should reach\n     *    right of the pane window.\n     */\n    prefetchX : function(minLeft, maxLeft, minRight, maxRight)\n    {\n      var layers = this.getVisibleLayers();\n      if (layers.length == 0) {\n        return;\n      }\n\n      var bounds = this.getBounds();\n      if (!bounds) {\n        return;\n      }\n\n      var paneRight = this.__scrollLeft + bounds.width;\n      var rightAvailable = this.__paneWidth - paneRight;\n      if (\n        this.__scrollLeft - this.__layerWindow.left  < Math.min(this.__scrollLeft, minLeft) ||\n        this.__layerWindow.right - paneRight < Math.min(rightAvailable, minRight)\n      )\n      {\n        var left = Math.min(this.__scrollLeft, maxLeft);\n        var right = Math.min(rightAvailable, maxRight);\n        this._setLayerWindow(\n          layers,\n          this.__scrollLeft - left,\n          this.__scrollTop,\n          bounds.width + left + right,\n          bounds.height,\n          false\n        );\n      }\n    },\n\n\n    /**\n     * Increase the layers height beyond the needed height to improve\n     * vertical scrolling. The layers are only resized if invisible parts\n     * above/below the pane window are smaller than minAbove/minBelow.\n     *\n     * @param minAbove {Integer} Only prefetch if the invisible part above the\n     *    pane window if smaller than this (pixel) value.\n     * @param maxAbove {Integer} The amount of pixel the layers should reach\n     *    above the pane window.\n     * @param minBelow {Integer} Only prefetch if the invisible part below the\n     *    pane window if smaller than this (pixel) value.\n     * @param maxBelow {Integer} The amount of pixel the layers should reach\n     *    below the pane window.\n     */\n    prefetchY : function(minAbove, maxAbove, minBelow, maxBelow)\n    {\n      var layers = this.getVisibleLayers();\n      if (layers.length == 0) {\n        return;\n      }\n\n      var bounds = this.getBounds();\n      if (!bounds) {\n        return;\n      }\n\n      var paneBottom = this.__scrollTop + bounds.height;\n      var belowAvailable = this.__paneHeight - paneBottom;\n      if (\n        this.__scrollTop - this.__layerWindow.top  < Math.min(this.__scrollTop, minAbove) ||\n        this.__layerWindow.bottom - paneBottom < Math.min(belowAvailable, minBelow)\n      )\n      {\n        var above = Math.min(this.__scrollTop, maxAbove);\n        var below = Math.min(belowAvailable, maxBelow);\n        this._setLayerWindow(\n          layers,\n          this.__scrollLeft,\n          this.__scrollTop - above,\n          bounds.width,\n          bounds.height + above + below,\n          false\n        );\n      }\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT LISTENER\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Resize event handler.\n     *\n     * Updates the visible window.\n     */\n    _onResize : function()\n    {\n      if (this.getContentElement().getDomElement())\n      {\n        this.__dontFireUpdate = true;\n        this._updateScrollPosition();\n        this.__dontFireUpdate = null;\n        this.fireEvent(\"update\");\n      }\n    },\n\n\n    /**\n     * Resize event handler. Do a full update on first appear.\n     */\n    _onAppear : function() {\n      this.fullUpdate();\n    },\n\n    /**\n     * Event listener for pointer down. Remembers cell position to prevent pointer event when cell position change.\n     *\n     * @param e {qx.event.type.Pointer} The incoming pointer event.\n     */\n    _onPointerDown : function(e) {\n      this.__pointerDownCoords = this.getCellAtPosition(e.getDocumentLeft(), e.getDocumentTop());\n    },\n\n    /**\n     * Event listener for pointer taps. Fires an cellTap event.\n     *\n     * @param e {qx.event.type.Pointer} The incoming pointer event.\n     */\n    _onTap : function(e) {\n      this.__handlePointerCellEvent(e, \"cellTap\");\n    },\n\n\n    /**\n     * Event listener for context menu taps. Fires an cellContextmenu event.\n     *\n     * @param e {qx.event.type.Pointer} The incoming pointer event.\n     */\n    _onContextmenu : function(e) {\n      this.__handlePointerCellEvent(e, \"cellContextmenu\");\n    },\n\n\n    /**\n     * Event listener for double taps. Fires an cellDbltap event.\n     *\n     * @param e {qx.event.type.Pointer} The incoming pointer event.\n     */\n    _onDbltap : function(e) {\n       this.__handlePointerCellEvent(e, \"cellDbltap\");\n    },\n\n    /**\n     * Fixed scrollbar position whenever it is out of range\n     * it can happen when removing an item from the list reducing\n     * the max value for scrollY #8976\n     */\n    _checkScrollBounds: function() {\n      var maxx = this.getScrollMaxX();\n      var maxy = this.getScrollMaxY();\n      if (this.__scrollLeft < 0) {\n        this.__scrollLeft = 0;\n      }\n      else if (this.__scrollLeft > maxx) {\n        this.__scrollLeft = maxx;\n      }\n      if (this.__scrollTop < 0) {\n        this.__scrollTop = 0;\n      }\n      else if (this.__scrollTop > maxy) {\n        this.__scrollTop = maxy;\n      }\n    },\n\n    /**\n     * Converts a pointer event into a cell event and fires the cell event if the\n     * pointer is over a cell.\n     *\n     * @param e {qx.event.type.Pointer} The pointer event.\n     * @param cellEventType {String} The name of the cell event to fire.\n     */\n    __handlePointerCellEvent : function(e, cellEventType)\n    {\n      var coords = this.getCellAtPosition(e.getDocumentLeft(), e.getDocumentTop());\n      if (!coords) {\n        return;\n      }\n\n      var pointerDownCoords = this.__pointerDownCoords;\n      if (pointerDownCoords == null || pointerDownCoords.row !== coords.row || pointerDownCoords.column !== coords.column) {\n        return;\n      }\n\n      this.fireNonBubblingEvent(\n        cellEventType,\n        qx.ui.virtual.core.CellEvent,\n        [this, e, coords.row, coords.column]\n      );\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      PANE UPDATE\n    ---------------------------------------------------------------------------\n    */\n\n\n    // overridden\n    syncWidget : function(jobs)\n    {\n      if (this.__jobs._fullUpdate) {\n        this._checkScrollBounds();\n        this._fullUpdate();\n      } else if (this.__jobs._updateScrollPosition) {\n        this._checkScrollBounds();\n        this._updateScrollPosition();\n      }\n      this.__jobs = {};\n    },\n\n\n    /**\n     * Sets the size of the layers to contain the cells at the pixel position\n     * \"left/right\" up to \"left+minHeight/right+minHeight\". The offset of the\n     * layer container is adjusted to respect the pane's scroll top and scroll\n     * left values.\n     *\n     * @param layers {qx.ui.virtual.core.ILayer[]} List of layers to update.\n     * @param left {Integer} Maximum left pixel coordinate of the layers.\n     * @param top {Integer} Maximum top pixel coordinate of the layers.\n     * @param minWidth {Integer} The minimum end coordinate of the layers will\n     *    be larger than <code>left+minWidth</code>.\n     * @param minHeight {Integer} The minimum end coordinate of the layers will\n     *    be larger than <code>top+minHeight</code>.\n     * @param doFullUpdate {Boolean?false} Whether a full update on the layer\n     *    should be performed of if only the layer window should be updated.\n     */\n    _setLayerWindow : function(layers, left, top, minWidth, minHeight, doFullUpdate)\n    {\n      var rowCellData = this.__rowConfig.getItemAtPosition(top);\n      if (rowCellData)\n      {\n        var firstRow = rowCellData.index;\n        var rowSizes = this.__rowConfig.getItemSizes(firstRow, minHeight + rowCellData.offset);\n        var layerHeight = qx.lang.Array.sum(rowSizes);\n        var layerTop = top - rowCellData.offset;\n        var layerBottom = top - rowCellData.offset + layerHeight;\n      }\n      else\n      {\n        var firstRow = 0;\n        var rowSizes = [];\n        var layerHeight = 0;\n        var layerTop = 0;\n        var layerBottom = 0;\n      }\n\n      var columnCellData = this.__columnConfig.getItemAtPosition(left);\n      if (columnCellData)\n      {\n        var firstColumn = columnCellData.index;\n        var columnSizes = this.__columnConfig.getItemSizes(firstColumn, minWidth + columnCellData.offset);\n        var layerWidth = qx.lang.Array.sum(columnSizes);\n        var layerLeft = left - columnCellData.offset;\n        var layerRight = left - columnCellData.offset + layerWidth;\n      }\n      else\n      {\n        var firstColumn = 0;\n        var columnSizes = [];\n        var layerWidth = 0;\n        var layerLeft = 0;\n        var layerRight = 0;\n      }\n\n      this.__layerWindow = {\n        top: layerTop,\n        bottom: layerBottom,\n        left: layerLeft,\n        right: layerRight\n      };\n\n      this.__layerContainer.setUserBounds(\n        (this.getPaddingLeft() || 0) + (this.__layerWindow.left - this.__scrollLeft),\n        (this.getPaddingTop() || 0) + (this.__layerWindow.top - this.__scrollTop),\n        layerWidth, layerHeight\n      );\n\n      this.__columnSizes = columnSizes;\n      this.__rowSizes = rowSizes;\n\n      for (var i=0; i<this.__layers.length; i++)\n      {\n        var layer = this.__layers[i];\n        layer.setUserBounds(0, 0, layerWidth, layerHeight);\n\n        if (doFullUpdate) {\n          layer.fullUpdate(firstRow, firstColumn, rowSizes, columnSizes);\n        } else {\n          layer.updateLayerWindow(firstRow, firstColumn, rowSizes, columnSizes);\n        }\n      }\n    },\n\n\n\n    /**\n     * Check whether the pane was resized and fire an {@link #update} event if\n     * it was.\n     */\n    __checkPaneResize : function()\n    {\n      if (this.__dontFireUpdate) {\n        return;\n      }\n\n      var scrollSize = this.getScrollSize();\n      if (\n        this.__paneHeight !== scrollSize.height ||\n        this.__paneWidth !== scrollSize.width\n      )\n      {\n        this.__paneHeight = scrollSize.height;\n        this.__paneWidth = scrollSize.width;\n        this.fireEvent(\"update\");\n      }\n    },\n\n\n    /**\n     * Schedule a full update on all visible layers.\n     */\n    fullUpdate : function()\n    {\n      this.__jobs._fullUpdate = 1;\n      qx.ui.core.queue.Widget.add(this);\n    },\n\n\n    /**\n     * Whether a full update is scheduled.\n     *\n     * @return {Boolean} Whether a full update is scheduled.\n     */\n    isUpdatePending : function() {\n      return !!this.__jobs._fullUpdate;\n    },\n\n\n    /**\n     * Perform a full update on all visible layers. All cached data will be\n     * discarded.\n     */\n    _fullUpdate : function()\n    {\n      var layers = this.getVisibleLayers();\n      if (layers.length == 0)\n      {\n        this.__checkPaneResize();\n        return;\n      }\n\n      var bounds = this.getBounds();\n\n      if (!bounds) {\n        return; // the pane has not yet been rendered -> wait for the appear event\n      }\n\n\n\n      this._setLayerWindow(\n        layers,\n        this.__scrollLeft, this.__scrollTop,\n        bounds.width, bounds.height,\n        true\n      );\n\n      this.__checkPaneResize();\n    },\n\n\n    /**\n     * Schedule an update the visible window of the grid according to the top\n     * and left scroll positions.\n     */\n    _deferredUpdateScrollPosition : function()\n    {\n      this.__jobs._updateScrollPosition = 1;\n      qx.ui.core.queue.Widget.add(this);\n    },\n\n\n    /**\n     * Update the visible window of the grid according to the top and left scroll\n     * positions.\n     */\n    _updateScrollPosition : function()\n    {\n      var layers = this.getVisibleLayers();\n      if (layers.length == 0)\n      {\n        this.__checkPaneResize();\n        return;\n      }\n\n      var bounds = this.getBounds();\n      if (!bounds) {\n        return; // the pane has not yet been rendered -> wait for the appear event\n      }\n\n      // the visible window of the virtual coordinate space\n      var paneWindow = {\n        top: this.__scrollTop,\n        bottom: this.__scrollTop + bounds.height,\n        left: this.__scrollLeft,\n        right: this.__scrollLeft + bounds.width\n      };\n\n      if (\n        this.__layerWindow.top <= paneWindow.top &&\n        this.__layerWindow.bottom >= paneWindow.bottom &&\n        this.__layerWindow.left <= paneWindow.left &&\n        this.__layerWindow.right >= paneWindow.right\n      )\n      {\n        // only update layer container offset\n        this.__layerContainer.setUserBounds(\n          (this.getPaddingLeft() || 0) + (this.__layerWindow.left - paneWindow.left),\n          (this.getPaddingTop() || 0) + (this.__layerWindow.top - paneWindow.top),\n          this.__layerWindow.right - this.__layerWindow.left,\n          this.__layerWindow.bottom - this.__layerWindow.top\n        );\n      }\n      else\n      {\n        this._setLayerWindow(\n          layers,\n          this.__scrollLeft, this.__scrollTop,\n          bounds.width, bounds.height,\n          false\n        );\n      }\n\n      this.__checkPaneResize();\n    }\n  },\n\n\n  destruct : function()\n  {\n    this._disposeArray(\"__layers\");\n    this._disposeObjects(\"__rowConfig\", \"__columnConfig\", \"__layerContainer\");\n    this.__layerWindow = this.__jobs = this.__columnSizes =\n      this.__rowSizes = null;\n  }\n});\n"
  ]
}