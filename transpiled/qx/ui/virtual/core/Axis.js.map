{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/virtual/core/Axis.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "defaultItemSize",
    "itemCount",
    "customSizes",
    "events",
    "members",
    "__ranges",
    "getDefaultItemSize",
    "setDefaultItemSize",
    "fireNonBubblingEvent",
    "getItemCount",
    "setItemCount",
    "setItemSize",
    "index",
    "size",
    "assertArgumentsCount",
    "arguments",
    "assert",
    "getItemSize",
    "resetItemSizes",
    "__getRanges",
    "defaultSize",
    "indexes",
    "key",
    "parseInt",
    "push",
    "length",
    "ranges",
    "startIndex",
    "endIndex",
    "firstItemSize",
    "rangeStart",
    "rangeEnd",
    "sort",
    "a",
    "b",
    "correctionSum",
    "i",
    "cellSize",
    "unshift",
    "lastRange",
    "remainingItemsSize",
    "__findRangeByPosition",
    "position",
    "start",
    "end",
    "pivot",
    "range",
    "getItemAtPosition",
    "getTotalSize",
    "startPos",
    "offset",
    "Math",
    "floor",
    "__findRangeByIndex",
    "getItemPosition",
    "getItemSizes",
    "minSizeSum",
    "sum",
    "sizes",
    "itemSize",
    "destruct",
    "ui",
    "virtual",
    "Axis"
  ],
  "mappings": ";;;;;;;;;;;;;AAAAA,KAAGC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC,EAyBAH,GAAGI,KAAH,CAASC,MAAT,CAAgB,yBAAhB,EACA;AACEC,YAASN,GAAGO,IAAH,CAAQC,MADnB;;AAGE;;;;AAIAC,eAAY,mBAASC,eAAT,EAA0BC,SAA1B,EACZ;AACE;;AAEA,WAAKA,SAAL,GAAiBA,SAAjB;AACA,WAAKD,eAAL,GAAuBA,eAAvB;;AAEA;AACA,WAAKE,WAAL,GAAmB,EAAnB;AACD,KAhBH;;AAmBEC,YACA;AACE;AACA,gBAAW;AAFb,KApBF;;AA0BEC,aACA;AACEC,gBAAW,IADb;;AAIE;;;;;AAKAC,0BAAqB,8BAAW;AAC9B,eAAO,KAAKN,eAAZ;AACD,OAXH;;AAcE;;;;;AAKAO,0BAAqB,4BAASP,eAAT,EACrB;AACE,YAAI,KAAKA,eAAL,KAAyBA,eAA7B,EACA;AACE,eAAKA,eAAL,GAAuBA,eAAvB;AACA,eAAKK,QAAL,GAAgB,IAAhB;AACA,eAAKG,oBAAL,CAA0B,QAA1B;AACD;AACF,OA3BH;;AA8BE;;;;;AAKAC,oBAAe,wBAAW;AACxB,eAAO,KAAKR,SAAZ;AACD,OArCH;;AAwCE;;;;;AAKAS,oBAAe,sBAAST,SAAT,EACf;AACE,YAAI,KAAKA,SAAL,KAAmBA,SAAvB,EACA;AACE,eAAKA,SAAL,GAAiBA,SAAjB;AACA,eAAKI,QAAL,GAAgB,IAAhB;AACA,eAAKG,oBAAL,CAA0B,QAA1B;AACD;AACF,OArDH;;AAwDE;;;;;;;AAOAG,mBAAc,qBAASC,KAAT,EAAgBC,IAAhB,EACd;AAEE;AACE,eAAKC,oBAAL,CAA0BC,SAA1B,EAAqC,CAArC,EAAwC,CAAxC;AACA,eAAKC,MAAL,CACEH,QAAQ,CAAR,IAAaA,SAAS,IADxB,EAEE,oDAFF;AAID;AACD,YAAI,KAAKX,WAAL,CAAiBU,KAAjB,KAA2BC,IAA/B,EAAqC;AACnC;AACD;;AAED,YAAIA,SAAS,IAAb,EAAmB;AACjB,iBAAO,KAAKX,WAAL,CAAiBU,KAAjB,CAAP;AACD,SAFD,MAEO;AACL,eAAKV,WAAL,CAAiBU,KAAjB,IAA0BC,IAA1B;AACD;AACD,aAAKR,QAAL,GAAgB,IAAhB;AACA,aAAKG,oBAAL,CAA0B,QAA1B;AACD,OApFH;;AAuFE;;;;;;AAMAS,mBAAc,qBAASL,KAAT,EACd;AACE;AACA,eAAO,KAAKV,WAAL,CAAiBU,KAAjB,KAA2B,KAAKZ,eAAvC;AACD,OAjGH;;AAoGE;;;AAGAkB,sBAAiB,0BACjB;AACE,aAAKhB,WAAL,GAAmB,EAAnB;AACA,aAAKG,QAAL,GAAgB,IAAhB;AACA,aAAKG,oBAAL,CAA0B,QAA1B;AACD,OA5GH;;AA+GE;;;;;;;;;AASAW,mBAAc,uBACd;AACE,YAAI,KAAKd,QAAT,EAAmB;AACjB,iBAAO,KAAKA,QAAZ;AACD;;AAED,YAAIe,cAAc,KAAKpB,eAAvB;AACA,YAAIC,YAAY,KAAKA,SAArB;;AAEA,YAAIoB,UAAU,EAAd;AACA,aAAK,IAAIC,GAAT,IAAgB,KAAKpB,WAArB,EACA;AACE,cAAIU,QAAQW,SAASD,GAAT,EAAc,EAAd,CAAZ;AACA,cAAIV,QAAQX,SAAZ,EAAuB;AACrBoB,oBAAQG,IAAR,CAAaZ,KAAb;AACD;AACF;AACD,YAAIS,QAAQI,MAAR,IAAkB,CAAtB,EACA;AACE,cAAIC,SAAS,CAAC;AACZC,wBAAY,CADA;AAEZC,sBAAU3B,YAAY,CAFV;AAGZ4B,2BAAeT,WAHH;AAIZU,wBAAY,CAJA;AAKZC,sBAAU9B,YAAYmB,WAAZ,GAA0B;AALxB,WAAD,CAAb;AAOA,eAAKf,QAAL,GAAgBqB,MAAhB;AACA,iBAAOA,MAAP;AACD;;AAEDL,gBAAQW,IAAR,CAAa,UAASC,CAAT,EAAWC,CAAX,EAAc;AAAE,iBAAOD,IAAIC,CAAJ,GAAQ,CAAR,GAAY,CAAC,CAApB;AAAuB,SAApD;;AAEA,YAAIR,SAAS,EAAb;AACA,YAAIS,gBAAgB,CAApB;;AAEA,aAAK,IAAIC,IAAE,CAAX,EAAcA,IAAEf,QAAQI,MAAxB,EAAgCW,GAAhC,EACA;AACE,cAAIxB,QAAQS,QAAQe,CAAR,CAAZ;AACA,cAAIxB,SAASX,SAAb,EAAwB;AACtB;AACD;;AAED,cAAIoC,WAAW,KAAKnC,WAAL,CAAiBU,KAAjB,CAAf;AACA,cAAIkB,aAAalB,QAAQQ,WAAR,GAAsBe,aAAvC;;AAEAA,2BAAiBE,WAAWjB,WAA5B;;AAEAM,iBAAOU,CAAP,IAAY;AACVT,wBAAYf,KADF;AAEViB,2BAAeQ,QAFL;AAGVP,wBAAYA;AAHF,WAAZ;AAKA,cAAIM,IAAI,CAAR,EAAW;AACTV,mBAAOU,IAAE,CAAT,EAAYL,QAAZ,GAAuBD,aAAW,CAAlC;AACAJ,mBAAOU,IAAE,CAAT,EAAYR,QAAZ,GAAuBhB,QAAM,CAA7B;AACD;AACF;;AAED;AACA,YAAIc,OAAO,CAAP,EAAUI,UAAV,GAAuB,CAA3B,EACA;AACEJ,iBAAOY,OAAP,CAAe;AACbX,wBAAY,CADC;AAEbC,sBAAUF,OAAO,CAAP,EAAUC,UAAV,GAAqB,CAFlB;AAGbE,2BAAeT,WAHF;AAIbU,wBAAY,CAJC;AAKbC,sBAAUL,OAAO,CAAP,EAAUI,UAAV,GAAqB;AALlB,WAAf;AAOD;;AAED;AACA,YAAIS,YAAYb,OAAOA,OAAOD,MAAP,GAAc,CAArB,CAAhB;AACA,YAAIe,qBAAqB,CAACvC,YAAYsC,UAAUZ,UAAtB,GAAmC,CAApC,IAAyCP,WAAlE;AACAmB,kBAAUR,QAAV,GAAqBQ,UAAUT,UAAV,GAAuBS,UAAUV,aAAjC,GAAiDW,kBAAjD,GAAsE,CAA3F;AACAD,kBAAUX,QAAV,GAAqB3B,YAAY,CAAjC;;AAEA,aAAKI,QAAL,GAAgBqB,MAAhB;AACA,eAAOA,MAAP;AACD,OAtMH;;AAyME;;;;;;;;AAQAe,6BAAwB,+BAASC,QAAT,EACxB;AACE,YAAIhB,SAAS,KAAKrB,QAAL,IAAiB,KAAKc,WAAL,EAA9B;;AAEA,YAAIwB,QAAQ,CAAZ;AACA,YAAIC,MAAMlB,OAAOD,MAAP,GAAc,CAAxB;;AAEA;AACA,eAAO,IAAP,EACA;AACE,cAAIoB,QAAQF,SAAUC,MAAMD,KAAP,IAAiB,CAA1B,CAAZ;AACA,cAAIG,QAAQpB,OAAOmB,KAAP,CAAZ;;AAEA,cAAIC,MAAMf,QAAN,GAAiBW,QAArB,EAA+B;AAC7BC,oBAAQE,QAAQ,CAAhB;AACD,WAFD,MAEO,IAAIC,MAAMhB,UAAN,GAAmBY,QAAvB,EAAiC;AACtCE,kBAAMC,QAAQ,CAAd;AACD,WAFM,MAEA;AACL,mBAAOC,KAAP;AACD;AACF;AACF,OAtOH;;AAyOE;;;;;;;;;AASAC,yBAAoB,2BAASL,QAAT,EACpB;AACE,YAAIA,WAAW,CAAX,IAAgBA,YAAY,KAAKM,YAAL,EAAhC,EAAqD;AACnD,iBAAO,IAAP;AACD;;AAED,YAAIF,QAAQ,KAAKL,qBAAL,CAA2BC,QAA3B,CAAZ;;AAEA,YAAIO,WAAWH,MAAMhB,UAArB;AACA,YAAIlB,QAAQkC,MAAMnB,UAAlB;AACA,YAAIE,gBAAgBiB,MAAMjB,aAA1B;;AAEA,YAAIoB,WAAWpB,aAAX,GAA2Ba,QAA/B,EACA;AACE,iBAAO;AACL9B,mBAAOA,KADF;AAELsC,oBAAQR,WAAWO;AAFd,WAAP;AAID,SAND,MAQA;AACE,cAAI7B,cAAc,KAAKpB,eAAvB;AACA,iBAAO;AACLY,mBAAOA,QAAQ,CAAR,GAAYuC,KAAKC,KAAL,CAAW,CAACV,WAAWO,QAAX,GAAsBpB,aAAvB,IAAwCT,WAAnD,CADd;AAEL8B,oBAAQ,CAACR,WAAWO,QAAX,GAAsBpB,aAAvB,IAAwCT;AAF3C,WAAP;AAID;AACF,OA7QH;;AAgRE;;;;;;;;AAQAiC,0BAAqB,4BAASzC,KAAT,EACrB;AACE,YAAIc,SAAS,KAAKrB,QAAL,IAAiB,KAAKc,WAAL,EAA9B;;AAEA,YAAIwB,QAAQ,CAAZ;AACA,YAAIC,MAAMlB,OAAOD,MAAP,GAAc,CAAxB;;AAEA;AACA,eAAO,IAAP,EACA;AACE,cAAIoB,QAAQF,SAAUC,MAAMD,KAAP,IAAiB,CAA1B,CAAZ;AACA,cAAIG,QAAQpB,OAAOmB,KAAP,CAAZ;;AAEA,cAAIC,MAAMlB,QAAN,GAAiBhB,KAArB,EAA4B;AAC1B+B,oBAAQE,QAAQ,CAAhB;AACD,WAFD,MAEO,IAAIC,MAAMnB,UAAN,GAAmBf,KAAvB,EAA8B;AACnCgC,kBAAMC,QAAQ,CAAd;AACD,WAFM,MAEA;AACL,mBAAOC,KAAP;AACD;AACF;AACF,OA7SH;;AAgTE;;;;;;;AAOAQ,uBAAkB,yBAAS1C,KAAT,EAClB;AACE,YAAIA,QAAQ,CAAR,IAAaA,SAAS,KAAKX,SAA/B,EAA0C;AACxC,iBAAO,IAAP;AACD;;AAED,YAAI6C,QAAQ,KAAKO,kBAAL,CAAwBzC,KAAxB,CAAZ;AACA,YAAIkC,MAAMnB,UAAN,IAAoBf,KAAxB,EAA+B;AAC7B,iBAAOkC,MAAMhB,UAAb;AACD,SAFD,MAEO;AACL,iBAAOgB,MAAMhB,UAAN,GAAmBgB,MAAMjB,aAAzB,GAAyC,CAACjB,QAAMkC,MAAMnB,UAAZ,GAAuB,CAAxB,IAA6B,KAAK3B,eAAlF;AACD;AACF,OAnUH;;AAsUE;;;;;AAKAgD,oBAAe,wBACf;AACE,YAAItB,SAAS,KAAKrB,QAAL,IAAiB,KAAKc,WAAL,EAA9B;AACA,eAAOO,OAAOA,OAAOD,MAAP,GAAc,CAArB,EAAwBM,QAAxB,GAAmC,CAA1C;AACD,OA/UH;;AAkVE;;;;;;;;;;AAUAwB,oBAAe,sBAAS5B,UAAT,EAAqB6B,UAArB,EACf;AACE,YAAItD,cAAc,KAAKA,WAAvB;AACA,YAAIkB,cAAc,KAAKpB,eAAvB;;AAEA,YAAIyD,MAAM,CAAV;AACA,YAAIC,QAAQ,EAAZ;AACA,YAAItB,IAAE,CAAN;AACA,eAAOqB,MAAMD,UAAb,EACA;AACE,cAAIG,WAAWzD,YAAYyB,UAAZ,KAA2B,IAA3B,GAAkCzB,YAAYyB,UAAZ,CAAlC,GAA4DP,WAA3E;AACAO;;AAEA8B,iBAAOE,QAAP;AACAD,gBAAMtB,GAAN,IAAauB,QAAb;AACA,cAAIhC,cAAc,KAAK1B,SAAvB,EAAkC;AAChC;AACD;AACF;AACD,eAAOyD,KAAP;AACD;AAhXH,KA3BF;;AA+YEE,cAAW,oBAAW;AACpB,WAAK1D,WAAL,GAAmB,KAAKG,QAAL,GAAgB,IAAnC;AACD;AAjZH,GADA,C;AAzBAf,KAAGuE,EAAH,CAAMC,OAAN,CAAcjE,IAAd,CAAmBkE,IAAnB,CAAwBtE,aAAxB,GAAwCA,aAAxC",
  "file": "Axis.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * EXPERIMENTAL!\n *\n * The axis maps virtual screen coordinates to item indexes. By default all\n * items have the same size but it is also possible to give specific items\n * a different size.\n */\nqx.Class.define(\"qx.ui.virtual.core.Axis\",\n{\n  extend : qx.core.Object,\n\n  /**\n   * @param defaultItemSize {Integer} The default size of the items.\n   * @param itemCount {Integer} The number of item on the axis.\n   */\n  construct : function(defaultItemSize, itemCount)\n  {\n    this.base(arguments);\n\n    this.itemCount = itemCount;\n    this.defaultItemSize = defaultItemSize;\n\n    // sparse array\n    this.customSizes = {};\n  },\n\n\n  events :\n  {\n    /** Every change to the axis configuration triggers this event. */\n    \"change\" : \"qx.event.type.Event\"\n  },\n\n\n  members :\n  {\n    __ranges : null,\n\n\n    /**\n     * Get the default size of the items.\n     *\n     * @return {Integer} The default item size.\n     */\n    getDefaultItemSize : function() {\n      return this.defaultItemSize;\n    },\n\n\n    /**\n     * Set the default size the items.\n     *\n     * @param defaultItemSize {Integer} The default size of the items.\n     */\n    setDefaultItemSize : function(defaultItemSize)\n    {\n      if (this.defaultItemSize !== defaultItemSize)\n      {\n        this.defaultItemSize = defaultItemSize;\n        this.__ranges = null;\n        this.fireNonBubblingEvent(\"change\");\n      }\n    },\n\n\n    /**\n     * Get the number of items in the axis.\n     *\n     * @return {Integer} The number of items.\n     */\n    getItemCount : function() {\n      return this.itemCount;\n    },\n\n\n    /**\n     * Set the number of items in the axis.\n     *\n     * @param itemCount {Integer} The new item count.\n     */\n    setItemCount : function(itemCount)\n    {\n      if (this.itemCount !== itemCount)\n      {\n        this.itemCount = itemCount;\n        this.__ranges = null;\n        this.fireNonBubblingEvent(\"change\");\n      }\n    },\n\n\n    /**\n     * Sets the size of a specific item. This allow item, which have a size\n     * different from the default size.\n     *\n     * @param index {Integer} Index of the item to change.\n     * @param size {Integer} New size of the item.\n     */\n    setItemSize : function(index, size)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        this.assertArgumentsCount(arguments, 2, 2);\n        this.assert(\n          size >= 0 || size === null,\n          \"'size' must be 'null' or an integer larger than 0.\"\n        );\n      }\n      if (this.customSizes[index] == size) {\n        return;\n      }\n\n      if (size === null) {\n        delete this.customSizes[index];\n      } else {\n        this.customSizes[index] = size;\n      }\n      this.__ranges = null;\n      this.fireNonBubblingEvent(\"change\");\n    },\n\n\n    /**\n     * Get the size of the item at the given index.\n     *\n     * @param index {Integer} Index of the item to get the size for.\n     * @return {Integer} Size of the item.\n     */\n    getItemSize : function(index)\n    {\n      // custom size of 0 is not allowed\n      return this.customSizes[index] || this.defaultItemSize;\n    },\n\n\n    /**\n     * Reset all custom sizes set with {@link #setItemSize}.\n     */\n    resetItemSizes : function()\n    {\n      this.customSizes = {};\n      this.__ranges = null;\n      this.fireNonBubblingEvent(\"change\");\n    },\n\n\n    /**\n     * Split the position range into disjunct intervals. Each interval starts\n     * with a custom sized cell. Each position is contained in exactly one range.\n     * The ranges are sorted according to their start position.\n     *\n     * Complexity: O(n log n) (n = number of custom sized cells)\n     *\n     * @return {Map[]} The sorted list of ranges.\n     */\n    __getRanges : function()\n    {\n      if (this.__ranges) {\n        return this.__ranges;\n      }\n\n      var defaultSize = this.defaultItemSize;\n      var itemCount = this.itemCount;\n\n      var indexes = [];\n      for (var key in this.customSizes)\n      {\n        var index = parseInt(key, 10);\n        if (index < itemCount) {\n          indexes.push(index);\n        }\n      }\n      if (indexes.length == 0)\n      {\n        var ranges = [{\n          startIndex: 0,\n          endIndex: itemCount - 1,\n          firstItemSize: defaultSize,\n          rangeStart: 0,\n          rangeEnd: itemCount * defaultSize - 1\n        }];\n        this.__ranges = ranges;\n        return ranges;\n      }\n\n      indexes.sort(function(a,b) { return a > b ? 1 : -1;});\n\n      var ranges = [];\n      var correctionSum = 0;\n\n      for (var i=0; i<indexes.length; i++)\n      {\n        var index = indexes[i];\n        if (index >= itemCount) {\n          break;\n        }\n\n        var cellSize = this.customSizes[index];\n        var rangeStart = index * defaultSize + correctionSum;\n\n        correctionSum += cellSize - defaultSize;\n\n        ranges[i] = {\n          startIndex: index,\n          firstItemSize: cellSize,\n          rangeStart: rangeStart\n        };\n        if (i > 0) {\n          ranges[i-1].rangeEnd = rangeStart-1;\n          ranges[i-1].endIndex = index-1;\n        }\n      }\n\n      // fix first range\n      if (ranges[0].rangeStart > 0)\n      {\n        ranges.unshift({\n          startIndex: 0,\n          endIndex: ranges[0].startIndex-1,\n          firstItemSize: defaultSize,\n          rangeStart: 0,\n          rangeEnd: ranges[0].rangeStart-1\n        });\n      }\n\n      // fix last range\n      var lastRange = ranges[ranges.length-1];\n      var remainingItemsSize = (itemCount - lastRange.startIndex - 1) * defaultSize;\n      lastRange.rangeEnd = lastRange.rangeStart + lastRange.firstItemSize + remainingItemsSize - 1;\n      lastRange.endIndex = itemCount - 1;\n\n      this.__ranges = ranges;\n      return ranges;\n    },\n\n\n    /**\n     * Returns the range, which contains the position\n     *\n     * Complexity: O(log n) (n = number of custom sized cells)\n     *\n     * @param position {Integer} The position.\n     * @return {Map} The range, which contains the given position.\n     */\n    __findRangeByPosition : function(position)\n    {\n      var ranges = this.__ranges || this.__getRanges();\n\n      var start = 0;\n      var end = ranges.length-1;\n\n      // binary search in the sorted ranges list\n      while (true)\n      {\n        var pivot = start + ((end - start) >> 1);\n        var range = ranges[pivot];\n\n        if (range.rangeEnd < position) {\n          start = pivot + 1;\n        } else if (range.rangeStart > position) {\n          end = pivot - 1;\n        } else {\n          return range;\n        }\n      }\n    },\n\n\n    /**\n     * Get the item and the offset into the item at the given position.\n     *\n     * @param position {Integer|null} The position to get the item for.\n     * @return {Map} A map with the keys <code>index</code> and\n     *    <code>offset</code>. The index is the index of the item containing the\n     *    position and offsets specifies offset into this item. If the position\n     *    is outside of the range, <code>null</code> is returned.\n     */\n    getItemAtPosition : function(position)\n    {\n      if (position < 0 || position >= this.getTotalSize()) {\n        return null;\n      }\n\n      var range = this.__findRangeByPosition(position);\n\n      var startPos = range.rangeStart;\n      var index = range.startIndex;\n      var firstItemSize = range.firstItemSize;\n\n      if (startPos + firstItemSize > position)\n      {\n        return {\n          index: index,\n          offset: position - startPos\n        };\n      }\n      else\n      {\n        var defaultSize = this.defaultItemSize;\n        return {\n          index: index + 1 + Math.floor((position - startPos - firstItemSize) / defaultSize),\n          offset: (position - startPos - firstItemSize) % defaultSize\n        };\n      }\n    },\n\n\n    /**\n     * Returns the range, which contains the position.\n     *\n     * Complexity: O(log n) (n = number of custom sized cells)\n     *\n     * @param index {Integer} The index of the item to get the range for.\n     * @return {Map} The range for the index.\n     */\n    __findRangeByIndex : function(index)\n    {\n      var ranges = this.__ranges || this.__getRanges();\n\n      var start = 0;\n      var end = ranges.length-1;\n\n      // binary search in the sorted ranges list\n      while (true)\n      {\n        var pivot = start + ((end - start) >> 1);\n        var range = ranges[pivot];\n\n        if (range.endIndex < index) {\n          start = pivot + 1;\n        } else if (range.startIndex > index) {\n          end = pivot - 1;\n        } else {\n          return range;\n        }\n      }\n    },\n\n\n    /**\n     * Get the start position of the item with the given index.\n     *\n     * @param index {Integer} The item's index.\n     * @return {Integer|null} The start position of the item. If the index is outside\n     *    of the axis range <code>null</code> is returned.\n     */\n    getItemPosition : function(index)\n    {\n      if (index < 0 || index >= this.itemCount) {\n        return null;\n      }\n\n      var range = this.__findRangeByIndex(index);\n      if (range.startIndex == index) {\n        return range.rangeStart;\n      } else {\n        return range.rangeStart + range.firstItemSize + (index-range.startIndex-1) * this.defaultItemSize;\n      }\n    },\n\n\n    /**\n     * Returns the sum of all cell sizes.\n     *\n     * @return {Integer} The sum of all item sizes.\n     */\n    getTotalSize : function()\n    {\n      var ranges = this.__ranges || this.__getRanges();\n      return ranges[ranges.length-1].rangeEnd + 1;\n    },\n\n\n    /**\n     * Get an array of item sizes starting with the item at \"startIndex\". The\n     * sum of all sizes in the returned array is at least \"minSizeSum\".\n     *\n     * @param startIndex {Integer} The index of the first item.\n     * @param minSizeSum {Integer} The minimum sum of the item sizes.\n     * @return {Integer[]} List of item sizes starting with the size of the item\n     *    at index <code>startIndex</code>. The sum of the item sizes is at least\n     *    <code>minSizeSum</code>.\n     */\n    getItemSizes : function(startIndex, minSizeSum)\n    {\n      var customSizes = this.customSizes;\n      var defaultSize = this.defaultItemSize;\n\n      var sum = 0;\n      var sizes = [];\n      var i=0;\n      while (sum < minSizeSum)\n      {\n        var itemSize = customSizes[startIndex] != null ? customSizes[startIndex] : defaultSize;\n        startIndex++;\n\n        sum += itemSize;\n        sizes[i++] = itemSize;\n        if (startIndex >= this.itemCount) {\n          break;\n        }\n      }\n      return sizes;\n    }\n  },\n\n\n  destruct : function() {\n    this.customSizes = this.__ranges = null;\n  }\n});\n"
  ]
}