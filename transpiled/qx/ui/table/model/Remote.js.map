{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/table/model/Remote.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "type",
    "extend",
    "ui",
    "table",
    "model",
    "Abstract",
    "construct",
    "_sortColumnIndex",
    "_sortAscending",
    "_rowCount",
    "_lruCounter",
    "_firstLoadingBlock",
    "_firstRowToLoad",
    "_lastRowToLoad",
    "_ignoreCurrentRequest",
    "_rowBlockCache",
    "_rowBlockCount",
    "_sortableColArr",
    "_editableColArr",
    "properties",
    "blockSize",
    "check",
    "init",
    "maxCachedBlockCount",
    "clearCacheOnRemove",
    "blockConcurrentLoadRowCount",
    "members",
    "_loadRowCountRequestRunning",
    "_clearCache",
    "_getIgnoreCurrentRequest",
    "getRowCount",
    "getBlockConcurrentLoadRowCount",
    "_loadRowCount",
    "Error",
    "_onRowCountLoaded",
    "rowCount",
    "Number",
    "data",
    "firstRow",
    "lastRow",
    "firstColumn",
    "lastColumn",
    "getColumnCount",
    "fireDataEvent",
    "reloadData",
    "cancelingSucceed",
    "_cancelCurrentRequest",
    "clearCache",
    "getCacheContent",
    "sortColumnIndex",
    "sortAscending",
    "lruCounter",
    "rowBlockCache",
    "rowBlockCount",
    "restoreCacheContent",
    "cacheContent",
    "iterateCachedRows",
    "iterator",
    "object",
    "getBlockSize",
    "blockCount",
    "Math",
    "ceil",
    "block",
    "blockData",
    "rowOffset",
    "rowDataArr",
    "relRow",
    "length",
    "rowData",
    "newRowData",
    "call",
    "prefetchRows",
    "firstRowIndex",
    "lastRowIndex",
    "totalBlockCount",
    "firstBlock",
    "parseInt",
    "lastBlock",
    "firstBlockToLoad",
    "lastBlockToLoad",
    "isDirty",
    "_loadRowData",
    "_onRowDataLoaded",
    "_setRowBlockData",
    "i",
    "blockRowData",
    "mailCount",
    "min",
    "row",
    "push",
    "getMaxCachedBlockCount",
    "lruBlock",
    "minLru",
    "currBlock",
    "currLru",
    "lru",
    "removeRow",
    "rowIndex",
    "getClearCacheOnRemove",
    "startBlock",
    "removeIndex",
    "splice",
    "nextBlockData",
    "hasListener",
    "getRowData",
    "getValue",
    "columnIndex",
    "columnId",
    "getColumnId",
    "setValue",
    "value",
    "setEditable",
    "editable",
    "col",
    "fireEvent",
    "setColumnEditable",
    "isColumnEditable",
    "setColumnSortable",
    "sortable",
    "isColumnSortable",
    "sortByColumn",
    "ascending",
    "getSortColumnIndex",
    "isSortAscending",
    "setSortColumnIndexWithoutSortingData",
    "setSortAscendingWithoutSortingData",
    "destruct",
    "Remote"
  ],
  "mappings": "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",
  "file": "Remote.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Til Schneider (til132)\n\n************************************************************************ */\n\n/**\n * A table model that loads its data from a backend.\n * <p>\n * Only a subset of the available rows, those which are within or near the\n * currently visible area, are loaded. If a quick scroll operation occurs,\n * rows will soon be displayed using asynchronous loading in the background.\n * All loaded data is managed through a cache which automatically removes\n * the oldest used rows when it gets full.\n * <p>\n * This class is abstract: The actual loading of row data must be done by\n * subclasses.\n */\nqx.Class.define(\"qx.ui.table.model.Remote\",\n{\n  type : \"abstract\",\n  extend : qx.ui.table.model.Abstract,\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct : function()\n  {\n    this.base(arguments);\n\n    this._sortColumnIndex = -1;\n    this._sortAscending = true;\n    this._rowCount = -1;\n\n    this._lruCounter = 0;\n\n    // Holds the index of the first block that is currently loading.\n    // Is -1 if there is currently no request on its way.\n    this._firstLoadingBlock = -1;\n\n    // Holds the index of the first row that should be loaded when the response of\n    // the current request arrives. Is -1 we need no following request.\n    this._firstRowToLoad = -1;\n\n    // Counterpart to _firstRowToLoad\n    this._lastRowToLoad = -1;\n\n    // Holds whether the current request will bring obsolete data. When true the\n    // response of the current request will be ignored.\n    this._ignoreCurrentRequest = false;\n\n    this._rowBlockCache = {};\n    this._rowBlockCount = 0;\n\n    this._sortableColArr = null;\n    this._editableColArr = null;\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n\n    /** The number of rows that are stored in one cache block. */\n    blockSize :\n    {\n      check : \"Integer\",\n      init : 50\n    },\n\n    /** The maximum number of row blocks kept in the cache. */\n    maxCachedBlockCount :\n    {\n      check : \"Integer\",\n      init : 15\n    },\n\n\n    /**\n     * Whether to clear the cache when some rows are removed.\n     * If true the rows are removed locally in the cache.\n     */\n    clearCacheOnRemove :\n    {\n      check : \"Boolean\",\n      init : false\n    },\n\n    /**\n     * Whether to block remote requests for the row count while a request for\n     * the row count is pending. Row counts are requested at various times and\n     * from various parts of the code, resulting in numerous requests to the\n     * user-provided _loadRowCount() method, often while other requests are\n     * already pending. The default behavior now ignores requests to load a\n     * new row count if such a request is already pending. It is therefore now\n     * conceivable that the row count changes between an initial request for\n     * the row count and a later (ignored) request. Since the chance of this\n     * is low, the desirability of reducing the server requests outweighs the\n     * slight possibility of an altered count (which will, by the way, be\n     * detected soon thereafter upon the next request for the row count). If\n     * the old behavior is desired, set this property to false.\n     */\n    blockConcurrentLoadRowCount:\n    {\n      check : \"Boolean\",\n      init  : true\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    _rowCount : null,\n    _ignoreCurrentRequest : null,\n\n    _lruCounter : null,\n    _firstLoadingBlock : null,\n    _firstRowToLoad : null,\n    _lastRowToLoad : null,\n    _rowBlockCache : null,\n    _rowBlockCount : null,\n\n    _sortColumnIndex : null,\n    _sortAscending : null,\n\n    _editableColArr : null,\n    _sortableColArr : null,\n\n    _loadRowCountRequestRunning : false,\n\n    _clearCache : false,\n\n\n    /**\n     * Returns whether the current request is ignored by the model.\n     *\n     * @return {Boolean} true when the current request is ignored by the model.\n     */\n    _getIgnoreCurrentRequest : function()\n    {\n      return this._ignoreCurrentRequest;\n    },\n\n\n    // overridden\n    getRowCount : function()\n    {\n      if (this._rowCount == -1)\n      {\n        if (! this._loadRowCountRequestRunning ||\n            ! this.getBlockConcurrentLoadRowCount())\n        {\n          this._loadRowCountRequestRunning = true;\n          this._loadRowCount();\n        }\n\n        // NOTE: _loadRowCount may set this._rowCount\n        return (this._rowCount == -1) ? 0 : this._rowCount;\n      }\n      else\n      {\n        return this._rowCount;\n      }\n    },\n\n\n    /**\n     * Implementing classes have to call {@link #_onRowCountLoaded} when the\n     * server response arrived. That method has to be called! Even when there\n     * was an error.\n     *\n     * @abstract\n     * @throws {Error} the abstract function warning.\n     */\n    _loadRowCount : function() {\n      throw new Error(\"_loadRowCount is abstract\");\n    },\n\n\n    /**\n     * Sets the row count.\n     *\n     * Has to be called by {@link #_loadRowCount}.\n     *\n     * @param rowCount {Integer} the number of rows in this model or null if loading.\n     */\n    _onRowCountLoaded : function(rowCount)\n    {\n      if (this.getBlockConcurrentLoadRowCount())\n      {\n        // There's no longer a loadRowCount() in progress\n        this._loadRowCountRequestRunning = false;\n      }\n\n      // this.debug(\"row count loaded: \" + rowCount);\n      if (rowCount == null || rowCount < 0) {\n        rowCount = 0;\n      }\n\n      this._rowCount = Number(rowCount);\n\n      // Inform the listeners\n      var data =\n      {\n        firstRow    : 0,\n        lastRow     : rowCount - 1,\n        firstColumn : 0,\n        lastColumn  : this.getColumnCount() - 1\n      };\n\n      this.fireDataEvent(\"dataChanged\", data);\n    },\n\n\n    /**\n     * Reloads the model and clears the local cache.\n     *\n     */\n    reloadData : function()\n    {\n      // If there is currently a request on its way, then this request will bring\n      // obsolete data -> Ignore it\n      if (this._firstLoadingBlock != -1) {\n        var cancelingSucceed = this._cancelCurrentRequest();\n        if (cancelingSucceed) {\n          // The request was canceled -> We're not loading any blocks any more\n          this._firstLoadingBlock = -1;\n          this._ignoreCurrentRequest = false;\n        } else {\n          // The request was not canceled -> Ignore it\n          this._ignoreCurrentRequest = true;\n        }\n      }\n\n      // Force clearing row cache, because of reloading data.\n      this._clearCache = true;\n\n      // Forget a possibly outstanding request\n      // (_loadRowCount will tell the listeners anyway, that the whole table\n      // changed)\n      //\n      // NOTE: This will inform the listeners as soon as the new row count is\n      // known\n      this._firstRowToLoad = -1;\n      this._lastRowToLoad = -1;\n      this._loadRowCountRequestRunning = true;\n      this._loadRowCount();\n    },\n\n\n    /**\n     * Clears the cache.\n     *\n     */\n    clearCache : function()\n    {\n      this._rowBlockCache = {};\n      this._rowBlockCount = 0;\n    },\n\n\n    /**\n     * Returns the current state of the cache.\n     * <p>\n     * Do not change anything in the returned data. This breaks the model state.\n     * Use this method only together with {@link #restoreCacheContent} for backing\n     * up state for a later restore.\n     *\n     * @return {Map} the current cache state.\n     */\n    getCacheContent : function() {\n      return {\n        sortColumnIndex : this._sortColumnIndex,\n        sortAscending   : this._sortAscending,\n        rowCount        : this._rowCount,\n        lruCounter      : this._lruCounter,\n        rowBlockCache   : this._rowBlockCache,\n        rowBlockCount   : this._rowBlockCount\n      };\n    },\n\n\n    /**\n     * Restores a cache state created by {@link #getCacheContent}.\n     *\n     * @param cacheContent {Map} An old cache state.\n     */\n    restoreCacheContent : function(cacheContent)\n    {\n      // If there is currently a request on its way, then this request will bring\n      // obsolete data -> Ignore it\n      if (this._firstLoadingBlock != -1)\n      {\n        // Try to cancel the current request\n        var cancelingSucceed = this._cancelCurrentRequest();\n\n        if (cancelingSucceed)\n        {\n          // The request was canceled -> We're not loading any blocks any more\n          this._firstLoadingBlock = -1;\n          this._ignoreCurrentRequest = false;\n        }\n        else\n        {\n          // The request was not canceled -> Ignore it\n          this._ignoreCurrentRequest = true;\n        }\n      }\n\n      // Restore the cache content\n      this._sortColumnIndex = cacheContent.sortColumnIndex;\n      this._sortAscending = cacheContent.sortAscending;\n      this._rowCount = cacheContent.rowCount;\n      this._lruCounter = cacheContent.lruCounter;\n      this._rowBlockCache = cacheContent.rowBlockCache;\n      this._rowBlockCount = cacheContent.rowBlockCount;\n\n      // Inform the listeners\n      var data =\n      {\n        firstRow    : 0,\n        lastRow     : this._rowCount - 1,\n        firstColumn : 0,\n        lastColumn  : this.getColumnCount() - 1\n      };\n\n      this.fireDataEvent(\"dataChanged\", data);\n    },\n\n\n    /**\n     * Cancels the current request if possible.\n     *\n     * Should be overridden by subclasses if they are able to cancel requests. This\n     * allows sending a new request directly after a call of {@link #reloadData}.\n     *\n     * @return {Boolean} whether the request was canceled.\n     */\n    _cancelCurrentRequest : function() {\n      return false;\n    },\n\n\n    /**\n     * Iterates through all cached rows.\n     *\n     * The iterator will be called for each cached row with two parameters: The row\n     * index of the current row (Integer) and the row data of that row (var[]). If\n     * the iterator returns something this will be used as new row data.\n     *\n     * The iterator is called in the same order as the rows are in the model\n     * (the row index is always ascending).\n     *\n     * @param iterator {Function} The iterator function to call.\n     * @param object {Object} context of the iterator\n     */\n    iterateCachedRows : function(iterator, object)\n    {\n      var blockSize = this.getBlockSize();\n      var blockCount = Math.ceil(this.getRowCount() / blockSize);\n\n      // Remove the row and move the rows of all following blocks\n      for (var block=0; block<=blockCount; block++)\n      {\n        var blockData = this._rowBlockCache[block];\n\n        if (blockData != null)\n        {\n          var rowOffset = block * blockSize;\n          var rowDataArr = blockData.rowDataArr;\n\n          for (var relRow=0; relRow<rowDataArr.length; relRow++)\n          {\n            // Call the iterator for this row\n            var rowData = rowDataArr[relRow];\n            var newRowData = iterator.call(object, rowOffset + relRow, rowData);\n\n            if (newRowData != null) {\n              rowDataArr[relRow] = newRowData;\n            }\n          }\n        }\n      }\n    },\n\n    // overridden\n    prefetchRows : function(firstRowIndex, lastRowIndex)\n    {\n      // this.debug(\"Prefetch wanted: \" + firstRowIndex + \"..\" + lastRowIndex);\n      if (this._firstLoadingBlock == -1)\n      {\n        var blockSize = this.getBlockSize();\n        var totalBlockCount = Math.ceil(this._rowCount / blockSize);\n\n        // There is currently no request running -> Start a new one\n        // NOTE: We load one more block above and below to have a smooth\n        //       scrolling into the next block without blank cells\n        var firstBlock = parseInt(firstRowIndex / blockSize, 10) - 1;\n\n        if (firstBlock < 0) {\n          firstBlock = 0;\n        }\n\n        var lastBlock = parseInt(lastRowIndex / blockSize, 10) + 1;\n\n        if (lastBlock >= totalBlockCount) {\n          lastBlock = totalBlockCount - 1;\n        }\n\n        // Check which blocks we have to load\n        var firstBlockToLoad = -1;\n        var lastBlockToLoad = -1;\n\n        for (var block=firstBlock; block<=lastBlock; block++)\n        {\n          if ((this._clearCache && !this._loadRowCountRequestRunning)|| this._rowBlockCache[block] == null || this._rowBlockCache[block].isDirty)\n          {\n            // We don't have this block\n            if (firstBlockToLoad == -1) {\n              firstBlockToLoad = block;\n            }\n\n            lastBlockToLoad = block;\n          }\n        }\n\n        // Load the blocks\n        if (firstBlockToLoad != -1)\n        {\n          this._firstRowToLoad = -1;\n          this._lastRowToLoad = -1;\n\n          this._firstLoadingBlock = firstBlockToLoad;\n\n          // this.debug(\"Starting server request. rows: \" + firstRowIndex + \"..\" + lastRowIndex + \", blocks: \" + firstBlockToLoad + \"..\" + lastBlockToLoad);\n          this._loadRowData(firstBlockToLoad * blockSize, (lastBlockToLoad + 1) * blockSize - 1);\n        }\n      }\n      else\n      {\n        // There is already a request running -> Remember this request\n        // so it can be executed after the current one is finished.\n        this._firstRowToLoad = firstRowIndex;\n        this._lastRowToLoad = lastRowIndex;\n      }\n    },\n\n\n    /**\n     * Loads some row data from the server.\n     *\n     * Implementing classes have to call {@link #_onRowDataLoaded} when the server\n     * response arrived. That method has to be called! Even when there was an error.\n     *\n     * @abstract\n     * @param firstRow {Integer} The index of the first row to load.\n     * @param lastRow {Integer} The index of the last row to load.\n     * @throws {Error} the abstract function warning.\n     */\n    _loadRowData : function(firstRow, lastRow) {\n      throw new Error(\"_loadRowData is abstract\");\n    },\n\n\n    /**\n     * Sets row data.\n     *\n     * Has to be called by {@link #_loadRowData}.\n     *\n     * @param rowDataArr {Map[]} the loaded row data or null if there was an error.\n     */\n    _onRowDataLoaded : function(rowDataArr)\n    {\n      // Clear cache if function was called because of a reload.\n      if (this._clearCache) {\n        this.clearCache();\n        this._clearCache = false;\n      }\n\n      if (rowDataArr != null && !this._ignoreCurrentRequest)\n      {\n        var blockSize = this.getBlockSize();\n        var blockCount = Math.ceil(rowDataArr.length / blockSize);\n\n        if (blockCount == 1)\n        {\n          // We got one block -> Use the rowData directly\n          this._setRowBlockData(this._firstLoadingBlock, rowDataArr);\n        }\n        else\n        {\n          // We got more than one block -> We've to split the rowData\n          for (var i=0; i<blockCount; i++)\n          {\n            var rowOffset = i * blockSize;\n            var blockRowData = [];\n            var mailCount = Math.min(blockSize, rowDataArr.length - rowOffset);\n\n            for (var row=0; row<mailCount; row++) {\n              blockRowData.push(rowDataArr[rowOffset + row]);\n            }\n\n            this._setRowBlockData(this._firstLoadingBlock + i, blockRowData);\n          }\n        }\n\n        // this.debug(\"Got server answer. blocks: \" + this._firstLoadingBlock + \"..\" + (this._firstLoadingBlock + blockCount - 1) + \". mail count: \" + rowDataArr.length + \" block count:\" + blockCount);\n        // Inform the listeners\n        var data =\n        {\n          firstRow    : this._firstLoadingBlock * blockSize,\n          lastRow     : (this._firstLoadingBlock + blockCount + 1) * blockSize - 1,\n          firstColumn : 0,\n          lastColumn  : this.getColumnCount() - 1\n        };\n\n        this.fireDataEvent(\"dataChanged\", data);\n      }\n\n      // We're not loading any blocks any more\n      this._firstLoadingBlock = -1;\n      this._ignoreCurrentRequest = false;\n\n      // Check whether we have to start a new request\n      if (this._firstRowToLoad != -1) {\n        this.prefetchRows(this._firstRowToLoad, this._lastRowToLoad);\n      }\n    },\n\n\n    /**\n     * Sets the data of one block.\n     *\n     * @param block {Integer} the index of the block.\n     * @param rowDataArr {var[][]} the data to set.\n     */\n    _setRowBlockData : function(block, rowDataArr)\n    {\n      if (this._rowBlockCache[block] == null)\n      {\n\n        // This is a new block -> Check whether we have to remove another block first\n        this._rowBlockCount++;\n\n        while (this._rowBlockCount > this.getMaxCachedBlockCount())\n        {\n          // Find the last recently used block\n          // NOTE: We never remove block 0 and 1\n          var lruBlock;\n          var minLru = this._lruCounter;\n\n          for (var currBlock in this._rowBlockCache)\n          {\n            var currLru = this._rowBlockCache[currBlock].lru;\n\n            if (currLru < minLru && currBlock > 1)\n            {\n              minLru = currLru;\n              lruBlock = currBlock;\n            }\n          }\n\n          // Remove that block\n          // this.debug(\"Removing block: \" + lruBlock + \". current LRU: \" + this._lruCounter);\n          delete this._rowBlockCache[lruBlock];\n          this._rowBlockCount--;\n        }\n      }\n\n      this._rowBlockCache[block] =\n      {\n        lru        : ++this._lruCounter,\n        rowDataArr : rowDataArr\n      };\n    },\n\n\n    /**\n     * Removes a row from the model.\n     *\n     * @param rowIndex {Integer} the index of the row to remove.\n     */\n    removeRow : function(rowIndex)\n    {\n      if (this.getClearCacheOnRemove())\n      {\n        this.clearCache();\n\n        // Inform the listeners\n        var data =\n        {\n          firstRow    : 0,\n          lastRow     : this.getRowCount() - 1,\n          firstColumn : 0,\n          lastColumn  : this.getColumnCount() - 1\n        };\n\n        this.fireDataEvent(\"dataChanged\", data);\n      }\n      else\n      {\n        var blockSize = this.getBlockSize();\n        var blockCount = Math.ceil(this.getRowCount() / blockSize);\n        var startBlock = parseInt(rowIndex / blockSize, 10);\n\n        // Remove the row and move the rows of all following blocks\n        for (var block=startBlock; block<=blockCount; block++)\n        {\n          var blockData = this._rowBlockCache[block];\n\n          if (blockData != null)\n          {\n            // Remove the row in the start block\n            // NOTE: In the other blocks the first row is removed\n            //       (This is the row that was)\n            var removeIndex = 0;\n\n            if (block == startBlock) {\n              removeIndex = rowIndex - block * blockSize;\n            }\n\n            blockData.rowDataArr.splice(removeIndex, 1);\n\n            if (block == blockCount - 1)\n            {\n              // This is the last block\n              if (blockData.rowDataArr.length == 0)\n              {\n                // It is empty now -> Remove it\n                delete this._rowBlockCache[block];\n              }\n            }\n            else\n            {\n              // Try to copy the first row of the next block to the end of this block\n              // so this block can stays clean\n              var nextBlockData = this._rowBlockCache[block + 1];\n\n              if (nextBlockData != null) {\n                blockData.rowDataArr.push(nextBlockData.rowDataArr[0]);\n              }\n              else\n              {\n                // There is no row to move -> Mark this block as dirty\n                blockData.isDirty = true;\n              }\n            }\n          }\n        }\n\n        if (this._rowCount != -1) {\n          this._rowCount--;\n        }\n\n        // Inform the listeners\n        if (this.hasListener(\"dataChanged\"))\n        {\n          var data =\n          {\n            firstRow    : rowIndex,\n            lastRow     : this.getRowCount() - 1,\n            firstColumn : 0,\n            lastColumn  : this.getColumnCount() - 1\n          };\n\n          this.fireDataEvent(\"dataChanged\", data);\n        }\n      }\n    },\n\n\n    /**\n     *\n     * See overridden method for details.\n     *\n     * @param rowIndex {Integer} the model index of the row.\n     * @return {Object} Map containing a value for each column.\n     */\n    getRowData : function(rowIndex)\n    {\n      var blockSize = this.getBlockSize();\n      var block = parseInt(rowIndex / blockSize, 10);\n      var blockData = this._rowBlockCache[block];\n\n      if (blockData == null)\n      {\n        // This block is not (yet) loaded\n        return null;\n      }\n      else\n      {\n        var rowData = blockData.rowDataArr[rowIndex - (block * blockSize)];\n\n        // Update the last recently used counter\n        if (blockData.lru != this._lruCounter) {\n          blockData.lru = ++this._lruCounter;\n        }\n\n        return rowData;\n      }\n    },\n\n    // overridden\n    getValue : function(columnIndex, rowIndex)\n    {\n      var rowData = this.getRowData(rowIndex);\n\n      if (rowData == null) {\n        return null;\n      }\n      else\n      {\n        var columnId = this.getColumnId(columnIndex);\n        return rowData[columnId];\n      }\n    },\n\n    // overridden\n    setValue : function(columnIndex, rowIndex, value)\n    {\n      var rowData = this.getRowData(rowIndex);\n\n      if (rowData == null) {\n        // row has not yet been loaded or does not exist\n        return;\n      }\n      else\n      {\n        var columnId = this.getColumnId(columnIndex);\n        rowData[columnId] = value;\n\n        // Inform the listeners\n        if (this.hasListener(\"dataChanged\"))\n        {\n          var data =\n          {\n            firstRow    : rowIndex,\n            lastRow     : rowIndex,\n            firstColumn : columnIndex,\n            lastColumn  : columnIndex\n          };\n\n          this.fireDataEvent(\"dataChanged\", data);\n        }\n      }\n    },\n\n\n    /**\n     * Sets all columns editable or not editable.\n     *\n     * @param editable {Boolean} whether all columns are editable.\n     */\n    setEditable : function(editable)\n    {\n      this._editableColArr = [];\n\n      for (var col=0; col<this.getColumnCount(); col++) {\n        this._editableColArr[col] = editable;\n      }\n\n      this.fireEvent(\"metaDataChanged\");\n    },\n\n\n    /**\n     * Sets whether a column is editable.\n     *\n     * @param columnIndex {Integer} the column of which to set the editable state.\n     * @param editable {Boolean} whether the column should be editable.\n     */\n    setColumnEditable : function(columnIndex, editable)\n    {\n      if (editable != this.isColumnEditable(columnIndex))\n      {\n        if (this._editableColArr == null) {\n          this._editableColArr = [];\n        }\n\n        this._editableColArr[columnIndex] = editable;\n\n        this.fireEvent(\"metaDataChanged\");\n      }\n    },\n\n    // overridden\n    isColumnEditable : function(columnIndex)\n    {\n      return (this._editableColArr\n              ? (this._editableColArr[columnIndex] == true)\n              : false);\n    },\n\n   /**\n     * Sets whether a column is sortable.\n     *\n     * @param columnIndex {Integer} the column of which to set the sortable state.\n     * @param sortable {Boolean} whether the column should be sortable.\n     */\n    setColumnSortable : function(columnIndex, sortable)\n    {\n      if (sortable != this.isColumnSortable(columnIndex))\n      {\n        if (this._sortableColArr == null) {\n          this._sortableColArr = [];\n        }\n\n        this._sortableColArr[columnIndex] = sortable;\n\n        this.fireEvent(\"metaDataChanged\");\n      }\n    },\n\n    // overridden\n    isColumnSortable : function(columnIndex)\n    {\n      return (\n        this._sortableColArr\n        ? (this._sortableColArr[columnIndex] !== false)\n        : true\n      );\n    },\n\n    // overridden\n    sortByColumn : function(columnIndex, ascending)\n    {\n      if (this._sortColumnIndex != columnIndex || this._sortAscending != ascending)\n      {\n        this._sortColumnIndex = columnIndex;\n        this._sortAscending = ascending;\n\n        this.clearCache();\n\n        // Inform the listeners\n        this.fireEvent(\"metaDataChanged\");\n      }\n    },\n\n    // overridden\n    getSortColumnIndex : function() {\n      return this._sortColumnIndex;\n    },\n\n    // overridden\n    isSortAscending : function() {\n      return this._sortAscending;\n    },\n\n    /**\n     * Sets the sorted column without sorting the data.\n     * Use this method, if you want to mark the column as the sorted column,\n     * (e.g. for appearance reason), but the sorting of the data will be done\n     * in another step.\n     *\n     * @param sortColumnIndex {Integer} the column, which shall be marked as the sorted column.\n     */\n    setSortColumnIndexWithoutSortingData : function(sortColumnIndex)\n    {\n      this._sortColumnIndex = sortColumnIndex;\n    },\n\n    /**\n     * Sets the direction of the sorting without sorting the data.\n     * Use this method, if you want to set the direction of sorting, (e.g\n     * for appearance reason), but the sorting of the data will be done in\n     * another step.\n     *\n     * @param sortAscending {Boolean} whether the sorting direction is ascending\n     *        (true) or not (false).\n     */\n    setSortAscendingWithoutSortingData : function (sortAscending)\n    {\n      this._sortAscending = sortAscending;\n    }\n\n  },\n\n  destruct : function() {\n    this._sortableColArr = this._editableColArr = this._rowBlockCache = null;\n  }\n});\n"
  ]
}