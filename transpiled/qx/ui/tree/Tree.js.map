{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/tree/Tree.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "core",
    "scroll",
    "AbstractScrollArea",
    "implement",
    "IMultiSelection",
    "form",
    "IModelSelection",
    "IField",
    "IForm",
    "include",
    "MMultiSelectionHandling",
    "MContentPadding",
    "MModelSelection",
    "MForm",
    "construct",
    "__content",
    "container",
    "Composite",
    "layout",
    "VBox",
    "set",
    "allowShrinkY",
    "allowGrowX",
    "getChildControl",
    "add",
    "initOpenMode",
    "initRootOpenClose",
    "addListener",
    "_onChangeSelection",
    "_onKeyPress",
    "events",
    "addItem",
    "removeItem",
    "properties",
    "openMode",
    "check",
    "init",
    "apply",
    "event",
    "themeable",
    "root",
    "nullable",
    "hideRoot",
    "rootOpenClose",
    "appearance",
    "refine",
    "focusable",
    "members",
    "SELECTION_MANAGER",
    "tree",
    "selection",
    "SelectionManager",
    "getChildrenContainer",
    "_applyRoot",
    "value",
    "old",
    "isDisposed",
    "remove",
    "hasChildren",
    "setVisibility",
    "getHideRoot",
    "recursiveAddToWidgetQueue",
    "_applyHideRoot",
    "getRoot",
    "_applyRootOpenClose",
    "_getContentPaddingTarget",
    "getNextNodeOf",
    "treeItem",
    "invisible",
    "isOpen",
    "getChildren",
    "parent",
    "getParent",
    "parentChildren",
    "index",
    "indexOf",
    "length",
    "getPreviousNodeOf",
    "folder",
    "children",
    "getNextSiblingOf",
    "siblings",
    "getPreviousSiblingOf",
    "getItems",
    "recursive",
    "getTreeItem",
    "widget",
    "AbstractTreeItem",
    "getLayoutParent",
    "_applyOpenMode",
    "removeListener",
    "_onOpen",
    "e",
    "getTarget",
    "isOpenable",
    "setOpen",
    "stopPropagation",
    "getData",
    "i",
    "item",
    "_getLeadItem",
    "getKeyIdentifier",
    "setSelection",
    "toggleOpen",
    "destruct",
    "_disposeObjects",
    "Tree"
  ],
  "mappings": "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",
  "file": "Tree.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n     * Sebastian Werner (wpbasti)\n     * Andreas Ecker (ecker)\n     * Derrell Lipman (derrell)\n     * Christian Hagendorn (chris_schmidt)\n     * Daniel Wagner (d_wagner)\n\n************************************************************************ */\n\n/**\n * The Tree class implements a tree widget, with collapsible and expandable\n * container nodes and terminal leaf nodes. You instantiate a Tree object and\n * then assign the tree a root folder using the {@link #root} property.\n *\n * If you don't want to show the root item, you can hide it with the\n * {@link #hideRoot} property.\n *\n * The handling of <b>selections</b> within a tree is somewhat distributed\n * between the root tree object and the attached {@link qx.ui.tree.selection.SelectionManager}.\n * To get the currently selected element of a tree use the tree {@link #getSelection}\n * method and tree {@link #setSelection} to set it. The TreeSelectionManager\n * handles more coarse-grained issues like providing {@link #selectAll} and\n * {@link #resetSelection} methods.\n */\nqx.Class.define(\"qx.ui.tree.Tree\",\n{\n  extend : qx.ui.core.scroll.AbstractScrollArea,\n  implement : [\n    qx.ui.core.IMultiSelection,\n    qx.ui.form.IModelSelection,\n    qx.ui.form.IField,\n    qx.ui.form.IForm\n  ],\n  include : [\n    qx.ui.core.MMultiSelectionHandling,\n    qx.ui.core.MContentPadding,\n    qx.ui.form.MModelSelection,\n    qx.ui.form.MForm\n  ],\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n\n  construct : function()\n  {\n    this.base(arguments);\n\n    this.__content = new qx.ui.container.Composite(new qx.ui.layout.VBox()).set({\n      allowShrinkY: false,\n      allowGrowX: true\n    });\n\n    this.getChildControl(\"pane\").add(this.__content);\n\n    this.initOpenMode();\n    this.initRootOpenClose();\n\n    this.addListener(\"changeSelection\", this._onChangeSelection, this);\n    this.addListener(\"keypress\", this._onKeyPress, this);\n  },\n\n\n  /*\n  *****************************************************************************\n     EVENTS\n  *****************************************************************************\n  */\n\n\n  events :\n  {\n    /**\n     * This event is fired after a tree item was added to the tree. The\n     * {@link qx.event.type.Data#getData} method of the event returns the\n     * added item.\n     */\n    addItem : \"qx.event.type.Data\",\n\n    /**\n     * This event is fired after a tree item has been removed from the tree.\n     * The {@link qx.event.type.Data#getData} method of the event returns the\n     * removed item.\n     */\n    removeItem : \"qx.event.type.Data\"\n  },\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n    /**\n     * Control whether tap or double tap should open or close the tapped\n     * folder.\n     */\n    openMode :\n    {\n      check : [\"tap\", \"dbltap\", \"none\"],\n      init : \"dbltap\",\n      apply : \"_applyOpenMode\",\n      event : \"changeOpenMode\",\n      themeable : true\n    },\n\n    /**\n     * The root tree item of the tree to display\n     */\n    root :\n    {\n      check : \"qx.ui.tree.core.AbstractTreeItem\",\n      init : null,\n      nullable : true,\n      event : \"changeRoot\",\n      apply : \"_applyRoot\"\n    },\n\n    /**\n     * Hide the root (Tree) node.  This differs from the visibility property in\n     * that this property hides *only* the root node, not the node's children.\n     */\n    hideRoot :\n    {\n      check : \"Boolean\",\n      init : false,\n      apply :\"_applyHideRoot\"\n    },\n\n    /**\n     * Whether the Root should have an open/close button.  This may also be\n     * used in conjunction with the hideNode property to provide for virtual root\n     * nodes.  In the latter case, be very sure that the virtual root nodes are\n     * expanded programmatically, since there will be no open/close button for the\n     * user to open them.\n     */\n    rootOpenClose :\n    {\n      check : \"Boolean\",\n      init : false,\n      apply : \"_applyRootOpenClose\"\n    },\n\n    // overridden\n    appearance :\n    {\n      refine: true,\n      init: \"tree\"\n    },\n\n    // overridden\n    focusable :\n    {\n      refine : true,\n      init : true\n    }\n  },\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    __content : null,\n\n    /** @type {Class} Pointer to the selection manager to use */\n    SELECTION_MANAGER : qx.ui.tree.selection.SelectionManager,\n\n\n    /*\n    ---------------------------------------------------------------------------\n      WIDGET API\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Get the widget, which contains the root tree item. This widget must\n     * have a vertical box layout.\n     *\n     * @return {qx.ui.core.Widget} the children container\n     */\n    getChildrenContainer : function() {\n      return this.__content;\n    },\n\n\n    // property apply\n    _applyRoot : function(value, old)\n    {\n      var container = this.getChildrenContainer();\n\n      if (old && !old.isDisposed())\n      {\n        container.remove(old);\n        if (old.hasChildren()) {\n          container.remove(old.getChildrenContainer());\n        }\n      }\n\n      if (value)\n      {\n        container.add(value);\n        if (value.hasChildren()) {\n          container.add(value.getChildrenContainer());\n        }\n\n        value.setVisibility(this.getHideRoot() ? \"excluded\" : \"visible\");\n        value.recursiveAddToWidgetQueue();\n      }\n    },\n\n\n    // property apply\n    _applyHideRoot : function(value, old)\n    {\n      var root = this.getRoot();\n      if (!root) {\n        return;\n      }\n\n      root.setVisibility(value ? \"excluded\" : \"visible\");\n      root.recursiveAddToWidgetQueue();\n    },\n\n\n    // property apply\n    _applyRootOpenClose : function(value, old)\n    {\n      var root = this.getRoot();\n      if (!root) {\n        return;\n      }\n      root.recursiveAddToWidgetQueue();\n    },\n\n\n    /**\n     * Returns the element, to which the content padding should be applied.\n     *\n     * @return {qx.ui.core.Widget} The content padding target.\n     */\n    _getContentPaddingTarget : function() {\n      return this.__content;\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      SELECTION MANAGER API\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Get the tree item following the given item in the tree hierarchy.\n     *\n     * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the item after\n     * @param invisible {Boolean?true} Whether invisible/closed tree items\n     *     should be returned as well.\n     *\n     * @return {qx.ui.tree.core.AbstractTreeItem?null} The item after the given item. May be\n     *     <code>null</code> if the item is the last item.\n     */\n    getNextNodeOf : function(treeItem, invisible)\n    {\n      if ((invisible !== false || treeItem.isOpen()) && treeItem.hasChildren()) {\n        return treeItem.getChildren()[0];\n      }\n\n      while (treeItem)\n      {\n        var parent = treeItem.getParent();\n        if (!parent) {\n          return null;\n        }\n\n\n        var parentChildren = parent.getChildren();\n        var index = parentChildren.indexOf(treeItem);\n        if (index > -1 && index < parentChildren.length-1) {\n          return parentChildren[index+1];\n        }\n\n        treeItem = parent;\n      }\n      return null;\n    },\n\n\n    /**\n     * Get the tree item preceding the given item in the tree hierarchy.\n     *\n     * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the item before\n     * @param invisible {Boolean?true} Whether invisible/closed tree items\n     *     should be returned as well.\n     *\n     * @return {qx.ui.tree.core.AbstractTreeItem?null} The item before the given item. May be\n     *     <code>null</code> if the given item is the tree's root.\n     */\n    getPreviousNodeOf : function(treeItem, invisible)\n    {\n      var parent = treeItem.getParent();\n      if (!parent) {\n        return null;\n      }\n\n      if (this.getHideRoot())\n      {\n        if (parent == this.getRoot())\n        {\n          if (parent.getChildren()[0] == treeItem) {\n            return null;\n          }\n        }\n      }\n      else\n      {\n        if (treeItem == this.getRoot()) {\n          return null;\n        }\n      }\n\n      var parentChildren = parent.getChildren();\n      var index = parentChildren.indexOf(treeItem);\n      if (index > 0)\n      {\n        var folder = parentChildren[index-1];\n        while ((invisible !== false || folder.isOpen()) && folder.hasChildren())\n        {\n          var children = folder.getChildren();\n          folder = children[children.length-1];\n        }\n        return folder;\n      }\n      else\n      {\n        return parent;\n      }\n    },\n\n\n    /**\n     * Get the tree item's next sibling.\n     *\n     * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the following\n     * sibling of.\n     *\n     * @return {qx.ui.tree.core.AbstractTreeItem?null} The item following the given item. May be\n     *     <code>null</code> if the given item is the last in it's nesting\n     *     level.\n     */\n    getNextSiblingOf : function(treeItem)\n    {\n      if (treeItem == this.getRoot()) {\n        return null;\n      }\n\n      var parent = treeItem.getParent();\n      var siblings = parent.getChildren();\n      var index = siblings.indexOf(treeItem);\n\n      if (index < siblings.length-1) {\n        return siblings[index+1];\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Get the tree item's previous sibling.\n     *\n     * @param treeItem {qx.ui.tree.core.AbstractTreeItem} The tree item to get the previous\n     * sibling of.\n     *\n     * @return {qx.ui.tree.core.AbstractTreeItem?null} The item preceding the given item. May be\n     *     <code>null</code> if the given item is the first in it's nesting\n     *     level.\n     */\n    getPreviousSiblingOf : function(treeItem)\n    {\n      if (treeItem == this.getRoot()) {\n        return null;\n      }\n\n      var parent = treeItem.getParent();\n      var siblings = parent.getChildren();\n      var index = siblings.indexOf(treeItem);\n\n      if (index > 0) {\n        return siblings[index-1];\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Returns all children of the tree.\n     *\n     * @param recursive {Boolean ? false} whether children of subfolder should be\n     *     included\n     * @param invisible {Boolean ? true} whether invisible children should be\n     *     included\n     * @return {qx.ui.tree.core.AbstractTreeItem[]} list of children\n     */\n    getItems : function(recursive, invisible) {\n      if (this.getRoot() != null) {\n        return this.getRoot().getItems(recursive, invisible, this.getHideRoot());\n      }\n      else {\n        return [];\n      }\n    },\n\n\n    /**\n     * Returns the tree's only \"external\" child, namely the root node.\n     *\n     * @return {qx.ui.tree.core.AbstractTreeItem[]} Array containing the root node\n     */\n    getChildren : function() {\n      if (this.getRoot() != null) {\n        return [this.getRoot()];\n      }\n      else {\n        return [];\n      }\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      POINTER EVENT HANDLER\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Returns the tree item, which contains the given widget.\n     *\n     * @param widget {qx.ui.core.Widget} The widget to get the containing tree\n     *   item for.\n     * @return {qx.ui.tree.core.AbstractTreeItem|null} The tree item containing the widget. If the\n     *     widget is not inside of any tree item <code>null</code> is returned.\n     */\n    getTreeItem : function(widget)\n    {\n      while (widget)\n      {\n        if (widget == this) {\n          return null;\n        }\n\n        if (widget instanceof qx.ui.tree.core.AbstractTreeItem) {\n          return widget;\n        }\n\n        widget = widget.getLayoutParent();\n      }\n\n      return null;\n    },\n\n\n    // property apply\n    _applyOpenMode : function(value, old)\n    {\n      if (old == \"tap\") {\n        this.removeListener(\"tap\", this._onOpen, this);\n      } else if (old == \"dbltap\") {\n        this.removeListener(\"dbltap\", this._onOpen, this);\n      }\n\n      if (value == \"tap\") {\n        this.addListener(\"tap\", this._onOpen, this);\n      } else if (value == \"dbltap\") {\n        this.addListener(\"dbltap\", this._onOpen, this);\n      }\n    },\n\n\n    /**\n     * Event handler for tap events, which could change a tree item's open\n     * state.\n     *\n     * @param e {qx.event.type.Pointer} The tap event object\n     */\n    _onOpen : function(e)\n    {\n      var treeItem = this.getTreeItem(e.getTarget());\n      if (!treeItem ||!treeItem.isOpenable()) {\n        return;\n      }\n\n      treeItem.setOpen(!treeItem.isOpen());\n      e.stopPropagation();\n    },\n\n\n    /**\n     * Event handler for changeSelection events, which opens all parent folders\n     * of the selected folders.\n     *\n     * @param e {qx.event.type.Data} The selection data event.\n     */\n    _onChangeSelection : function(e) {\n      var selection = e.getData();\n      // for every selected folder\n      for (var i = 0; i < selection.length; i++) {\n        var folder = selection[i];\n        // go up all parents and open them\n        while (folder.getParent() != null) {\n          folder = folder.getParent();\n          folder.setOpen(true);\n        }\n      }\n    },\n\n\n    /**\n     * Event handler for key press events. Open and close the current selected\n     * item on key left and right press. Jump to parent on key left if already\n     * closed.\n     *\n     * @param e {qx.event.type.KeySequence} key event.\n     */\n    _onKeyPress : function(e)\n    {\n      var item = this._getLeadItem();\n\n      if (item !== null)\n      {\n        switch(e.getKeyIdentifier())\n        {\n          case \"Left\":\n            if (item.isOpenable() && item.isOpen()) {\n              item.setOpen(false);\n            } else if (item.getParent()) {\n              this.setSelection([item.getParent()]);\n            }\n            break;\n\n          case \"Right\":\n            if (item.isOpenable() && !item.isOpen()) {\n              item.setOpen(true);\n            }\n            break;\n\n          case \"Enter\":\n          case \"Space\":\n            if (item.isOpenable()) {\n              item.toggleOpen();\n            }\n            break;\n        }\n      }\n    }\n  },\n\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n\n\n  destruct : function() {\n    this._disposeObjects(\"__content\");\n  }\n});\n"
  ]
}