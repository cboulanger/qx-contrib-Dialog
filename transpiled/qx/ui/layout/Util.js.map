{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/layout/Util.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "PERCENT_VALUE",
    "computeFlexOffsets",
    "flexibles",
    "avail",
    "used",
    "child",
    "key",
    "flexSum",
    "flexStep",
    "grow",
    "remaining",
    "Math",
    "abs",
    "roundingOffset",
    "currentOffset",
    "result",
    "potential",
    "max",
    "value",
    "min",
    "flex",
    "offset",
    "Infinity",
    "ceil",
    "computeHorizontalAlignOffset",
    "align",
    "width",
    "availWidth",
    "marginLeft",
    "marginRight",
    "round",
    "computeVerticalAlignOffset",
    "height",
    "availHeight",
    "marginTop",
    "marginBottom",
    "collapseMargins",
    "varargs",
    "i",
    "l",
    "arguments",
    "length",
    "computeHorizontalGaps",
    "children",
    "spacing",
    "collapse",
    "gaps",
    "getMarginLeft",
    "getMarginRight",
    "computeVerticalGaps",
    "getMarginTop",
    "getMarginBottom",
    "computeHorizontalSeparatorGaps",
    "separator",
    "instance",
    "theme",
    "manager",
    "Decoration",
    "getInstance",
    "resolve",
    "insets",
    "getInsets",
    "left",
    "right",
    "computeVerticalSeparatorGaps",
    "top",
    "bottom",
    "arrangeIdeals",
    "beginMin",
    "beginIdeal",
    "beginMax",
    "endMin",
    "endIdeal",
    "endMax",
    "begin",
    "end",
    "ui",
    "layout",
    "Util"
  ],
  "mappings": ";;;;;;;;;;AAAAA,KAAGC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC,EAwBAH,GAAGI,KAAH,CAASC,MAAT,CAAgB,mBAAhB,EACA;AACEC,aACA;AACE;AACAC,qBAAgB,sBAFlB;;AAKE;;;;;;;;;;;;;;;;;;AAkBAC,0BAAqB,4BAASC,SAAT,EAAoBC,KAApB,EAA2BC,IAA3B,EACrB;AACE,YAAIC,KAAJ,EAAWC,GAAX,EAAgBC,OAAhB,EAAyBC,QAAzB;AACA,YAAIC,OAAON,QAAQC,IAAnB;AACA,YAAIM,YAAYC,KAAKC,GAAL,CAAST,QAAQC,IAAjB,CAAhB;AACA,YAAIS,cAAJ,EAAoBC,aAApB;;AAGA;AACA,YAAIC,SAAS,EAAb;AACA,aAAKT,GAAL,IAAYJ,SAAZ,EACA;AACEG,kBAAQH,UAAUI,GAAV,CAAR;AACAS,iBAAOT,GAAP,IACA;AACEU,uBAAYP,OAAOJ,MAAMY,GAAN,GAAYZ,MAAMa,KAAzB,GAAiCb,MAAMa,KAAN,GAAcb,MAAMc,GADnE;AAEEC,kBAAOX,OAAOJ,MAAMe,IAAb,GAAoB,IAAIf,MAAMe,IAFvC;AAGEC,oBAAS;AAHX,WADA;AAMD;;AAGD;AACA,eAAOX,aAAa,CAApB,EACA;AACE;AACAF,qBAAWc,QAAX;AACAf,oBAAU,CAAV;AACA,eAAKD,GAAL,IAAYS,MAAZ,EACA;AACEV,oBAAQU,OAAOT,GAAP,CAAR;;AAEA,gBAAID,MAAMW,SAAN,GAAkB,CAAtB,EACA;AACET,yBAAWF,MAAMe,IAAjB;AACAZ,yBAAWG,KAAKQ,GAAL,CAASX,QAAT,EAAmBH,MAAMW,SAAN,GAAkBX,MAAMe,IAA3C,CAAX;AACD;AACF;;AAGD;AACA,cAAIb,WAAW,CAAf,EAAkB;AAChB;AACD;;AAGD;AACA;AACAC,qBAAWG,KAAKQ,GAAL,CAAST,SAAT,EAAoBF,WAAWD,OAA/B,IAA0CA,OAArD;;AAGA;AACAM,2BAAiB,CAAjB;AACA,eAAKP,GAAL,IAAYS,MAAZ,EACA;AACEV,oBAAQU,OAAOT,GAAP,CAAR;;AAEA,gBAAID,MAAMW,SAAN,GAAkB,CAAtB,EACA;AACE;AACAF,8BAAgBH,KAAKQ,GAAL,CAAST,SAAT,EAAoBL,MAAMW,SAA1B,EAAqCL,KAAKY,IAAL,CAAUf,WAAWH,MAAMe,IAA3B,CAArC,CAAhB;;AAEA;AACAP,gCAAkBC,gBAAgBN,WAAWH,MAAMe,IAAnD;AACA,kBAAIP,kBAAkB,CAAtB,EACA;AACEA,kCAAkB,CAAlB;AACAC,iCAAiB,CAAjB;AACD;;AAED;AACAT,oBAAMW,SAAN,IAAmBF,aAAnB;;AAEA,kBAAIL,IAAJ,EAAU;AACRJ,sBAAMgB,MAAN,IAAgBP,aAAhB;AACD,eAFD,MAEO;AACLT,sBAAMgB,MAAN,IAAgBP,aAAhB;AACD;;AAED;AACAJ,2BAAaI,aAAb;AACD;AACF;AACF;;AAED,eAAOC,MAAP;AACD,OA7GH;;AAgHE;;;;;;;;;;;;AAYAS,oCAA+B,sCAASC,KAAT,EAAgBC,KAAhB,EAAuBC,UAAvB,EAAmCC,UAAnC,EAA+CC,WAA/C,EAC/B;AACE,YAAID,cAAc,IAAlB,EAAwB;AACtBA,uBAAa,CAAb;AACD;;AAED,YAAIC,eAAe,IAAnB,EAAyB;AACvBA,wBAAc,CAAd;AACD;;AAED,YAAIX,QAAQ,CAAZ;AACA,gBAAOO,KAAP;AAEE,eAAK,MAAL;AACEP,oBAAQU,UAAR;AACA;;AAEF,eAAK,OAAL;AACE;AACA;AACAV,oBAAQS,aAAaD,KAAb,GAAqBG,WAA7B;AACA;;AAEF,eAAK,QAAL;AACE;AACAX,oBAAQP,KAAKmB,KAAL,CAAW,CAACH,aAAaD,KAAd,IAAuB,CAAlC,CAAR;;AAEA;AACA,gBAAIR,QAAQU,UAAZ,EAAwB;AACtBV,sBAAQU,UAAR;AACD,aAFD,MAEO,IAAIV,QAAQW,WAAZ,EAAyB;AAC9BX,sBAAQP,KAAKM,GAAL,CAASW,UAAT,EAAqBD,aAAWD,KAAX,GAAiBG,WAAtC,CAAR;AACD;;AAED;AAvBJ;;AA0BA,eAAOX,KAAP;AACD,OAlKH;;AAqKE;;;;;;;;;;;;AAYAa,kCAA6B,oCAASN,KAAT,EAAgBO,MAAhB,EAAwBC,WAAxB,EAAqCC,SAArC,EAAgDC,YAAhD,EAC7B;AACE,YAAID,aAAa,IAAjB,EAAuB;AACrBA,sBAAY,CAAZ;AACD;;AAED,YAAIC,gBAAgB,IAApB,EAA0B;AACxBA,yBAAe,CAAf;AACD;;AAED,YAAIjB,QAAQ,CAAZ;AACA,gBAAOO,KAAP;AAEE,eAAK,KAAL;AACEP,oBAAQgB,SAAR;AACA;;AAEF,eAAK,QAAL;AACE;AACA;AACAhB,oBAAQe,cAAcD,MAAd,GAAuBG,YAA/B;AACA;;AAEF,eAAK,QAAL;AACE;AACAjB,oBAAQP,KAAKmB,KAAL,CAAW,CAACG,cAAcD,MAAf,IAAyB,CAApC,CAAR;;AAEA;AACA,gBAAId,QAAQgB,SAAZ,EAAuB;AACrBhB,sBAAQgB,SAAR;AACD,aAFD,MAEO,IAAIhB,QAAQiB,YAAZ,EAA0B;AAC/BjB,sBAAQP,KAAKM,GAAL,CAASiB,SAAT,EAAoBD,cAAYD,MAAZ,GAAmBG,YAAvC,CAAR;AACD;;AAED;AAvBJ;;AA0BA,eAAOjB,KAAP;AACD,OAvNH;;AA0NE;;;;;;;;;;;AAWAkB,uBAAkB,yBAASC,OAAT,EAClB;AACE,YAAIpB,MAAI,CAAR;AAAA,YAAWE,MAAI,CAAf;AACA,aAAK,IAAImB,IAAE,CAAN,EAASC,IAAEC,UAAUC,MAA1B,EAAkCH,IAAEC,CAApC,EAAuCD,GAAvC,EACA;AACE,cAAIpB,QAAQsB,UAAUF,CAAV,CAAZ;;AAEA,cAAIpB,QAAQ,CAAZ,EAAe;AACbC,kBAAMR,KAAKQ,GAAL,CAASA,GAAT,EAAcD,KAAd,CAAN;AACD,WAFD,MAEO,IAAIA,QAAQ,CAAZ,EAAe;AACpBD,kBAAMN,KAAKM,GAAL,CAASA,GAAT,EAAcC,KAAd,CAAN;AACD;AACF;;AAED,eAAOD,MAAME,GAAb;AACD,OApPH;;AAuPE;;;;;;;;;;;;AAYAuB,6BAAwB,+BAASC,QAAT,EAAmBC,OAAnB,EAA4BC,QAA5B,EACxB;AACE,YAAID,WAAW,IAAf,EAAqB;AACnBA,oBAAU,CAAV;AACD;;AAED,YAAIE,OAAO,CAAX;;AAEA,YAAID,QAAJ,EACA;AACE;AACAC,kBAAQH,SAAS,CAAT,EAAYI,aAAZ,EAAR;;AAEA,eAAK,IAAIT,IAAE,CAAN,EAASC,IAAEI,SAASF,MAAzB,EAAiCH,IAAEC,CAAnC,EAAsCD,KAAG,CAAzC,EAA4C;AAC1CQ,oBAAQ,KAAKV,eAAL,CAAqBQ,OAArB,EAA8BD,SAASL,IAAE,CAAX,EAAcU,cAAd,EAA9B,EAA8DL,SAASL,CAAT,EAAYS,aAAZ,EAA9D,CAAR;AACD;;AAED;AACAD,kBAAQH,SAASJ,IAAE,CAAX,EAAcS,cAAd,EAAR;AACD,SAXD,MAaA;AACE;AACA,eAAK,IAAIV,IAAE,CAAN,EAASC,IAAEI,SAASF,MAAzB,EAAiCH,IAAEC,CAAnC,EAAsCD,KAAG,CAAzC,EAA4C;AAC1CQ,oBAAQH,SAASL,CAAT,EAAYS,aAAZ,KAA8BJ,SAASL,CAAT,EAAYU,cAAZ,EAAtC;AACD;;AAED;AACAF,kBAASF,WAAWL,IAAE,CAAb,CAAT;AACD;;AAED,eAAOO,IAAP;AACD,OAnSH;;AAsSE;;;;;;;;;;;;AAYAG,2BAAsB,6BAASN,QAAT,EAAmBC,OAAnB,EAA4BC,QAA5B,EACtB;AACE,YAAID,WAAW,IAAf,EAAqB;AACnBA,oBAAU,CAAV;AACD;;AAED,YAAIE,OAAO,CAAX;;AAEA,YAAID,QAAJ,EACA;AACE;AACAC,kBAAQH,SAAS,CAAT,EAAYO,YAAZ,EAAR;;AAEA,eAAK,IAAIZ,IAAE,CAAN,EAASC,IAAEI,SAASF,MAAzB,EAAiCH,IAAEC,CAAnC,EAAsCD,KAAG,CAAzC,EAA4C;AAC1CQ,oBAAQ,KAAKV,eAAL,CAAqBQ,OAArB,EAA8BD,SAASL,IAAE,CAAX,EAAca,eAAd,EAA9B,EAA+DR,SAASL,CAAT,EAAYY,YAAZ,EAA/D,CAAR;AACD;;AAED;AACAJ,kBAAQH,SAASJ,IAAE,CAAX,EAAcY,eAAd,EAAR;AACD,SAXD,MAaA;AACE;AACA,eAAK,IAAIb,IAAE,CAAN,EAASC,IAAEI,SAASF,MAAzB,EAAiCH,IAAEC,CAAnC,EAAsCD,KAAG,CAAzC,EAA4C;AAC1CQ,oBAAQH,SAASL,CAAT,EAAYY,YAAZ,KAA6BP,SAASL,CAAT,EAAYa,eAAZ,EAArC;AACD;;AAED;AACAL,kBAASF,WAAWL,IAAE,CAAb,CAAT;AACD;;AAED,eAAOO,IAAP;AACD,OAlVH;;AAqVE;;;;;;;;AAQAM,sCAAiC,wCAAST,QAAT,EAAmBC,OAAnB,EAA4BS,SAA5B,EACjC;AACE,YAAIC,WAAW7D,GAAG8D,KAAH,CAASC,OAAT,CAAiBC,UAAjB,CAA4BC,WAA5B,GAA0CC,OAA1C,CAAkDN,SAAlD,CAAf;AACA,YAAIO,SAASN,SAASO,SAAT,EAAb;AACA,YAAInC,QAAQkC,OAAOE,IAAP,GAAcF,OAAOG,KAAjC;;AAEA,YAAIjB,OAAO,CAAX;AACA,aAAK,IAAIR,IAAE,CAAN,EAASC,IAAEI,SAASF,MAAzB,EAAiCH,IAAEC,CAAnC,EAAsCD,GAAtC,EACA;AACE,cAAIjC,QAAQsC,SAASL,CAAT,CAAZ;AACAQ,kBAAQzC,MAAM0C,aAAN,KAAwB1C,MAAM2C,cAAN,EAAhC;AACD;;AAEDF,gBAAQ,CAACF,UAAUlB,KAAV,GAAkBkB,OAAnB,KAA+BL,IAAE,CAAjC,CAAR;;AAEA,eAAOO,IAAP;AACD,OA7WH;;AAgXE;;;;;;;;AAQAkB,oCAA+B,sCAASrB,QAAT,EAAmBC,OAAnB,EAA4BS,SAA5B,EAC/B;AACE,YAAIC,WAAW7D,GAAG8D,KAAH,CAASC,OAAT,CAAiBC,UAAjB,CAA4BC,WAA5B,GAA0CC,OAA1C,CAAkDN,SAAlD,CAAf;AACA,YAAIO,SAASN,SAASO,SAAT,EAAb;AACA,YAAI7B,SAAS4B,OAAOK,GAAP,GAAaL,OAAOM,MAAjC;;AAEA,YAAIpB,OAAO,CAAX;AACA,aAAK,IAAIR,IAAE,CAAN,EAASC,IAAEI,SAASF,MAAzB,EAAiCH,IAAEC,CAAnC,EAAsCD,GAAtC,EACA;AACE,cAAIjC,QAAQsC,SAASL,CAAT,CAAZ;AACAQ,kBAAQzC,MAAM6C,YAAN,KAAuB7C,MAAM8C,eAAN,EAA/B;AACD;;AAEDL,gBAAQ,CAACF,UAAUZ,MAAV,GAAmBY,OAApB,KAAgCL,IAAE,CAAlC,CAAR;;AAEA,eAAOO,IAAP;AACD,OAxYH;;AA2YE;;;;;;;;;;;;;;;AAeAqB,qBAAgB,uBAASC,QAAT,EAAmBC,UAAnB,EAA+BC,QAA/B,EAAyCC,MAAzC,EAAiDC,QAAjD,EAA2DC,MAA3D,EAChB;AACE,YAAIJ,aAAaD,QAAb,IAAyBI,WAAWD,MAAxC,EACA;AACE,cAAIF,aAAaD,QAAb,IAAyBI,WAAWD,MAAxC,EACA;AACE;AACA;AACA;AACAF,yBAAaD,QAAb;AACAI,uBAAWD,MAAX;AACD,WAPD,MAQK,IAAIF,aAAaD,QAAjB,EACL;AACE;AACAI,wBAAaJ,WAAWC,UAAxB;AACAA,yBAAaD,QAAb;;AAEA;AACA,gBAAII,WAAWD,MAAf,EAAuB;AACrBC,yBAAWD,MAAX;AACD;AACF,WAVI,MAWA,IAAIC,WAAWD,MAAf,EACL;AACE;AACAF,0BAAeE,SAASC,QAAxB;AACAA,uBAAWD,MAAX;;AAEA;AACA,gBAAIF,aAAaD,QAAjB,EAA2B;AACzBC,2BAAaD,QAAb;AACD;AACF;AACF;;AAED,YAAIC,aAAaC,QAAb,IAAyBE,WAAWC,MAAxC,EACA;AACE,cAAIJ,aAAaC,QAAb,IAAyBE,WAAWC,MAAxC,EACA;AACE;AACA;AACAJ,yBAAaC,QAAb;AACAE,uBAAWC,MAAX;AACD,WAND,MAOK,IAAIJ,aAAaC,QAAjB,EACL;AACE;AACAE,wBAAaH,aAAaC,QAA1B;AACAD,yBAAaC,QAAb;;AAEA;AACA,gBAAIE,WAAWC,MAAf,EAAuB;AACrBD,yBAAWC,MAAX;AACD;AACF,WAVI,MAWA,IAAID,WAAWC,MAAf,EACL;AACE;AACAJ,0BAAeG,WAAWC,MAA1B;AACAD,uBAAWC,MAAX;;AAEA;AACA,gBAAIJ,aAAaC,QAAjB,EAA2B;AACzBD,2BAAaC,QAAb;AACD;AACF;AACF;;AAED,eAAO;AACLI,iBAAQL,UADH;AAELM,eAAMH;AAFD,SAAP;AAID;AAneH;AAFF,GADA,C;AAxBA/E,KAAGmF,EAAH,CAAMC,MAAN,CAAaC,IAAb,CAAkBlF,aAAlB,GAAkCA,aAAlC",
  "file": "Util.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * Common set of utility methods used by the standard qooxdoo layouts.\n *\n * @internal\n */\nqx.Class.define(\"qx.ui.layout.Util\",\n{\n  statics :\n  {\n    /** @type {RegExp} Regular expression to match percent values */\n    PERCENT_VALUE : /[0-9]+(?:\\.[0-9]+)?%/,\n\n\n    /**\n     * Computes the flex offsets needed to reduce the space\n     * difference as much as possible by respecting the\n     * potential of the given elements (being in the range of\n     * their min/max values)\n     *\n     * @param flexibles {Map} Each entry must have these keys:\n     *   <code>id</code>, <code>potential</code> and <code>flex</code>.\n     *   The ID is used in the result map as the key for the user to work\n     *   with later (e.g. upgrade sizes etc. to respect the given offset)\n     *   The potential is an integer value which is the difference of the\n     *   currently interesting direction (e.g. shrinking=width-minWidth, growing=\n     *   maxWidth-width). The flex key holds the flex value of the item.\n     * @param avail {Integer} Full available space to allocate (ignoring used one)\n     * @param used {Integer} Size of already allocated space\n     * @return {Map} A map which contains the calculated offsets under the key\n     *   which is identical to the ID given in the incoming map.\n     */\n    computeFlexOffsets : function(flexibles, avail, used)\n    {\n      var child, key, flexSum, flexStep;\n      var grow = avail > used;\n      var remaining = Math.abs(avail - used);\n      var roundingOffset, currentOffset;\n\n\n      // Preprocess data\n      var result = {};\n      for (key in flexibles)\n      {\n        child = flexibles[key];\n        result[key] =\n        {\n          potential : grow ? child.max - child.value : child.value - child.min,\n          flex : grow ? child.flex : 1 / child.flex,\n          offset : 0\n        };\n      }\n\n\n      // Continue as long as we need to do anything\n      while (remaining != 0)\n      {\n        // Find minimum potential for next correction\n        flexStep = Infinity;\n        flexSum = 0;\n        for (key in result)\n        {\n          child = result[key];\n\n          if (child.potential > 0)\n          {\n            flexSum += child.flex;\n            flexStep = Math.min(flexStep, child.potential / child.flex);\n          }\n        }\n\n\n        // No potential found, quit here\n        if (flexSum == 0) {\n          break;\n        }\n\n\n        // Respect maximum potential given through remaining space\n        // The parent should always win in such conflicts.\n        flexStep = Math.min(remaining, flexStep * flexSum) / flexSum;\n\n\n        // Start with correction\n        roundingOffset = 0;\n        for (key in result)\n        {\n          child = result[key];\n\n          if (child.potential > 0)\n          {\n            // Compute offset for this step\n            currentOffset = Math.min(remaining, child.potential, Math.ceil(flexStep * child.flex));\n\n            // Fix rounding issues\n            roundingOffset += currentOffset - flexStep * child.flex;\n            if (roundingOffset >= 1)\n            {\n              roundingOffset -= 1;\n              currentOffset -= 1;\n            }\n\n            // Update child status\n            child.potential -= currentOffset;\n\n            if (grow) {\n              child.offset += currentOffset;\n            } else {\n              child.offset -= currentOffset;\n            }\n\n            // Update parent status\n            remaining -= currentOffset;\n          }\n        }\n      }\n\n      return result;\n    },\n\n\n    /**\n     * Computes the offset which needs to be added to the top position\n     * to result in the stated vertical alignment. Also respects\n     * existing margins (without collapsing).\n     *\n     * @param align {String} One of <code>top</code>, <code>center</code> or <code>bottom</code>.\n     * @param width {Integer} The visible width of the widget\n     * @param availWidth {Integer} The available inner width of the parent\n     * @param marginLeft {Integer?0} Optional left margin of the widget\n     * @param marginRight {Integer?0} Optional right margin of the widget\n     * @return {Integer} Computed top coordinate\n     */\n    computeHorizontalAlignOffset : function(align, width, availWidth, marginLeft, marginRight)\n    {\n      if (marginLeft == null) {\n        marginLeft = 0;\n      }\n\n      if (marginRight == null) {\n        marginRight = 0;\n      }\n\n      var value = 0;\n      switch(align)\n      {\n        case \"left\":\n          value = marginLeft;\n          break;\n\n        case \"right\":\n          // Align right changes priority to right edge:\n          // To align to the right is more important here than to left.\n          value = availWidth - width - marginRight;\n          break;\n\n        case \"center\":\n          // Ideal center position\n          value = Math.round((availWidth - width) / 2);\n\n          // Try to make this possible (with left-right priority)\n          if (value < marginLeft) {\n            value = marginLeft;\n          } else if (value < marginRight) {\n            value = Math.max(marginLeft, availWidth-width-marginRight);\n          }\n\n          break;\n      }\n\n      return value;\n    },\n\n\n    /**\n     * Computes the offset which needs to be added to the top position\n     * to result in the stated vertical alignment. Also respects\n     * existing margins (without collapsing).\n     *\n     * @param align {String} One of <code>top</code>, <code>middle</code> or <code>bottom</code>.\n     * @param height {Integer} The visible height of the widget\n     * @param availHeight {Integer} The available inner height of the parent\n     * @param marginTop {Integer?0} Optional top margin of the widget\n     * @param marginBottom {Integer?0} Optional bottom margin of the widget\n     * @return {Integer} Computed top coordinate\n     */\n    computeVerticalAlignOffset : function(align, height, availHeight, marginTop, marginBottom)\n    {\n      if (marginTop == null) {\n        marginTop = 0;\n      }\n\n      if (marginBottom == null) {\n        marginBottom = 0;\n      }\n\n      var value = 0;\n      switch(align)\n      {\n        case \"top\":\n          value = marginTop;\n          break;\n\n        case \"bottom\":\n          // Align bottom changes priority to bottom edge:\n          // To align to the bottom is more important here than to top.\n          value = availHeight - height - marginBottom;\n          break;\n\n        case \"middle\":\n          // Ideal middle position\n          value = Math.round((availHeight - height) / 2);\n\n          // Try to make this possible (with top-down priority)\n          if (value < marginTop) {\n            value = marginTop;\n          } else if (value < marginBottom) {\n            value = Math.max(marginTop, availHeight-height-marginBottom);\n          }\n\n          break;\n      }\n\n      return value;\n    },\n\n\n    /**\n     * Collapses two margins.\n     *\n     * Supports positive and negative margins.\n     * Collapsing find the largest positive and the largest\n     * negative value. Afterwards the result is computed through the\n     * subtraction of the negative from the positive value.\n     *\n     * @param varargs {arguments} Any number of configured margins\n     * @return {Integer} The collapsed margin\n     */\n    collapseMargins : function(varargs)\n    {\n      var max=0, min=0;\n      for (var i=0, l=arguments.length; i<l; i++)\n      {\n        var value = arguments[i];\n\n        if (value < 0) {\n          min = Math.min(min, value);\n        } else if (value > 0) {\n          max = Math.max(max, value);\n        }\n      }\n\n      return max + min;\n    },\n\n\n    /**\n     * Computes the sum of all horizontal gaps. Normally the\n     * result is used to compute the available width in a widget.\n     *\n     * The method optionally respects margin collapsing as well. In\n     * this mode the spacing is collapsed together with the margins.\n     *\n     * @param children {Array} List of children\n     * @param spacing {Integer?0} Spacing between every child\n     * @param collapse {Boolean?false} Optional margin collapsing mode\n     * @return {Integer} Sum of all gaps in the final layout.\n     */\n    computeHorizontalGaps : function(children, spacing, collapse)\n    {\n      if (spacing == null) {\n        spacing = 0;\n      }\n\n      var gaps = 0;\n\n      if (collapse)\n      {\n        // Add first child\n        gaps += children[0].getMarginLeft();\n\n        for (var i=1, l=children.length; i<l; i+=1) {\n          gaps += this.collapseMargins(spacing, children[i-1].getMarginRight(), children[i].getMarginLeft());\n        }\n\n        // Add last child\n        gaps += children[l-1].getMarginRight();\n      }\n      else\n      {\n        // Simple adding of all margins\n        for (var i=1, l=children.length; i<l; i+=1) {\n          gaps += children[i].getMarginLeft() + children[i].getMarginRight();\n        }\n\n        // Add spacing\n        gaps += (spacing * (l-1));\n      }\n\n      return gaps;\n    },\n\n\n    /**\n     * Computes the sum of all vertical gaps. Normally the\n     * result is used to compute the available height in a widget.\n     *\n     * The method optionally respects margin collapsing as well. In\n     * this mode the spacing is collapsed together with the margins.\n     *\n     * @param children {Array} List of children\n     * @param spacing {Integer?0} Spacing between every child\n     * @param collapse {Boolean?false} Optional margin collapsing mode\n     * @return {Integer} Sum of all gaps in the final layout.\n     */\n    computeVerticalGaps : function(children, spacing, collapse)\n    {\n      if (spacing == null) {\n        spacing = 0;\n      }\n\n      var gaps = 0;\n\n      if (collapse)\n      {\n        // Add first child\n        gaps += children[0].getMarginTop();\n\n        for (var i=1, l=children.length; i<l; i+=1) {\n          gaps += this.collapseMargins(spacing, children[i-1].getMarginBottom(), children[i].getMarginTop());\n        }\n\n        // Add last child\n        gaps += children[l-1].getMarginBottom();\n      }\n      else\n      {\n        // Simple adding of all margins\n        for (var i=1, l=children.length; i<l; i+=1) {\n          gaps += children[i].getMarginTop() + children[i].getMarginBottom();\n        }\n\n        // Add spacing\n        gaps += (spacing * (l-1));\n      }\n\n      return gaps;\n    },\n\n\n    /**\n     * Computes the gaps together with the configuration of separators.\n     *\n     * @param children {qx.ui.core.LayoutItem[]} List of children\n     * @param spacing {Integer} Configured spacing\n     * @param separator {String|qx.ui.decoration.IDecorator} Separator to render\n     * @return {Integer} Sum of gaps\n     */\n    computeHorizontalSeparatorGaps : function(children, spacing, separator)\n    {\n      var instance = qx.theme.manager.Decoration.getInstance().resolve(separator);\n      var insets = instance.getInsets();\n      var width = insets.left + insets.right;\n\n      var gaps = 0;\n      for (var i=0, l=children.length; i<l; i++)\n      {\n        var child = children[i];\n        gaps += child.getMarginLeft() + child.getMarginRight();\n      }\n\n      gaps += (spacing + width + spacing) * (l-1);\n\n      return gaps;\n    },\n\n\n    /**\n     * Computes the gaps together with the configuration of separators.\n     *\n     * @param children {qx.ui.core.LayoutItem[]} List of children\n     * @param spacing {Integer} Configured spacing\n     * @param separator {String|qx.ui.decoration.IDecorator} Separator to render\n     * @return {Integer} Sum of gaps\n     */\n    computeVerticalSeparatorGaps : function(children, spacing, separator)\n    {\n      var instance = qx.theme.manager.Decoration.getInstance().resolve(separator);\n      var insets = instance.getInsets();\n      var height = insets.top + insets.bottom;\n\n      var gaps = 0;\n      for (var i=0, l=children.length; i<l; i++)\n      {\n        var child = children[i];\n        gaps += child.getMarginTop() + child.getMarginBottom();\n      }\n\n      gaps += (spacing + height + spacing) * (l-1);\n\n      return gaps;\n    },\n\n\n    /**\n     * Arranges two sizes in one box to best respect their individual limitations.\n     *\n     * Mainly used by split layouts (Split Panes) where the layout is mainly defined\n     * by the outer dimensions.\n     *\n     * @param beginMin {Integer} Minimum size of first widget (from size hint)\n     * @param beginIdeal {Integer} Ideal size of first widget (maybe after dragging the splitter)\n     * @param beginMax {Integer} Maximum size of first widget (from size hint)\n     * @param endMin {Integer} Minimum size of second widget (from size hint)\n     * @param endIdeal {Integer} Ideal size of second widget (maybe after dragging the splitter)\n     * @param endMax {Integer} Maximum size of second widget (from size hint)\n     * @return {Map} Map with the keys <code>begin</code and <code>end</code> with the\n     *   arranged dimensions.\n     */\n    arrangeIdeals : function(beginMin, beginIdeal, beginMax, endMin, endIdeal, endMax)\n    {\n      if (beginIdeal < beginMin || endIdeal < endMin)\n      {\n        if (beginIdeal < beginMin && endIdeal < endMin)\n        {\n          // Just increase both, can not rearrange them otherwise\n          // Result into overflowing of the overlapping content\n          // Should normally not happen through auto sizing!\n          beginIdeal = beginMin;\n          endIdeal = endMin;\n        }\n        else if (beginIdeal < beginMin)\n        {\n          // Reduce end, increase begin to min\n          endIdeal -= (beginMin - beginIdeal);\n          beginIdeal = beginMin;\n\n          // Re-check to keep min size of end\n          if (endIdeal < endMin) {\n            endIdeal = endMin;\n          }\n        }\n        else if (endIdeal < endMin)\n        {\n          // Reduce begin, increase end to min\n          beginIdeal -= (endMin - endIdeal);\n          endIdeal = endMin;\n\n          // Re-check to keep min size of begin\n          if (beginIdeal < beginMin) {\n            beginIdeal = beginMin;\n          }\n        }\n      }\n\n      if (beginIdeal > beginMax || endIdeal > endMax)\n      {\n        if (beginIdeal > beginMax && endIdeal > endMax)\n        {\n          // Just reduce both, can not rearrange them otherwise\n          // Leaves a blank area in the pane!\n          beginIdeal = beginMax;\n          endIdeal = endMax;\n        }\n        else if (beginIdeal > beginMax)\n        {\n          // Increase end, reduce begin to max\n          endIdeal += (beginIdeal - beginMax);\n          beginIdeal = beginMax;\n\n          // Re-check to keep max size of end\n          if (endIdeal > endMax) {\n            endIdeal = endMax;\n          }\n        }\n        else if (endIdeal > endMax)\n        {\n          // Increase begin, reduce end to max\n          beginIdeal += (endIdeal - endMax);\n          endIdeal = endMax;\n\n          // Re-check to keep max size of begin\n          if (beginIdeal > beginMax) {\n            beginIdeal = beginMax;\n          }\n        }\n      }\n\n      return {\n        begin : beginIdeal,\n        end : endIdeal\n      };\n    }\n  }\n});\n"
  ]
}