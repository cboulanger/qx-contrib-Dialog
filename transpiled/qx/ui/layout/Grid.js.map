{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/ui/layout/Grid.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "layout",
    "Abstract",
    "construct",
    "spacingX",
    "spacingY",
    "__rowData",
    "__colData",
    "setSpacingX",
    "setSpacingY",
    "properties",
    "check",
    "init",
    "apply",
    "members",
    "__grid",
    "__colSpans",
    "__rowSpans",
    "__maxRowIndex",
    "__maxColIndex",
    "__rowHeights",
    "__colWidths",
    "verifyLayoutProperty",
    "item",
    "name",
    "value",
    "layoutProperties",
    "assert",
    "assertInteger",
    "__buildGrid",
    "grid",
    "colSpans",
    "rowSpans",
    "maxRowIndex",
    "maxColIndex",
    "children",
    "_getLayoutChildren",
    "i",
    "l",
    "length",
    "child",
    "props",
    "getLayoutProperties",
    "row",
    "column",
    "colSpan",
    "rowSpan",
    "Error",
    "x",
    "y",
    "undefined",
    "Math",
    "max",
    "push",
    "_invalidChildrenCache",
    "_setRowData",
    "key",
    "rowData",
    "_setColumnData",
    "colData",
    "setSpacing",
    "spacing",
    "setColumnAlign",
    "hAlign",
    "vAlign",
    "assertInArray",
    "_applyLayoutChange",
    "getColumnAlign",
    "setRowAlign",
    "getRowAlign",
    "getCellWidget",
    "getRowCount",
    "getColumnCount",
    "getCellAlign",
    "widget",
    "widgetProps",
    "getAlignY",
    "getAlignX",
    "setColumnFlex",
    "flex",
    "getColumnFlex",
    "setRowFlex",
    "getRowFlex",
    "rowFlex",
    "setColumnMaxWidth",
    "maxWidth",
    "getColumnMaxWidth",
    "Infinity",
    "setColumnWidth",
    "width",
    "getColumnWidth",
    "setColumnMinWidth",
    "minWidth",
    "getColumnMinWidth",
    "setRowMaxHeight",
    "maxHeight",
    "getRowMaxHeight",
    "setRowHeight",
    "height",
    "getRowHeight",
    "setRowMinHeight",
    "minHeight",
    "getRowMinHeight",
    "__getOuterSize",
    "hint",
    "getSizeHint",
    "hMargins",
    "getMarginLeft",
    "getMarginRight",
    "vMargins",
    "getMarginTop",
    "getMarginBottom",
    "outerSize",
    "_fixHeightsRowSpan",
    "rowHeights",
    "vSpacing",
    "getSpacingY",
    "widgetRow",
    "prefSpanHeight",
    "minSpanHeight",
    "rowFlexes",
    "j",
    "rowHeight",
    "min",
    "lang",
    "Object",
    "isEmpty",
    "rowIncrements",
    "Util",
    "computeFlexOffsets",
    "k",
    "offset",
    "totalSpacing",
    "availableHeight",
    "avgRowHeight",
    "floor",
    "usedHeight",
    "rowsNeedAddition",
    "currentHeight",
    "additionalRowHeight",
    "_fixWidthsColSpan",
    "colWidths",
    "hSpacing",
    "getSpacingX",
    "widgetColumn",
    "prefSpanWidth",
    "minSpanWidth",
    "colFlexes",
    "col",
    "colWidth",
    "colFlex",
    "colIncrements",
    "_getRowHeights",
    "widgetRowSpan",
    "cellSize",
    "_getColWidths",
    "widgetColSpan",
    "_getColumnFlexOffsets",
    "diff",
    "flexibles",
    "_getRowFlexOffsets",
    "renderLayout",
    "availWidth",
    "availHeight",
    "padding",
    "prefWidths",
    "colStretchOffsets",
    "prefHeights",
    "rowStretchOffsets",
    "left",
    "top",
    "spanWidth",
    "spanHeight",
    "cellHint",
    "marginTop",
    "marginLeft",
    "marginBottom",
    "marginRight",
    "cellWidth",
    "cellHeight",
    "cellAlign",
    "cellLeft",
    "computeHorizontalAlignOffset",
    "cellTop",
    "computeVerticalAlignOffset",
    "invalidateLayoutCache",
    "_computeSizeHint",
    "destruct",
    "Grid"
  ],
  "mappings": "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",
  "file": "Grid.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * The grid layout manager arranges the items in a two dimensional\n * grid. Widgets can be placed into the grid's cells and may span multiple rows\n * and columns.\n *\n * *Features*\n *\n * * Flex values for rows and columns\n * * Minimal and maximal column and row sizes\n * * Manually setting of column and row sizes\n * * Horizontal and vertical alignment\n * * Horizontal and vertical spacing\n * * Column and row spans\n * * Auto-sizing\n *\n * *Item Properties*\n *\n * <ul>\n * <li><strong>row</strong> <em>(Integer)</em>: The row of the cell the\n *   widget should occupy. Each cell can only containing one widget. This layout\n *   property is mandatory.\n * </li>\n * <li><strong>column</strong> <em>(Integer)</em>: The column of the cell the\n *   widget should occupy. Each cell can only containing one widget. This layout\n *   property is mandatory.\n * </li>\n * <li><strong>rowSpan</strong> <em>(Integer)</em>: The number of rows, the\n *   widget should span, starting from the row specified in the <code>row</code>\n *   property. The cells in the spanned rows must be empty as well.\n * </li>\n * <li><strong>colSpan</strong> <em>(Integer)</em>: The number of columns, the\n *   widget should span, starting from the column specified in the <code>column</code>\n *   property. The cells in the spanned columns must be empty as well.\n * </li>\n * </ul>\n *\n * *Example*\n *\n * Here is a little example of how to use the grid layout.\n *\n * <pre class=\"javascript\">\n * var layout = new qx.ui.layout.Grid();\n * layout.setRowFlex(0, 1); // make row 0 flexible\n * layout.setColumnWidth(1, 200); // set with of column 1 to 200 pixel\n *\n * var container = new qx.ui.container.Composite(layout);\n * container.add(new qx.ui.core.Widget(), {row: 0, column: 0});\n * container.add(new qx.ui.core.Widget(), {row: 0, column: 1});\n * container.add(new qx.ui.core.Widget(), {row: 1, column: 0, rowSpan: 2});\n * </pre>\n *\n * *External Documentation*\n *\n * <a href='http://manual.qooxdoo.org/${qxversion}/pages/layout/grid.html'>\n * Extended documentation</a> and links to demos of this layout in the qooxdoo manual.\n */\nqx.Class.define(\"qx.ui.layout.Grid\",\n{\n  extend : qx.ui.layout.Abstract,\n\n\n\n\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * @param spacingX {Integer?0} The horizontal spacing between grid cells.\n   *     Sets {@link #spacingX}.\n   * @param spacingY {Integer?0} The vertical spacing between grid cells.\n   *     Sets {@link #spacingY}.\n   */\n  construct : function(spacingX, spacingY)\n  {\n    this.base(arguments);\n\n    this.__rowData = [];\n    this.__colData = [];\n\n    if (spacingX) {\n      this.setSpacingX(spacingX);\n    }\n\n    if (spacingY) {\n      this.setSpacingY(spacingY);\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n    /**\n     * The horizontal spacing between grid cells.\n     */\n    spacingX :\n    {\n      check : \"Integer\",\n      init : 0,\n      apply : \"_applyLayoutChange\"\n    },\n\n\n    /**\n     * The vertical spacing between grid cells.\n     */\n    spacingY :\n    {\n      check : \"Integer\",\n      init : 0,\n      apply : \"_applyLayoutChange\"\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    /** @type {Array} 2D array of grid cell data */\n    __grid : null,\n    __rowData : null,\n    __colData : null,\n\n    __colSpans : null,\n    __rowSpans : null,\n    __maxRowIndex : null,\n    __maxColIndex : null,\n\n    /** @type {Array} cached row heights */\n    __rowHeights : null,\n\n    /** @type {Array} cached column widths */\n    __colWidths : null,\n\n\n\n    // overridden\n    verifyLayoutProperty : qx.core.Environment.select(\"qx.debug\",\n    {\n      \"true\" : function(item, name, value)\n      {\n        var layoutProperties = {\n          \"row\" : 1,\n          \"column\" : 1,\n          \"rowSpan\" : 1,\n          \"colSpan\" : 1\n        };\n        this.assert(layoutProperties[name] == 1, \"The property '\"+name+\"' is not supported by the Grid layout!\");\n        this.assertInteger(value);\n        this.assert(value >= 0, \"Value must be positive\");\n      },\n\n      \"false\" : null\n    }),\n\n\n    /**\n     * Rebuild the internal representation of the grid\n     */\n    __buildGrid : function()\n    {\n      var grid = [];\n      var colSpans = [];\n      var rowSpans = [];\n\n      var maxRowIndex = -1;\n      var maxColIndex = -1;\n\n      var children = this._getLayoutChildren();\n\n      for (var i=0,l=children.length; i<l; i++)\n      {\n        var child = children[i];\n        var props = child.getLayoutProperties();\n\n        var row = props.row;\n        var column = props.column;\n\n        props.colSpan = props.colSpan || 1;\n        props.rowSpan = props.rowSpan || 1;\n\n        // validate arguments\n        if (row == null || column == null) {\n          throw new Error(\n            \"The layout properties 'row' and 'column' of the child widget '\" +\n            child + \"' must be defined!\"\n          );\n        }\n\n        if (grid[row] && grid[row][column]) {\n          throw new Error(\n            \"Cannot add widget '\" + child + \"'!. \" +\n            \"There is already a widget '\" + grid[row][column] +\n            \"' in this cell (\" + row + \", \" + column + \") for '\" + this + \"'\"\n          );\n        }\n\n        for (var x=column; x<column+props.colSpan; x++)\n        {\n          for (var y=row; y<row+props.rowSpan; y++)\n          {\n            if (grid[y] == undefined) {\n               grid[y] = [];\n            }\n\n            grid[y][x] = child;\n\n            maxColIndex = Math.max(maxColIndex, x);\n            maxRowIndex = Math.max(maxRowIndex, y);\n          }\n        }\n\n        if (props.rowSpan > 1) {\n          rowSpans.push(child);\n        }\n\n        if (props.colSpan > 1) {\n          colSpans.push(child);\n        }\n      }\n\n      // make sure all columns are defined so that accessing the grid using\n      // this.__grid[column][row] will never raise an exception\n      for (var y=0; y<=maxRowIndex; y++) {\n        if (grid[y] == undefined) {\n           grid[y] = [];\n        }\n      }\n\n      this.__grid = grid;\n\n      this.__colSpans = colSpans;\n      this.__rowSpans = rowSpans;\n\n      this.__maxRowIndex = maxRowIndex;\n      this.__maxColIndex = maxColIndex;\n\n      this.__rowHeights = null;\n      this.__colWidths = null;\n\n      // Clear invalidation marker\n      delete this._invalidChildrenCache;\n    },\n\n\n    /**\n     * Stores data for a grid row\n     *\n     * @param row {Integer} The row index\n     * @param key {String} The key under which the data should be stored\n     * @param value {var} data to store\n     */\n    _setRowData : function(row, key, value)\n    {\n      var rowData = this.__rowData[row];\n\n      if (!rowData)\n      {\n        this.__rowData[row] = {};\n        this.__rowData[row][key] = value;\n      }\n      else\n      {\n        rowData[key] = value;\n      }\n    },\n\n\n    /**\n     * Stores data for a grid column\n     *\n     * @param column {Integer} The column index\n     * @param key {String} The key under which the data should be stored\n     * @param value {var} data to store\n     */\n    _setColumnData : function(column, key, value)\n    {\n      var colData = this.__colData[column];\n\n      if (!colData)\n      {\n        this.__colData[column] = {};\n        this.__colData[column][key] = value;\n      }\n      else\n      {\n        colData[key] = value;\n      }\n    },\n\n\n    /**\n     * Shortcut to set both horizontal and vertical spacing between grid cells\n     * to the same value.\n     *\n     * @param spacing {Integer} new horizontal and vertical spacing\n     * @return {qx.ui.layout.Grid} This object (for chaining support).\n     */\n    setSpacing : function(spacing)\n    {\n      this.setSpacingY(spacing);\n      this.setSpacingX(spacing);\n      return this;\n    },\n\n\n    /**\n     * Set the default cell alignment for a column. This alignment can be\n     * overridden on a per cell basis by setting the cell's content widget's\n     * <code>alignX</code> and <code>alignY</code> properties.\n     *\n     * If on a grid cell both row and a column alignment is set, the horizontal\n     * alignment is taken from the column and the vertical alignment is taken\n     * from the row.\n     *\n     * @param column {Integer} Column index\n     * @param hAlign {String} The horizontal alignment. Valid values are\n     *    \"left\", \"center\" and \"right\".\n     * @param vAlign {String} The vertical alignment. Valid values are\n     *    \"top\", \"middle\", \"bottom\"\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setColumnAlign : function(column, hAlign, vAlign)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        this.assertInteger(column, \"Invalid parameter 'column'\");\n        this.assertInArray(hAlign, [\"left\", \"center\", \"right\"]);\n        this.assertInArray(vAlign, [\"top\", \"middle\", \"bottom\"]);\n      }\n\n      this._setColumnData(column, \"hAlign\", hAlign);\n      this._setColumnData(column, \"vAlign\", vAlign);\n\n      this._applyLayoutChange();\n\n      return this;\n    },\n\n\n    /**\n     * Get a map of the column's alignment.\n     *\n     * @param column {Integer} The column index\n     * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>\n     *     containing the vertical and horizontal column alignment.\n     */\n    getColumnAlign : function(column)\n    {\n      var colData = this.__colData[column] || {};\n\n      return {\n        vAlign : colData.vAlign || \"top\",\n        hAlign : colData.hAlign || \"left\"\n      };\n    },\n\n\n    /**\n     * Set the default cell alignment for a row. This alignment can be\n     * overridden on a per cell basis by setting the cell's content widget's\n     * <code>alignX</code> and <code>alignY</code> properties.\n     *\n     * If on a grid cell both row and a column alignment is set, the horizontal\n     * alignment is taken from the column and the vertical alignment is taken\n     * from the row.\n     *\n     * @param row {Integer} Row index\n     * @param hAlign {String} The horizontal alignment. Valid values are\n     *    \"left\", \"center\" and \"right\".\n     * @param vAlign {String} The vertical alignment. Valid values are\n     *    \"top\", \"middle\", \"bottom\"\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setRowAlign : function(row, hAlign, vAlign)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        this.assertInteger(row, \"Invalid parameter 'row'\");\n        this.assertInArray(hAlign, [\"left\", \"center\", \"right\"]);\n        this.assertInArray(vAlign, [\"top\", \"middle\", \"bottom\"]);\n      }\n\n      this._setRowData(row, \"hAlign\", hAlign);\n      this._setRowData(row, \"vAlign\", vAlign);\n\n      this._applyLayoutChange();\n\n      return this;\n    },\n\n\n    /**\n     * Get a map of the row's alignment.\n     *\n     * @param row {Integer} The Row index\n     * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>\n     *     containing the vertical and horizontal row alignment.\n     */\n    getRowAlign : function(row)\n    {\n      var rowData = this.__rowData[row] || {};\n\n      return {\n        vAlign : rowData.vAlign || \"top\",\n        hAlign : rowData.hAlign || \"left\"\n      };\n    },\n\n\n    /**\n     * Get the widget located in the cell. If a the cell is empty or the widget\n     * has a {@link qx.ui.core.Widget#visibility} value of <code>exclude</code>,\n     * <code>null</code> is returned.\n     *\n     * @param row {Integer} The cell's row index\n     * @param column {Integer} The cell's column index\n     * @return {qx.ui.core.Widget|null}The cell's widget. The value may be null.\n     */\n    getCellWidget : function(row, column)\n    {\n      if (this._invalidChildrenCache) {\n        this.__buildGrid();\n      }\n\n      var row = this.__grid[row] || {};\n      return row[column] ||  null;\n    },\n\n\n    /**\n     * Get the number of rows in the grid layout.\n     *\n     * @return {Integer} The number of rows in the layout\n     */\n    getRowCount : function()\n    {\n      if (this._invalidChildrenCache) {\n        this.__buildGrid();\n      }\n\n      return this.__maxRowIndex + 1;\n    },\n\n\n    /**\n     * Get the number of columns in the grid layout.\n     *\n     * @return {Integer} The number of columns in the layout\n     */\n    getColumnCount : function()\n    {\n      if (this._invalidChildrenCache) {\n        this.__buildGrid();\n      }\n\n      return this.__maxColIndex + 1;\n    },\n\n\n    /**\n     * Get a map of the cell's alignment. For vertical alignment the row alignment\n     * takes precedence over the column alignment. For horizontal alignment it is\n     * the over way round. If an alignment is set on the cell widget using\n     * {@link qx.ui.core.LayoutItem#setLayoutProperties}, this alignment takes\n     * always precedence over row or column alignment.\n     *\n     * @param row {Integer} The cell's row index\n     * @param column {Integer} The cell's column index\n     * @return {Map} A map with the keys <code>vAlign</code> and <code>hAlign</code>\n     *     containing the vertical and horizontal cell alignment.\n     */\n    getCellAlign : function(row, column)\n    {\n      var vAlign = \"top\";\n      var hAlign = \"left\";\n\n      var rowData = this.__rowData[row];\n      var colData = this.__colData[column];\n\n      var widget = this.__grid[row][column];\n      if (widget)\n      {\n        var widgetProps = {\n          vAlign : widget.getAlignY(),\n          hAlign : widget.getAlignX()\n        };\n      }\n      else\n      {\n        widgetProps = {};\n      }\n\n      // compute vAlign\n      // precedence : widget -> row -> column\n      if (widgetProps.vAlign) {\n        vAlign = widgetProps.vAlign;\n      } else if (rowData && rowData.vAlign) {\n        vAlign = rowData.vAlign;\n      } else if (colData && colData.vAlign) {\n        vAlign = colData.vAlign;\n      }\n\n      // compute hAlign\n      // precedence : widget -> column -> row\n      if (widgetProps.hAlign) {\n        hAlign = widgetProps.hAlign;\n      } else if (colData && colData.hAlign) {\n        hAlign = colData.hAlign;\n      } else if (rowData && rowData.hAlign) {\n        hAlign = rowData.hAlign;\n      }\n\n      return {\n        vAlign : vAlign,\n        hAlign : hAlign\n      };\n    },\n\n\n    /**\n     * Set the flex value for a grid column.\n     * By default the column flex value is <code>0</code>.\n     *\n     * @param column {Integer} The column index\n     * @param flex {Integer} The column's flex value\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setColumnFlex : function(column, flex)\n    {\n      this._setColumnData(column, \"flex\", flex);\n      this._applyLayoutChange();\n      return this;\n    },\n\n\n    /**\n     * Get the flex value of a grid column.\n     *\n     * @param column {Integer} The column index\n     * @return {Integer} The column's flex value\n     */\n    getColumnFlex : function(column)\n    {\n      var colData = this.__colData[column] || {};\n      return colData.flex !== undefined ? colData.flex : 0;\n    },\n\n\n    /**\n     * Set the flex value for a grid row.\n     * By default the row flex value is <code>0</code>.\n     *\n     * @param row {Integer} The row index\n     * @param flex {Integer} The row's flex value\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setRowFlex : function(row, flex)\n    {\n      this._setRowData(row, \"flex\", flex);\n      this._applyLayoutChange();\n      return this;\n    },\n\n\n    /**\n     * Get the flex value of a grid row.\n     *\n     * @param row {Integer} The row index\n     * @return {Integer} The row's flex value\n     */\n    getRowFlex : function(row)\n    {\n      var rowData = this.__rowData[row] || {};\n      var rowFlex = rowData.flex !== undefined ? rowData.flex : 0;\n      return rowFlex;\n    },\n\n\n    /**\n     * Set the maximum width of a grid column.\n     * The default value is <code>Infinity</code>.\n     *\n     * @param column {Integer} The column index\n     * @param maxWidth {Integer} The column's maximum width\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setColumnMaxWidth : function(column, maxWidth)\n    {\n      this._setColumnData(column, \"maxWidth\", maxWidth);\n      this._applyLayoutChange();\n      return this;\n    },\n\n\n    /**\n     * Get the maximum width of a grid column.\n     *\n     * @param column {Integer} The column index\n     * @return {Integer} The column's maximum width\n     */\n    getColumnMaxWidth : function(column)\n    {\n      var colData = this.__colData[column] || {};\n      return colData.maxWidth !== undefined ? colData.maxWidth : Infinity;\n    },\n\n\n    /**\n     * Set the preferred width of a grid column.\n     * The default value is <code>Infinity</code>.\n     *\n     * @param column {Integer} The column index\n     * @param width {Integer} The column's width\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setColumnWidth : function(column, width)\n    {\n      this._setColumnData(column, \"width\", width);\n      this._applyLayoutChange();\n      return this;\n    },\n\n\n    /**\n     * Get the preferred width of a grid column.\n     *\n     * @param column {Integer} The column index\n     * @return {Integer} The column's width\n     */\n    getColumnWidth : function(column)\n    {\n      var colData = this.__colData[column] || {};\n      return colData.width !== undefined ? colData.width : null;\n    },\n\n\n    /**\n     * Set the minimum width of a grid column.\n     * The default value is <code>0</code>.\n     *\n     * @param column {Integer} The column index\n     * @param minWidth {Integer} The column's minimum width\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setColumnMinWidth : function(column, minWidth)\n    {\n      this._setColumnData(column, \"minWidth\", minWidth);\n      this._applyLayoutChange();\n      return this;\n    },\n\n\n    /**\n     * Get the minimum width of a grid column.\n     *\n     * @param column {Integer} The column index\n     * @return {Integer} The column's minimum width\n     */\n    getColumnMinWidth : function(column)\n    {\n      var colData = this.__colData[column] || {};\n      return colData.minWidth || 0;\n    },\n\n\n    /**\n     * Set the maximum height of a grid row.\n     * The default value is <code>Infinity</code>.\n     *\n     * @param row {Integer} The row index\n     * @param maxHeight {Integer} The row's maximum width\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setRowMaxHeight : function(row, maxHeight)\n    {\n      this._setRowData(row, \"maxHeight\", maxHeight);\n      this._applyLayoutChange();\n      return this;\n    },\n\n\n    /**\n     * Get the maximum height of a grid row.\n     *\n     * @param row {Integer} The row index\n     * @return {Integer} The row's maximum width\n     */\n    getRowMaxHeight : function(row)\n    {\n      var rowData = this.__rowData[row] || {};\n      return rowData.maxHeight || Infinity;\n    },\n\n\n    /**\n     * Set the preferred height of a grid row.\n     * The default value is <code>Infinity</code>.\n     *\n     * @param row {Integer} The row index\n     * @param height {Integer} The row's width\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setRowHeight : function(row, height)\n    {\n      this._setRowData(row, \"height\", height);\n      this._applyLayoutChange();\n      return this;\n    },\n\n\n    /**\n     * Get the preferred height of a grid row.\n     *\n     * @param row {Integer} The row index\n     * @return {Integer} The row's width\n     */\n    getRowHeight : function(row)\n    {\n      var rowData = this.__rowData[row] || {};\n      return rowData.height !== undefined ? rowData.height : null;\n    },\n\n\n    /**\n     * Set the minimum height of a grid row.\n     * The default value is <code>0</code>.\n     *\n     * @param row {Integer} The row index\n     * @param minHeight {Integer} The row's minimum width\n     * @return {qx.ui.layout.Grid} This object (for chaining support)\n     */\n    setRowMinHeight : function(row, minHeight)\n    {\n      this._setRowData(row, \"minHeight\", minHeight);\n      this._applyLayoutChange();\n      return this;\n    },\n\n\n    /**\n     * Get the minimum height of a grid row.\n     *\n     * @param row {Integer} The row index\n     * @return {Integer} The row's minimum width\n     */\n    getRowMinHeight : function(row)\n    {\n      var rowData = this.__rowData[row] || {};\n      return rowData.minHeight || 0;\n    },\n\n\n    /**\n     * Computes the widget's size hint including the widget's margins\n     *\n     * @param widget {qx.ui.core.LayoutItem} The widget to get the size for\n     * @return {Map} a size hint map\n     */\n    __getOuterSize : function(widget)\n    {\n      var hint = widget.getSizeHint();\n      var hMargins = widget.getMarginLeft() + widget.getMarginRight();\n      var vMargins = widget.getMarginTop() + widget.getMarginBottom();\n\n      var outerSize = {\n        height: hint.height + vMargins,\n        width: hint.width + hMargins,\n        minHeight: hint.minHeight + vMargins,\n        minWidth: hint.minWidth + hMargins,\n        maxHeight: hint.maxHeight + vMargins,\n        maxWidth: hint.maxWidth + hMargins\n      };\n\n      return outerSize;\n    },\n\n\n    /**\n     * Check whether all row spans fit with their preferred height into the\n     * preferred row heights. If there is not enough space, the preferred\n     * row sizes are increased. The distribution respects the flex and max\n     * values of the rows.\n     *\n     *  The same is true for the min sizes.\n     *\n     *  The height array is modified in place.\n     *\n     * @param rowHeights {Map[]} The current row height array as computed by\n     *     {@link #_getRowHeights}.\n     */\n    _fixHeightsRowSpan : function(rowHeights)\n    {\n      var vSpacing = this.getSpacingY();\n\n      for (var i=0, l=this.__rowSpans.length; i<l; i++)\n      {\n        var widget = this.__rowSpans[i];\n\n        var hint = this.__getOuterSize(widget);\n\n        var widgetProps = widget.getLayoutProperties();\n        var widgetRow = widgetProps.row;\n\n        var prefSpanHeight = vSpacing * (widgetProps.rowSpan - 1);\n        var minSpanHeight = prefSpanHeight;\n\n        var rowFlexes = {};\n\n        for (var j=0; j<widgetProps.rowSpan; j++)\n        {\n          var row = widgetProps.row+j;\n          var rowHeight = rowHeights[row];\n          var rowFlex = this.getRowFlex(row);\n\n          if (rowFlex > 0)\n          {\n            // compute flex array for the preferred height\n            rowFlexes[row] =\n            {\n              min : rowHeight.minHeight,\n              value : rowHeight.height,\n              max : rowHeight.maxHeight,\n              flex: rowFlex\n            };\n          }\n\n          prefSpanHeight += rowHeight.height;\n          minSpanHeight += rowHeight.minHeight;\n        }\n\n        // If there is not enough space for the preferred size\n        // increment the preferred row sizes.\n        if (prefSpanHeight < hint.height)\n        {\n          if (!qx.lang.Object.isEmpty(rowFlexes)) {\n            var rowIncrements = qx.ui.layout.Util.computeFlexOffsets(\n              rowFlexes, hint.height, prefSpanHeight\n            );\n\n            for (var k=0; k<widgetProps.rowSpan; k++)\n            {\n              var offset = rowIncrements[widgetRow+k] ? rowIncrements[widgetRow+k].offset : 0;\n              rowHeights[widgetRow+k].height += offset;\n            }\n          // row is too small and we have no flex value set\n          } else {\n            var totalSpacing = vSpacing * (widgetProps.rowSpan - 1);\n            var availableHeight = hint.height - totalSpacing;\n\n            // get the row height which every child would need to share the\n            // available hight equally\n            var avgRowHeight =\n              Math.floor(availableHeight / widgetProps.rowSpan);\n\n            // get the hight already used and the number of children which do\n            // not have at least that avg row height\n            var usedHeight = 0;\n            var rowsNeedAddition = 0;\n            for (var k = 0; k < widgetProps.rowSpan; k++) {\n              var currentHeight = rowHeights[widgetRow + k].height;\n              usedHeight += currentHeight;\n              if (currentHeight < avgRowHeight) {\n                rowsNeedAddition++;\n              }\n            }\n\n            // the difference of available and used needs to be shared among\n            // those not having the min size\n            var additionalRowHeight =\n              Math.floor((availableHeight - usedHeight) / rowsNeedAddition);\n\n            // add the extra height to the too small children\n            for (var k = 0; k < widgetProps.rowSpan; k++) {\n              if (rowHeights[widgetRow + k].height < avgRowHeight) {\n                rowHeights[widgetRow + k].height += additionalRowHeight;\n              }\n            }\n          }\n        }\n\n        // If there is not enough space for the min size\n        // increment the min row sizes.\n        if (minSpanHeight < hint.minHeight)\n        {\n          var rowIncrements = qx.ui.layout.Util.computeFlexOffsets(\n            rowFlexes, hint.minHeight, minSpanHeight\n          );\n\n          for (var j=0; j<widgetProps.rowSpan; j++)\n          {\n            var offset = rowIncrements[widgetRow+j] ? rowIncrements[widgetRow+j].offset : 0;\n            rowHeights[widgetRow+j].minHeight += offset;\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Check whether all col spans fit with their preferred width into the\n     * preferred column widths. If there is not enough space the preferred\n     * column sizes are increased. The distribution respects the flex and max\n     * values of the columns.\n     *\n     *  The same is true for the min sizes.\n     *\n     *  The width array is modified in place.\n     *\n     * @param colWidths {Map[]} The current column width array as computed by\n     *     {@link #_getColWidths}.\n     */\n    _fixWidthsColSpan : function(colWidths)\n    {\n      var hSpacing = this.getSpacingX();\n\n      for (var i=0, l=this.__colSpans.length; i<l; i++)\n      {\n        var widget = this.__colSpans[i];\n\n        var hint = this.__getOuterSize(widget);\n\n        var widgetProps = widget.getLayoutProperties();\n        var widgetColumn = widgetProps.column;\n\n        var prefSpanWidth = hSpacing * (widgetProps.colSpan - 1);\n        var minSpanWidth = prefSpanWidth;\n\n        var colFlexes = {};\n\n        var offset;\n\n        for (var j=0; j<widgetProps.colSpan; j++)\n        {\n          var col = widgetProps.column+j;\n          var colWidth = colWidths[col];\n          var colFlex = this.getColumnFlex(col);\n\n          // compute flex array for the preferred width\n          if (colFlex > 0)\n          {\n            colFlexes[col] =\n            {\n              min : colWidth.minWidth,\n              value : colWidth.width,\n              max : colWidth.maxWidth,\n              flex: colFlex\n            };\n          }\n\n          prefSpanWidth += colWidth.width;\n          minSpanWidth += colWidth.minWidth;\n        }\n\n        // If there is not enough space for the preferred size\n        // increment the preferred column sizes.\n        if (prefSpanWidth < hint.width)\n        {\n          var colIncrements = qx.ui.layout.Util.computeFlexOffsets(\n            colFlexes, hint.width, prefSpanWidth\n          );\n\n          for (var j=0; j<widgetProps.colSpan; j++)\n          {\n            offset = colIncrements[widgetColumn+j] ? colIncrements[widgetColumn+j].offset : 0;\n            colWidths[widgetColumn+j].width += offset;\n          }\n        }\n\n        // If there is not enough space for the min size\n        // increment the min column sizes.\n        if (minSpanWidth < hint.minWidth)\n        {\n          var colIncrements = qx.ui.layout.Util.computeFlexOffsets(\n            colFlexes, hint.minWidth, minSpanWidth\n          );\n\n          for (var j=0; j<widgetProps.colSpan; j++)\n          {\n            offset = colIncrements[widgetColumn+j] ? colIncrements[widgetColumn+j].offset : 0;\n            colWidths[widgetColumn+j].minWidth += offset;\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Compute the min/pref/max row heights.\n     *\n     * @return {Map[]} An array containing height information for each row. The\n     *     entries have the keys <code>minHeight</code>, <code>maxHeight</code> and\n     *     <code>height</code>.\n     */\n    _getRowHeights : function()\n    {\n      if (this.__rowHeights != null) {\n        return this.__rowHeights;\n      }\n\n      var rowHeights = [];\n\n      var maxRowIndex = this.__maxRowIndex;\n      var maxColIndex = this.__maxColIndex;\n\n      for (var row=0; row<=maxRowIndex; row++)\n      {\n        var minHeight = 0;\n        var height = 0;\n        var maxHeight = 0;\n\n        for (var col=0; col<=maxColIndex; col++)\n        {\n          var widget = this.__grid[row][col];\n          if (!widget) {\n            continue;\n          }\n\n          // ignore rows with row spans at this place\n          // these rows will be taken into account later\n          var widgetRowSpan = widget.getLayoutProperties().rowSpan || 0;\n          if (widgetRowSpan > 1) {\n            continue;\n          }\n\n          var cellSize = this.__getOuterSize(widget);\n\n          if (this.getRowFlex(row) > 0) {\n            minHeight = Math.max(minHeight, cellSize.minHeight);\n          } else {\n            minHeight = Math.max(minHeight, cellSize.height);\n          }\n\n          height = Math.max(height, cellSize.height);\n        }\n\n        var minHeight = Math.max(minHeight, this.getRowMinHeight(row));\n        var maxHeight = this.getRowMaxHeight(row);\n\n        if (this.getRowHeight(row) !== null) {\n          var height = this.getRowHeight(row);\n        } else {\n          var height = Math.max(minHeight, Math.min(height, maxHeight));\n        }\n\n        rowHeights[row] = {\n          minHeight : minHeight,\n          height : height,\n          maxHeight : maxHeight\n        };\n      }\n\n      if (this.__rowSpans.length > 0) {\n        this._fixHeightsRowSpan(rowHeights);\n      }\n\n      this.__rowHeights = rowHeights;\n      return rowHeights;\n    },\n\n\n    /**\n     * Compute the min/pref/max column widths.\n     *\n     * @return {Map[]} An array containing width information for each column. The\n     *     entries have the keys <code>minWidth</code>, <code>maxWidth</code> and\n     *     <code>width</code>.\n     */\n    _getColWidths : function()\n    {\n      if (this.__colWidths != null) {\n        return this.__colWidths;\n      }\n\n      var colWidths = [];\n\n      var maxColIndex = this.__maxColIndex;\n      var maxRowIndex = this.__maxRowIndex;\n\n      for (var col=0; col<=maxColIndex; col++)\n      {\n        var width = 0;\n        var minWidth = 0;\n        var maxWidth = Infinity;\n\n        for (var row=0; row<=maxRowIndex; row++)\n        {\n          var widget = this.__grid[row][col];\n          if (!widget) {\n            continue;\n          }\n\n          // ignore columns with col spans at this place\n          // these columns will be taken into account later\n          var widgetColSpan = widget.getLayoutProperties().colSpan || 0;\n          if (widgetColSpan > 1) {\n            continue;\n          }\n\n          var cellSize = this.__getOuterSize(widget);\n\n          minWidth = Math.max(minWidth, cellSize.minWidth);\n\n          width = Math.max(width, cellSize.width);\n        }\n\n        minWidth = Math.max(minWidth, this.getColumnMinWidth(col));\n        maxWidth = this.getColumnMaxWidth(col);\n\n        if (this.getColumnWidth(col) !== null) {\n          var width = this.getColumnWidth(col);\n        } else {\n          var width = Math.max(minWidth, Math.min(width, maxWidth));\n        }\n\n        colWidths[col] = {\n          minWidth: minWidth,\n          width : width,\n          maxWidth : maxWidth\n        };\n      }\n\n      if (this.__colSpans.length > 0) {\n        this._fixWidthsColSpan(colWidths);\n      }\n\n      this.__colWidths = colWidths;\n      return colWidths;\n    },\n\n\n    /**\n     * Computes for each column by how many pixels it must grow or shrink, taking\n     * the column flex values and min/max widths into account.\n     *\n     * @param width {Integer} The grid width\n     * @return {Integer[]} Sparse array of offsets to add to each column width. If\n     *     an array entry is empty nothing should be added to the column.\n     */\n    _getColumnFlexOffsets : function(width)\n    {\n      var hint = this.getSizeHint();\n      var diff = width - hint.width;\n\n      if (diff == 0) {\n        return {};\n      }\n\n      // collect all flexible children\n      var colWidths = this._getColWidths();\n      var flexibles = {};\n\n      for (var i=0, l=colWidths.length; i<l; i++)\n      {\n        var col = colWidths[i];\n        var colFlex = this.getColumnFlex(i);\n\n        if (\n          (colFlex <= 0) ||\n          (col.width == col.maxWidth && diff > 0) ||\n          (col.width == col.minWidth && diff < 0)\n        ) {\n          continue;\n        }\n\n        flexibles[i] ={\n          min : col.minWidth,\n          value : col.width,\n          max : col.maxWidth,\n          flex : colFlex\n        };\n      }\n\n      return qx.ui.layout.Util.computeFlexOffsets(flexibles, width, hint.width);\n    },\n\n\n    /**\n     * Computes for each row by how many pixels it must grow or shrink, taking\n     * the row flex values and min/max heights into account.\n     *\n     * @param height {Integer} The grid height\n     * @return {Integer[]} Sparse array of offsets to add to each row height. If\n     *     an array entry is empty nothing should be added to the row.\n     */\n    _getRowFlexOffsets : function(height)\n    {\n      var hint = this.getSizeHint();\n      var diff = height - hint.height;\n\n      if (diff == 0) {\n        return {};\n      }\n\n      // collect all flexible children\n      var rowHeights = this._getRowHeights();\n      var flexibles = {};\n\n      for (var i=0, l=rowHeights.length; i<l; i++)\n      {\n        var row = rowHeights[i];\n        var rowFlex = this.getRowFlex(i);\n\n        if (\n          (rowFlex <= 0) ||\n          (row.height == row.maxHeight && diff > 0) ||\n          (row.height == row.minHeight && diff < 0)\n        ) {\n          continue;\n        }\n\n        flexibles[i] = {\n          min : row.minHeight,\n          value : row.height,\n          max : row.maxHeight,\n          flex : rowFlex\n        };\n      }\n\n      return qx.ui.layout.Util.computeFlexOffsets(flexibles, height, hint.height);\n    },\n\n\n    // overridden\n    renderLayout : function(availWidth, availHeight, padding)\n    {\n      if (this._invalidChildrenCache) {\n        this.__buildGrid();\n      }\n\n      var Util = qx.ui.layout.Util;\n      var hSpacing = this.getSpacingX();\n      var vSpacing = this.getSpacingY();\n\n      // calculate column widths\n      var prefWidths = this._getColWidths();\n      var colStretchOffsets = this._getColumnFlexOffsets(availWidth);\n\n      var colWidths = [];\n\n      var maxColIndex = this.__maxColIndex;\n      var maxRowIndex = this.__maxRowIndex;\n\n      var offset;\n\n      for (var col=0; col<=maxColIndex; col++)\n      {\n        offset = colStretchOffsets[col] ? colStretchOffsets[col].offset : 0;\n        colWidths[col] = prefWidths[col].width + offset;\n      }\n\n      // calculate row heights\n      var prefHeights = this._getRowHeights();\n      var rowStretchOffsets = this._getRowFlexOffsets(availHeight);\n\n      var rowHeights = [];\n\n      for (var row=0; row<=maxRowIndex; row++)\n      {\n        offset = rowStretchOffsets[row] ? rowStretchOffsets[row].offset : 0;\n        rowHeights[row] = prefHeights[row].height + offset;\n      }\n\n      // do the layout\n      var left = 0;\n      for (var col=0; col<=maxColIndex; col++)\n      {\n        var top = 0;\n\n        for (var row=0; row<=maxRowIndex; row++)\n        {\n          var widget = this.__grid[row][col];\n\n          // ignore empty cells\n          if (!widget)\n          {\n            top += rowHeights[row] + vSpacing;\n            continue;\n          }\n\n          var widgetProps = widget.getLayoutProperties();\n\n          // ignore cells, which have cell spanning but are not the origin\n          // of the widget\n          if(widgetProps.row !== row || widgetProps.column !== col)\n          {\n            top += rowHeights[row] + vSpacing;\n            continue;\n          }\n\n          // compute sizes width including cell spanning\n          var spanWidth = hSpacing * (widgetProps.colSpan - 1);\n          for (var i=0; i<widgetProps.colSpan; i++) {\n            spanWidth += colWidths[col+i];\n          }\n\n          var spanHeight = vSpacing * (widgetProps.rowSpan - 1);\n          for (var i=0; i<widgetProps.rowSpan; i++) {\n            spanHeight += rowHeights[row+i];\n          }\n\n          var cellHint = widget.getSizeHint();\n          var marginTop = widget.getMarginTop();\n          var marginLeft = widget.getMarginLeft();\n          var marginBottom = widget.getMarginBottom();\n          var marginRight = widget.getMarginRight();\n\n          var cellWidth = Math.max(cellHint.minWidth, Math.min(spanWidth-marginLeft-marginRight, cellHint.maxWidth));\n          var cellHeight = Math.max(cellHint.minHeight, Math.min(spanHeight-marginTop-marginBottom, cellHint.maxHeight));\n\n          var cellAlign = this.getCellAlign(row, col);\n          var cellLeft = left + Util.computeHorizontalAlignOffset(cellAlign.hAlign, cellWidth, spanWidth, marginLeft, marginRight);\n          var cellTop = top + Util.computeVerticalAlignOffset(cellAlign.vAlign, cellHeight, spanHeight, marginTop, marginBottom);\n\n          widget.renderLayout(\n            cellLeft + padding.left,\n            cellTop + padding.top,\n            cellWidth,\n            cellHeight\n          );\n\n          top += rowHeights[row] + vSpacing;\n        }\n\n        left += colWidths[col] + hSpacing;\n      }\n    },\n\n\n    // overridden\n    invalidateLayoutCache : function()\n    {\n      this.base(arguments);\n\n      this.__colWidths = null;\n      this.__rowHeights = null;\n    },\n\n\n    // overridden\n    _computeSizeHint : function()\n    {\n      if (this._invalidChildrenCache) {\n        this.__buildGrid();\n      }\n\n      // calculate col widths\n      var colWidths = this._getColWidths();\n\n      var minWidth=0, width=0;\n\n      for (var i=0, l=colWidths.length; i<l; i++)\n      {\n        var col = colWidths[i];\n        if (this.getColumnFlex(i) > 0) {\n          minWidth += col.minWidth;\n        } else {\n          minWidth += col.width;\n        }\n\n        width += col.width;\n      }\n\n      // calculate row heights\n      var rowHeights = this._getRowHeights();\n\n      var minHeight=0, height=0;\n      for (var i=0, l=rowHeights.length; i<l; i++)\n      {\n        var row = rowHeights[i];\n\n        if (this.getRowFlex(i) > 0) {\n          minHeight += row.minHeight;\n        } else {\n          minHeight += row.height;\n        }\n\n        height += row.height;\n      }\n\n      var spacingX = this.getSpacingX() * (colWidths.length - 1);\n      var spacingY = this.getSpacingY() * (rowHeights.length - 1);\n\n      var hint = {\n        minWidth : minWidth + spacingX,\n        width : width + spacingX,\n        minHeight : minHeight + spacingY,\n        height : height + spacingY\n      };\n\n      return hint;\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     DESTRUCT\n  *****************************************************************************\n  */\n\n  destruct : function()\n  {\n    this.__grid = this.__rowData = this.__colData = this.__colSpans =\n      this.__rowSpans = this.__colWidths = this.__rowHeights = null;\n  }\n});\n"
  ]
}