{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/data/SingleValueBinding.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__bindings",
    "__bindingsByTarget",
    "bind",
    "sourceObject",
    "sourcePropertyChain",
    "targetObject",
    "targetPropertyChain",
    "options",
    "core",
    "Assert",
    "assertObject",
    "assertString",
    "targetListenerMap",
    "__setUpTargetBinding",
    "propertyNames",
    "split",
    "arrayIndexValues",
    "__checkForArrayInPropertyChain",
    "sources",
    "listeners",
    "listenerIds",
    "eventNames",
    "source",
    "initialPromise",
    "i",
    "length",
    "push",
    "eventName",
    "__getEventNameForProperty",
    "AssertionError",
    "__setInitialValue",
    "undefined",
    "itemIndex",
    "currentValue",
    "getItem",
    "__bindEventToProperty",
    "lang",
    "String",
    "firstUp",
    "context",
    "index",
    "listener",
    "Function",
    "__chainListener",
    "addListener",
    "ex",
    "removeListenerById",
    "targets",
    "targetIds",
    "id",
    "type",
    "targetListenerIds",
    "__storeBinding",
    "onUpdate",
    "j",
    "converter",
    "ignoreConverter",
    "currentSourceChain",
    "slice",
    "join",
    "match",
    "RegExp",
    "__setTargetValue",
    "__resetTargetValue",
    "implementsInterface",
    "data",
    "IListData",
    "target",
    "firstUpPropName",
    "currentIndex",
    "getLength",
    "SingleValueBinding",
    "updateTarget",
    "value",
    "resolvePropertyChain",
    "__convertValue",
    "o",
    "propertyChain",
    "properties",
    "__getPropertyChainArray",
    "__getTargetFromChain",
    "propertyName",
    "__getEventForProperty",
    "supportsEvent",
    "constructor",
    "lastProperty",
    "__getArrayIndex",
    "setItem",
    "arrayExp",
    "arrayMatch",
    "replace",
    "filter",
    "prop",
    "targetProperties",
    "property",
    "arrIndex",
    "result",
    "e",
    "ValidationError",
    "onSetFail",
    "log",
    "Logger",
    "warn",
    "name",
    "endsWith",
    "arrayIndex",
    "substring",
    "indexOf",
    "Error",
    "isNaN",
    "parseInt",
    "splice",
    "sourceEvent",
    "targetProperty",
    "eventType",
    "getEventType",
    "assertEquals",
    "bindListener",
    "start",
    "getData",
    "end",
    "hash",
    "toHashCode",
    "binding",
    "model",
    "getModel",
    "lastIndexOf",
    "propertieDefinition",
    "getPropertyDefinition",
    "check",
    "__defaultConversion",
    "sourceProperty",
    "event",
    "targetCheck",
    "dataType",
    "Type",
    "getClass",
    "parseFloat",
    "removeBindingFromObject",
    "bindings",
    "getAllBindingsForObject",
    "Array",
    "remove",
    "removeAllBindingsForObject",
    "object",
    "assertNotNull",
    "removeRelatedBindings",
    "relatedObject",
    "sourceBindings",
    "targetBindings",
    "unique",
    "concat",
    "removeAllBindings",
    "ObjectRegistry",
    "fromHashCode",
    "getAllBindings",
    "showBindingInLog",
    "message",
    "debug",
    "showAllBindingsInLog"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAAA,KAAGC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC,EAqBAH,GAAGI,KAAH,CAASC,MAAT,CAAgB,4BAAhB,EACA;;AAEEC,aACA;AACE;AACAC,kBAAY,EAFd;;AAIE;AACAC,0BAAqB,EALvB;;AAQE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoFAC,YAAO,cACLC,YADK,EACSC,mBADT,EAC8BC,YAD9B,EAC4CC,mBAD5C,EACiEC,OADjE,EAGP;AACE;AACyC;AACvCd,aAAGe,IAAH,CAAQC,MAAR,CAAeC,YAAf,CAA4BP,YAA5B,EAA0C,cAA1C;AACAV,aAAGe,IAAH,CAAQC,MAAR,CAAeE,YAAf,CAA4BP,mBAA5B,EAAiD,qBAAjD;AACAX,aAAGe,IAAH,CAAQC,MAAR,CAAeC,YAAf,CAA4BL,YAA5B,EAA0C,cAA1C;AACAZ,aAAGe,IAAH,CAAQC,MAAR,CAAeE,YAAf,CAA4BL,mBAA5B,EAAiD,qBAAjD;AACD;;AAED;AACA,YAAIM,oBAAoB,KAAKC,oBAAL,CACtBV,YADsB,EACRC,mBADQ,EACaC,YADb,EAC2BC,mBAD3B,EACgDC,OADhD,CAAxB;;AAIA;AACA,YAAIO,gBAAgBV,oBAAoBW,KAApB,CAA0B,GAA1B,CAApB;;AAEA;AACA,YAAIC,mBACF,KAAKC,8BAAL,CAAoCH,aAApC,CADF;AAEA,YAAII,UAAU,EAAd;AACA,YAAIC,YAAY,EAAhB;AACA,YAAIC,cAAc,EAAlB;AACA,YAAIC,aAAa,EAAjB;AACA,YAAIC,SAASnB,YAAb;AACA,YAAIoB,iBAAiB,IAArB;;AAEA;AACA;AACA,YAAI;AACF;AACA,eAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIV,cAAcW,MAAlC,EAA0CD,GAA1C,EAA+C;AAC7C;AACA,gBAAIR,iBAAiBQ,CAAjB,MAAwB,EAA5B,EAAgC;AAC9B;AACAH,yBAAWK,IAAX,CAAgB,QAAhB;AACD,aAHD,MAGO;AACL,kBAAIC,YAAY,KAAKC,yBAAL,CAA+BN,MAA/B,EAAuCR,cAAcU,CAAd,CAAvC,CAAhB;AACA,kBAAI,CAACG,SAAL,EAAgB;AACd,oBAAIH,KAAK,CAAT,EAAY;AAAE;AACZ,wBAAM,IAAI/B,GAAGe,IAAH,CAAQqB,cAAZ,CACJ,sBAAsBf,cAAcU,CAAd,CAAtB,GAAyC,aAAzC,GAAyDF,MAAzD,GACA,qCAFI,CAAN;AAID;AACD;AACAC,iCAAiB,KAAKO,iBAAL,CAAuBC,SAAvB,EAAkC1B,YAAlC,EAAgDC,mBAAhD,EAAqEC,OAArE,EAA8EJ,YAA9E,CAAjB;AACA;AACD;AACDkB,yBAAWK,IAAX,CAAgBC,SAAhB;AACD;;AAED;AACAT,oBAAQM,CAAR,IAAaF,MAAb;;AAEA;AACA,gBAAIE,KAAKV,cAAcW,MAAd,GAAsB,CAA/B,EAAkC;AAChC;AACA,kBAAIT,iBAAiBQ,CAAjB,MAAwB,EAA5B,EAAgC;AAC9B;AACA,oBAAIQ,YAAYhB,iBAAiBQ,CAAjB,MAAwB,MAAxB,GACdF,OAAOG,MAAP,GAAgB,CADF,GACMT,iBAAiBQ,CAAjB,CADtB;AAEA,oBAAIS,eAAeX,OAAOY,OAAP,CAAeF,SAAf,CAAnB;;AAEA;AACAT,iCAAiB,KAAKO,iBAAL,CAAuBG,YAAvB,EAAqC5B,YAArC,EAAmDC,mBAAnD,EAAwEC,OAAxE,EAAiFJ,YAAjF,CAAjB;;AAEA;AACAiB,4BAAYI,CAAZ,IAAiB,KAAKW,qBAAL,CACfb,MADe,EACPD,WAAWG,CAAX,CADO,EACQnB,YADR,EACsBC,mBADtB,EAC2CC,OAD3C,EACoDS,iBAAiBQ,CAAjB,CADpD,CAAjB;AAGD,eAbD,MAaO;AACL;AACA,oBAAIV,cAAcU,CAAd,KAAoB,IAApB,IAA4BF,OAAO,QAAQ7B,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBxB,cAAcU,CAAd,CAAvB,CAAf,KAA4D,IAA5F,EAAkG;AAChG,sBAAIS,eAAeX,OAAO,QAAQ7B,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBxB,cAAcU,CAAd,CAAvB,CAAf,GAAnB;AACAD,mCAAiB,KAAKO,iBAAL,CAAuBG,YAAvB,EAAqC5B,YAArC,EAAmDC,mBAAnD,EAAwEC,OAAxE,EAAiFJ,YAAjF,CAAjB;AACD;AACD;AACAiB,4BAAYI,CAAZ,IAAiB,KAAKW,qBAAL,CACfb,MADe,EACPD,WAAWG,CAAX,CADO,EACQnB,YADR,EACsBC,mBADtB,EAC2CC,OAD3C,CAAjB;AAGD;;AAEH;AACC,aA5BD,MA4BO;;AAEL;AACA,kBAAIgC,UAAU;AACZC,uBAAOhB,CADK;AAEZV,+BAAeA,aAFH;AAGZI,yBAASA,OAHG;AAIZE,6BAAaA,WAJD;AAKZJ,kCAAkBA,gBALN;AAMZX,8BAAcA,YANF;AAOZC,qCAAqBA,mBAPT;AAQZC,yBAASA,OARG;AASZY,2BAAWA;AATC,eAAd;;AAYA;AACA,kBAAIsB,WAAWhD,GAAG2C,IAAH,CAAQM,QAAR,CAAiBxC,IAAjB,CAAsB,KAAKyC,eAA3B,EAA4C,IAA5C,EAAkDJ,OAAlD,CAAf;;AAEA;AACApB,wBAAUO,IAAV,CAAee,QAAf;;AAEA;AACArB,0BAAYI,CAAZ,IAAiBF,OAAOsB,WAAP,CAAmBvB,WAAWG,CAAX,CAAnB,EAAkCiB,QAAlC,CAAjB;AACD;;AAED;AACA,gBAAInB,OAAO,QAAQ7B,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBxB,cAAcU,CAAd,CAAvB,CAAf,KAA4D,IAAhE,EAAsE;AACpEF,uBAASS,SAAT;AACD,aAFD,MAEO,IAAIf,iBAAiBQ,CAAjB,MAAwB,EAA5B,EAAgC;AACrC,kBAAIQ,YAAYhB,iBAAiBQ,CAAjB,MAAwB,MAAxB,GACdF,OAAOG,MAAP,GAAgB,CADF,GACMT,iBAAiBQ,CAAjB,CADtB;AAEAF,uBAASA,OAAO,QAAQ7B,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBxB,cAAcU,CAAd,CAAvB,CAAf,EAAyDQ,SAAzD,CAAT;AACD,aAJM,MAIA;AACLV,uBAASA,OAAO,QAAQ7B,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBxB,cAAcU,CAAd,CAAvB,CAAf,GAAT;AACA;AACA,kBAAIF,WAAW,IAAX,IAAoBR,cAAcW,MAAd,GAAuB,CAAxB,IAA8BD,CAArD,EAAwD;AACtDF,yBAASS,SAAT;AACD;AACF;AACD,gBAAI,CAACT,MAAL,EAAa;AACX;AACA,mBAAKQ,iBAAL,CAAuBR,MAAvB,EAA+BjB,YAA/B,EAA6CC,mBAA7C,EAAkEC,OAAlE,EAA2EJ,YAA3E;AACA;AACD;AACF;AAEF,SArGD,CAqGE,OAAO0C,EAAP,EAAW;AACX;AACA;;AAEA,eAAK,IAAIrB,IAAI,CAAb,EAAgBA,IAAIN,QAAQO,MAA5B,EAAoCD,GAApC,EAAyC;AACvC;AACA,gBAAIN,QAAQM,CAAR,KAAcJ,YAAYI,CAAZ,CAAlB,EAAkC;AAChCN,sBAAQM,CAAR,EAAWsB,kBAAX,CAA8B1B,YAAYI,CAAZ,CAA9B;AACD;AACF;AACD,cAAIuB,UAAUnC,kBAAkBmC,OAAhC;AACA,cAAIC,YAAYpC,kBAAkBQ,WAAlC;AACA;AACA,eAAK,IAAII,IAAI,CAAb,EAAgBA,IAAIuB,QAAQtB,MAA5B,EAAoCD,GAApC,EAAyC;AACvC;AACA,gBAAIuB,QAAQvB,CAAR,KAAcwB,UAAUxB,CAAV,CAAlB,EAAgC;AAC9BuB,sBAAQvB,CAAR,EAAWsB,kBAAX,CAA8BE,UAAUxB,CAAV,CAA9B;AACD;AACF;;AAED,gBAAMqB,EAAN;AACD;;AAED;AACA,YAAII,KAAK;AACPC,gBAAM,aADC;AAEP9B,uBAAaA,WAFN;AAGPF,mBAASA,OAHF;AAIPiC,6BAAmBvC,kBAAkBQ,WAJ9B;AAKP2B,mBAASnC,kBAAkBmC,OALpB;AAMPxB,0BAAgBA;AANT,SAAT;AAQA;AACA,aAAK6B,cAAL,CACEH,EADF,EACM9C,YADN,EACoBC,mBADpB,EACyCC,YADzC,EACuDC,mBADvD;;AAIA,eAAO2C,EAAP;AACD,OAvQH;;AA0QE;;;;;AAKAN,uBAAkB,yBAASJ,OAAT,EAClB;AACE;AACA,YAAIA,QAAQhC,OAAR,IAAmBgC,QAAQhC,OAAR,CAAgB8C,QAAvC,EAAiD;AAC/Cd,kBAAQhC,OAAR,CAAgB8C,QAAhB,CACEd,QAAQrB,OAAR,CAAgBqB,QAAQC,KAAxB,CADF,EACkCD,QAAQlC,YAD1C;AAGD;;AAED;AACA,aAAK,IAAIiD,IAAIf,QAAQC,KAAR,GAAgB,CAA7B,EAAgCc,IAAIf,QAAQzB,aAAR,CAAsBW,MAA1D,EAAkE6B,GAAlE,EAAuE;AACrE;AACA,cAAIhC,SAASiB,QAAQrB,OAAR,CAAgBoC,CAAhB,CAAb;AACAf,kBAAQrB,OAAR,CAAgBoC,CAAhB,IAAqB,IAArB;AACA,cAAI,CAAChC,MAAL,EAAa;AACX;AACD;;AAED;AACAA,iBAAOwB,kBAAP,CAA0BP,QAAQnB,WAAR,CAAoBkC,CAApB,CAA1B;AACD;;AAED;AACA,YAAIhC,SAASiB,QAAQrB,OAAR,CAAgBqB,QAAQC,KAAxB,CAAb;AACA;AACA,aAAK,IAAIc,IAAIf,QAAQC,KAAR,GAAgB,CAA7B,EAAgCc,IAAIf,QAAQzB,aAAR,CAAsBW,MAA1D,EAAkE6B,GAAlE,EAAuE;AACrE;AACA,cAAIf,QAAQvB,gBAAR,CAAyBsC,IAAI,CAA7B,MAAoC,EAAxC,EAA4C;AAC1ChC,qBAASA,OAAO,QAAQ7B,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBC,QAAQzB,aAAR,CAAsBwC,IAAI,CAA1B,CAAvB,CAAf,EAAqEf,QAAQvB,gBAAR,CAAyBsC,IAAI,CAA7B,CAArE,CAAT;AACD,WAFD,MAEO;AACLhC,qBAASA,OAAO,QAAQ7B,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBC,QAAQzB,aAAR,CAAsBwC,IAAI,CAA1B,CAAvB,CAAf,GAAT;AACD;AACDf,kBAAQrB,OAAR,CAAgBoC,CAAhB,IAAqBhC,MAArB;AACA;AACA,cAAI,CAACA,MAAL,EAAa;AACX;AACA,gBAAIiB,QAAQhC,OAAR,IAAmBgC,QAAQhC,OAAR,CAAgBgD,SAAvC,EAAkD;;AAEhD,kBAAIC,kBAAkB,KAAtB;AACA;AACA,kBAAIjB,QAAQhC,OAAR,CAAgBiD,eAApB,EAAqC;AACnC;AACA,oBAAIC,qBAAqBlB,QAAQzB,aAAR,CAAsB4C,KAAtB,CAA4B,CAA5B,EAA8BJ,CAA9B,EAAiCK,IAAjC,CAAsC,GAAtC,CAAzB;AACA;AACA,oBAAIC,QAAQH,mBAAmBG,KAAnB,CACV,IAAIC,MAAJ,CAAW,MAAMtB,QAAQhC,OAAR,CAAgBiD,eAAjC,CADU,CAAZ;AAGAA,kCAAkBI,QAAQA,MAAMnC,MAAN,GAAe,CAAvB,GAA2B,KAA7C;AACD;;AAED,kBAAI,CAAC+B,eAAL,EAAsB;AACpB,qBAAKM,gBAAL,CACEvB,QAAQlC,YADV,EAEEkC,QAAQjC,mBAFV,EAGEiC,QAAQhC,OAAR,CAAgBgD,SAAhB,EAHF;AAKD,eAND,MAMO;AACL,qBAAKQ,kBAAL,CAAwBxB,QAAQlC,YAAhC,EAA8CkC,QAAQjC,mBAAtD;AACD;AACF,aAvBD,MAuBO;AACL,mBAAKyD,kBAAL,CAAwBxB,QAAQlC,YAAhC,EAA8CkC,QAAQjC,mBAAtD;AACD;;AAED;AACD;;AAED;AACA,cAAIgD,KAAKf,QAAQzB,aAAR,CAAsBW,MAAtB,GAA+B,CAAxC,EAA2C;AACzC;AACA,gBAAIhC,GAAGI,KAAH,CAASmE,mBAAT,CAA6B1C,MAA7B,EAAqC7B,GAAGwE,IAAH,CAAQC,SAA7C,CAAJ,EAA6D;AAC3D;AACA,kBAAIlC,YAAYO,QAAQvB,gBAAR,CAAyBsC,CAAzB,MAAgC,MAAhC,GACdhC,OAAOG,MAAP,GAAgB,CADF,GACMc,QAAQvB,gBAAR,CAAyBsC,CAAzB,CADtB;AAEA,kBAAIrB,eAAeX,OAAOY,OAAP,CAAeF,SAAf,CAAnB;AACA,mBAAKF,iBAAL,CACEG,YADF,EACgBM,QAAQlC,YADxB,EACsCkC,QAAQjC,mBAD9C,EACmEiC,QAAQhC,OAD3E,EACoFgC,QAAQrB,OAAR,CAAgBqB,QAAQC,KAAxB,CADpF;;AAIA;AACAD,sBAAQnB,WAAR,CAAoBkC,CAApB,IAAyB,KAAKnB,qBAAL,CACvBb,MADuB,EACf,QADe,EACLiB,QAAQlC,YADH,EACiBkC,QAAQjC,mBADzB,EAC8CiC,QAAQhC,OADtD,EAC+DgC,QAAQvB,gBAAR,CAAyBsC,CAAzB,CAD/D,CAAzB;AAID,aAdD,MAcO;AACL,kBAAIf,QAAQzB,aAAR,CAAsBwC,CAAtB,KAA4B,IAA5B,IAAoChC,OAAO,QAAQ7B,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBC,QAAQzB,aAAR,CAAsBwC,CAAtB,CAAvB,CAAf,KAAoE,IAA5G,EAAkH;AAChH,oBAAIrB,eAAeX,OAAO,QAAQ7B,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBC,QAAQzB,aAAR,CAAsBwC,CAAtB,CAAvB,CAAf,GAAnB;AACA,qBAAKxB,iBAAL,CAAuBG,YAAvB,EAAqCM,QAAQlC,YAA7C,EAA2DkC,QAAQjC,mBAAnE,EAAwFiC,QAAQhC,OAAhG,EAAyGgC,QAAQrB,OAAR,CAAgBqB,QAAQC,KAAxB,CAAzG;AACD;AACD,kBAAIb,YAAY,KAAKC,yBAAL,CAA+BN,MAA/B,EAAuCiB,QAAQzB,aAAR,CAAsBwC,CAAtB,CAAvC,CAAhB;AACA,kBAAI,CAAC3B,SAAL,EAAgB;AACdY,wBAAQrB,OAAR,CAAgBoC,CAAhB,IAAqB,IAArB;AACA,qBAAKS,kBAAL,CAAwBxB,QAAQlC,YAAhC,EAA8CkC,QAAQjC,mBAAtD;AACA;AACD;AACD;AACAiC,sBAAQnB,WAAR,CAAoBkC,CAApB,IAAyB,KAAKnB,qBAAL,CACvBb,MADuB,EACfK,SADe,EACJY,QAAQlC,YADJ,EACkBkC,QAAQjC,mBAD1B,EAC+CiC,QAAQhC,OADvD,CAAzB;AAGD;AACF,WAhCD,MAgCO;AACL;AACA,gBAAIgC,QAAQpB,SAAR,CAAkBmC,CAAlB,KAAwB,IAA5B,EAAkC;AAChC,kBAAIb,WAAWhD,GAAG2C,IAAH,CAAQM,QAAR,CAAiBxC,IAAjB,CAAsB,KAAKyC,eAA3B,EAA4C,IAA5C,EAAkDJ,OAAlD,CAAf;AACA;AACAA,sBAAQpB,SAAR,CAAkBO,IAAlB,CAAuBe,QAAvB;AACD;AACD;AACA,gBAAIhD,GAAGI,KAAH,CAASmE,mBAAT,CAA6B1C,MAA7B,EAAqC7B,GAAGwE,IAAH,CAAQC,SAA7C,CAAJ,EAA6D;AAC3D,kBAAIvC,YAAY,QAAhB;AACD,aAFD,MAEO;AACL,kBAAIA,YAAY,KAAKC,yBAAL,CAA+BN,MAA/B,EAAuCiB,QAAQzB,aAAR,CAAsBwC,CAAtB,CAAvC,CAAhB;AACD;;AAED,gBAAI,CAAC3B,SAAL,EAAgB;AACdY,sBAAQrB,OAAR,CAAgBoC,CAAhB,IAAqB,IAArB;AACA,mBAAKS,kBAAL,CAAwBxB,QAAQlC,YAAhC,EAA8CkC,QAAQjC,mBAAtD;AACA;AACD;AACDiC,oBAAQnB,WAAR,CAAoBkC,CAApB,IAAyBhC,OAAOsB,WAAP,CAAmBjB,SAAnB,EAA8BY,QAAQpB,SAAR,CAAkBmC,CAAlB,CAA9B,CAAzB;AACD;AACF;AACF,OAxYH;;AA2YE;;;;;;;;;;;;;;;;AAgBAzC,4BAAuB,8BACrBV,YADqB,EACPC,mBADO,EACcC,YADd,EAC4BC,mBAD5B,EACiDC,OADjD,EAErB;AACA;AACA,YAAIO,gBAAgBR,oBAAoBS,KAApB,CAA0B,GAA1B,CAApB;;AAEA,YAAIC,mBACF,KAAKC,8BAAL,CAAoCH,aAApC,CADF;AAEA,YAAIiC,UAAU,EAAd;AACA,YAAI5B,YAAY,EAAhB;AACA,YAAIC,cAAc,EAAlB;AACA,YAAIC,aAAa,EAAjB;AACA,YAAI8C,SAAS9D,YAAb;;AAEA;AACA,aAAK,IAAImB,IAAI,CAAb,EAAgBA,IAAIV,cAAcW,MAAd,GAAuB,CAA3C,EAA8CD,GAA9C,EAAmD;AACjD;AACA,cAAIR,iBAAiBQ,CAAjB,MAAwB,EAA5B,EAAgC;AAC9B;AACAH,uBAAWK,IAAX,CAAgB,QAAhB;AACD,WAHD,MAGO;AACL,gBAAIC,YAAY,KAAKC,yBAAL,CAA+BuC,MAA/B,EAAuCrD,cAAcU,CAAd,CAAvC,CAAhB;AACA,gBAAI,CAACG,SAAL,EAAgB;AACd;AACA;AACA;AACD;AACDN,uBAAWK,IAAX,CAAgBC,SAAhB;AACD;;AAED;AACAoB,kBAAQvB,CAAR,IAAa2C,MAAb;;AAEA;AACA,cAAI1B,WAAW,SAAXA,QAAW,GAAW;AACxB;AACA,iBAAK,IAAIa,IAAI9B,IAAI,CAAjB,EAAoB8B,IAAIxC,cAAcW,MAAd,GAAuB,CAA/C,EAAkD6B,GAAlD,EAAuD;AACrD;AACA,kBAAIa,SAASpB,QAAQO,CAAR,CAAb;AACAP,sBAAQO,CAAR,IAAa,IAAb;AACA,kBAAI,CAACa,MAAL,EAAa;AACX;AACD;;AAED;AACAA,qBAAOrB,kBAAP,CAA0B1B,YAAYkC,CAAZ,CAA1B;AACD;;AAED;AACA,gBAAIa,SAASpB,QAAQvB,CAAR,CAAb;AACA;AACA,iBAAK,IAAI8B,IAAI9B,IAAI,CAAjB,EAAoB8B,IAAIxC,cAAcW,MAAd,GAAuB,CAA/C,EAAkD6B,GAAlD,EAAuD;;AAErD,kBAAIc,kBAAkB3E,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBxB,cAAcwC,IAAI,CAAlB,CAAvB,CAAtB;AACA;AACA,kBAAItC,iBAAiBsC,IAAI,CAArB,MAA4B,EAAhC,EAAoC;AAClC,oBAAIe,eAAerD,iBAAiBsC,IAAI,CAArB,MAA4B,MAA5B,GACjBa,OAAOG,SAAP,KAAqB,CADJ,GACQtD,iBAAiBsC,IAAI,CAArB,CAD3B;AAEAa,yBAASA,OAAO,QAAQC,eAAf,EAAgCC,YAAhC,CAAT;AACD,eAJD,MAIO;AACLF,yBAASA,OAAO,QAAQC,eAAf,GAAT;AACD;AACDrB,sBAAQO,CAAR,IAAaa,MAAb;AACA,kBAAI,CAACA,MAAL,EAAa;AACX;AACD;;AAED;AACA,kBAAIhD,UAAUmC,CAAV,KAAgB,IAApB,EAA0B;AACxB;AACAnC,0BAAUO,IAAV,CAAee,QAAf;AACD;;AAED;AACA,kBAAIhD,GAAGI,KAAH,CAASmE,mBAAT,CAA6BG,MAA7B,EAAqC1E,GAAGwE,IAAH,CAAQC,SAA7C,CAAJ,EAA6D;AAC3D,oBAAIvC,YAAY,QAAhB;AACD,eAFD,MAEO;AACL,oBAAIA,YACFlC,GAAGwE,IAAH,CAAQM,kBAAR,CAA2B3C,yBAA3B,CACEuC,MADF,EACUrD,cAAcwC,CAAd,CADV,CADF;AAIA,oBAAI,CAAC3B,SAAL,EAAgB;AACd;AACA;AACA;AACD;AACF;;AAEDP,0BAAYkC,CAAZ,IAAiBa,OAAOvB,WAAP,CAAmBjB,SAAnB,EAA8BR,UAAUmC,CAAV,CAA9B,CAAjB;AACA;;AAEF7D,eAAGwE,IAAH,CAAQM,kBAAR,CAA2BC,YAA3B,CACErE,YADF,EACgBC,mBADhB,EACqCC,YADrC,EACmDC,mBADnD,EACwEC,OADxE;AAGD,WA5DD;;AA8DA;AACAY,oBAAUO,IAAV,CAAee,QAAf;;AAEA;AACArB,sBAAYI,CAAZ,IAAiB2C,OAAOvB,WAAP,CAAmBvB,WAAWG,CAAX,CAAnB,EAAkCiB,QAAlC,CAAjB;;AAEA,cAAI2B,kBAAkB3E,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBxB,cAAcU,CAAd,CAAvB,CAAtB;AACA;AACA,cAAI2C,OAAO,QAAQC,eAAf,KAAmC,IAAvC,EAA6C;AAC3CD,qBAAS,IAAT;AACD,WAFD,MAEO,IAAInD,iBAAiBQ,CAAjB,MAAwB,EAA5B,EAAgC;AACrC2C,qBAASA,OAAO,QAAQC,eAAf,EAAgCpD,iBAAiBQ,CAAjB,CAAhC,CAAT;AACD,WAFM,MAEA;AACL2C,qBAASA,OAAO,QAAQC,eAAf,GAAT;AACD;AACD,cAAI,CAACD,MAAL,EAAa;AACX;AACD;AACF;;AAED,eAAO,EAAC/C,aAAaA,WAAd,EAA2B2B,SAASA,OAApC,EAAP;AACD,OAhhBH;;AAmhBE;;;;;;;;;;;;;;;;AAgBAyB,oBAAe,sBACbrE,YADa,EACCC,mBADD,EACsBC,YADtB,EACoCC,mBADpC,EACyDC,OADzD,EAGf;AACE,YAAIkE,QAAQ,KAAKC,oBAAL,CAA0BvE,YAA1B,EAAwCC,mBAAxC,CAAZ;;AAEA;AACAqE,gBAAQhF,GAAGwE,IAAH,CAAQM,kBAAR,CAA2BI,cAA3B,CACNF,KADM,EACCpE,YADD,EACeC,mBADf,EACoCC,OADpC,EAC6CJ,YAD7C,CAAR;;AAIA,aAAK2D,gBAAL,CAAsBzD,YAAtB,EAAoCC,mBAApC,EAAyDmE,KAAzD;AACD,OA/iBH;;AAkjBE;;;;;;;;AAQAC,4BAAuB,8BAASE,CAAT,EAAYC,aAAZ,EAA2B;AAChD,YAAIC,aAAa,KAAKC,uBAAL,CAA6BF,aAA7B,CAAjB;AACA,eAAO,KAAKG,oBAAL,CAA0BJ,CAA1B,EAA6BE,UAA7B,EAAyCA,WAAWrD,MAApD,CAAP;AACD,OA7jBH;;AAgkBE;;;;;;;;;;;;;AAaAG,iCAA4B,mCAASN,MAAT,EAAiB2D,YAAjB,EAC5B;AACE;AACA,YAAItD,YAAY,KAAKuD,qBAAL,CAA2B5D,MAA3B,EAAmC2D,YAAnC,CAAhB;AACA;AACA,YAAItD,aAAa,IAAjB,EAAuB;AACrB;AACA,cAAIlC,GAAGI,KAAH,CAASsF,aAAT,CAAuB7D,OAAO8D,WAA9B,EAA2CH,YAA3C,CAAJ,EAA8D;AAC5DtD,wBAAYsD,YAAZ;AACF;AACC,WAHD,MAGO,IAAIxF,GAAGI,KAAH,CAASsF,aAAT,CACT7D,OAAO8D,WADE,EACW,WAAW3F,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuB2C,YAAvB,CADtB,CAAJ,EAEL;AACAtD,wBAAY,WAAWlC,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuB2C,YAAvB,CAAvB;AACD,WAJM,MAIA;AACL,mBAAO,IAAP;AACD;AACF;AACD,eAAOtD,SAAP;AACD,OAhmBH;;AAmmBE;;;;;;;;;AASAoC,0BAAqB,4BAAS1D,YAAT,EAAuBC,mBAAvB,EACrB;AACE;AACA,YAAIwE,aAAa,KAAKC,uBAAL,CAA6BzE,mBAA7B,CAAjB;AACA,YAAI6D,SAAS,KAAKa,oBAAL,CAA0B3E,YAA1B,EAAwCyE,UAAxC,CAAb;AACA,YAAIX,UAAU,IAAd,EAAoB;AAClB;AACA,cAAIkB,eAAeP,WAAWA,WAAWrD,MAAX,GAAoB,CAA/B,CAAnB;AACA;AACA,cAAIe,QAAQ,KAAK8C,eAAL,CAAqBD,YAArB,CAAZ;AACA,cAAI7C,KAAJ,EAAW;AACT,iBAAKsB,gBAAL,CAAsBzD,YAAtB,EAAoCC,mBAApC,EAAyD,IAAzD;AACA;AACD;;AAED;AACA,cAAI6D,OAAO,UAAU1E,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuB+C,YAAvB,CAAjB,KAA0DtD,SAA9D,EAAyE;AACvEoC,mBAAO,UAAU1E,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuB+C,YAAvB,CAAjB;AACD,WAFD,MAEO;AACL;AACA,gBAAI,OAAOlB,OAAO,QAAQ1E,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuB+C,YAAvB,CAAf,CAAP,IAA+D,UAAnE,EAA+E;AAC7E,oBAAM,IAAI5F,GAAGe,IAAH,CAAQqB,cAAZ,CAA2B,oBAAoBwD,YAApB,GAAmC,cAAnC,GAAoDlB,MAApD,GAA6D,GAAxF,CAAN;AACD;AACDA,mBAAO,QAAQ1E,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuB+C,YAAvB,CAAf,EAAqD,IAArD;AACD;AACF;AACF,OAtoBH;;AAyoBE;;;;;;;;;;AAUAvB,wBAAmB,0BAASzD,YAAT,EAAuBC,mBAAvB,EAA4CmE,KAA5C,EACnB;AACE;AACA,YAAIK,aAAa,KAAKC,uBAAL,CAA6BzE,mBAA7B,CAAjB;AACA,YAAI6D,SAAS,KAAKa,oBAAL,CAA0B3E,YAA1B,EAAwCyE,UAAxC,CAAb;AACA,YAAIX,MAAJ,EAAY;AACV;AACA,cAAIkB,eAAeP,WAAWA,WAAWrD,MAAX,GAAoB,CAA/B,CAAnB;;AAEA;AACA,cAAIe,QAAQ,KAAK8C,eAAL,CAAqBD,YAArB,CAAZ;AACA,cAAI7C,KAAJ,EAAW;AACT,gBAAIA,UAAU,MAAd,EAAsB;AACpB;AACAA,sBAAQ2B,OAAO1C,MAAP,GAAgB,CAAxB;AACD;AACD0C,mBAAOoB,OAAP,CAAe/C,KAAf,EAAsBiC,KAAtB;AACD,WAND,MAMO;AACL,gBAAI,OAAON,OAAO,QAAQ1E,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuB+C,YAAvB,CAAf,CAAP,IAA+D,UAAnE,EAA+E;AAC7E,oBAAM,IAAI5F,GAAGe,IAAH,CAAQqB,cAAZ,CAA2B,oBAAoBwD,YAApB,GAAmC,cAAnC,GAAoDlB,MAApD,GAA6D,GAAxF,CAAN;AACD;AACD,mBAAOA,OAAO,QAAQ1E,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuB+C,YAAvB,CAAf,EAAqDZ,KAArD,CAAP;AACD;AACF;AACF,OA3qBH;;AA8qBE;;;;;;;;AAQAa,uBAAiB,yBAASL,YAAT,EAAuB;AACtC,YAAIO,WAAW,kBAAf;AACE,YAAIC,aAAaR,aAAarB,KAAb,CAAmB4B,QAAnB,CAAjB;AACA,YAAIC,UAAJ,EAAgB;AACd,iBAAQA,WAAW,CAAX,CAAR;AACD;AACD,eAAO,IAAP;AACH,OA7rBH;;AAgsBE;;;;;;AAMAV,+BAAyB,iCAASzE,mBAAT,EAA8B;AACrD;AACA,eAAOA,oBAAoBoF,OAApB,CAA4B,KAA5B,EAAmC,IAAnC,EAAyC3E,KAAzC,CAA+C,GAA/C,EACJ4E,MADI,CACG,UAASC,IAAT,EAAe;AACrB,iBAAOA,SAAS,EAAhB;AACD,SAHI,CAAP;AAID,OA5sBH;;AA+sBE;;;;;;;;;;;;AAYAZ,4BAAuB,8BAAS3E,YAAT,EAAuBwF,gBAAvB,EAAyCrD,KAAzC,EACvB;AACEA,gBAAQA,SAASqD,iBAAiBpE,MAAjB,GAA0B,CAA3C;AACA,YAAI0C,SAAS9D,YAAb;;AAEA,aAAK,IAAImB,IAAI,CAAb,EAAgB2C,WAAW,IAAX,IAAmB3C,IAAIgB,KAAvC,EAA8ChB,GAA9C,EAAmD;AACjD,cAAI;AACF,gBAAIsE,WAAWD,iBAAiBrE,CAAjB,CAAf;;AAEA;AACA,gBAAIuE,WAAW,KAAKT,eAAL,CAAqBQ,QAArB,CAAf;AACA,gBAAIC,QAAJ,EAAc;AACZ,kBAAIA,aAAa,MAAjB,EAAyB;AACvB;AACAA,2BAAW5B,OAAO1C,MAAP,GAAgB,CAA3B;AACD;AACD0C,uBAASA,OAAOjC,OAAP,CAAe6D,QAAf,CAAT;AACD,aAND,MAOK;AACH5B,uBAASA,OAAO,QAAQ1E,GAAG2C,IAAH,CAAQC,MAAR,CAAeC,OAAf,CAAuBwD,QAAvB,CAAf,GAAT;AACD;AACF,WAfD,CAeE,OAAOjD,EAAP,EAAW;AACX,mBAAO,IAAP;AACD;AACF;AACD,eAAOsB,MAAP;AACD,OArvBH;;AAwvBE;;;;;;;;;;;;;;AAcArC,yBAAoB,2BAAS2C,KAAT,EAAgBpE,YAAhB,EAA8BC,mBAA9B,EAAmDC,OAAnD,EAA4DJ,YAA5D,EACpB;AACE;AACAsE,gBAAQ,KAAKE,cAAL,CACNF,KADM,EACCpE,YADD,EACeC,mBADf,EACoCC,OADpC,EAC6CJ,YAD7C,CAAR;AAGA;AACA,YAAIsE,UAAU1C,SAAd,EAAyB;AACvB,eAAKgC,kBAAL,CAAwB1D,YAAxB,EAAsCC,mBAAtC;AACD;AACD;AACA,YAAImE,UAAU1C,SAAd,EAAyB;AACvB,cAAI;AACF,gBAAIiE,SAAS,KAAKlC,gBAAL,CAAsBzD,YAAtB,EAAoCC,mBAApC,EAAyDmE,KAAzD,CAAb;;AAEA;AACA,gBAAIlE,WAAWA,QAAQ8C,QAAvB,EAAiC;AAC/B9C,sBAAQ8C,QAAR,CAAiBlD,YAAjB,EAA+BE,YAA/B,EAA6CoE,KAA7C;AACD;AACD,mBAAOuB,MAAP;AACD,WARD,CAQE,OAAOC,CAAP,EAAU;AACV,gBAAI,EAAGA,aAAaxG,GAAGe,IAAH,CAAQ0F,eAAxB,CAAJ,EAA8C;AAC5C,oBAAMD,CAAN;AACD;;AAED,gBAAI1F,WAAWA,QAAQ4F,SAAvB,EAAkC;AAChC5F,sBAAQ4F,SAAR,CAAkBF,CAAlB;AACD,aAFD,MAEO;AACLxG,iBAAG2G,GAAH,CAAOC,MAAP,CAAcC,IAAd,CACE,yBAAyB7B,KAAzB,GAAiC,MAAjC,GAA0CpE,YAA1C,GACG,mBADH,GACyB4F,CAF3B;AAID;AACF;AACF;AACF,OAzyBH;;AA4yBE;;;;;;;;;AASAhF,sCAAgC,wCAASH,aAAT,EAAwB;AACtD;AACA,YAAIE,mBAAmB,EAAvB;;AAEA;AACA,aAAK,IAAIQ,IAAI,CAAb,EAAgBA,IAAIV,cAAcW,MAAlC,EAA0CD,GAA1C,EAA+C;AAC7C,cAAI+E,OAAOzF,cAAcU,CAAd,CAAX;AACA;AACA,cAAI+E,KAAKC,QAAL,CAAc,GAAd,CAAJ,EAAwB;AACtB;AACA,gBAAIC,aAAaF,KAAKG,SAAL,CAAeH,KAAKI,OAAL,CAAa,GAAb,IAAoB,CAAnC,EAAsCJ,KAAKI,OAAL,CAAa,GAAb,CAAtC,CAAjB;;AAEA;AACA,gBAAIJ,KAAKI,OAAL,CAAa,GAAb,KAAqBJ,KAAK9E,MAAL,GAAc,CAAvC,EAA0C;AACxC,oBAAM,IAAImF,KAAJ,CAAU,0CACZL,IADY,GACL,iBADL,CAAN;AAED;AACD,gBAAIE,eAAe,MAAnB,EAA2B;AACzB,kBAAIA,cAAc,EAAd,IAAoBI,MAAMC,SAASL,UAAT,EAAqB,EAArB,CAAN,CAAxB,EAAyD;AACvD,sBAAM,IAAIG,KAAJ,CAAU,mEACeL,IADf,GACsB,iBADhC,CAAN;AAED;AACF;;AAED;AACA,gBAAIA,KAAKI,OAAL,CAAa,GAAb,KAAqB,CAAzB,EAA4B;AAC1B;AACA7F,4BAAcU,CAAd,IAAmB+E,KAAKG,SAAL,CAAe,CAAf,EAAkBH,KAAKI,OAAL,CAAa,GAAb,CAAlB,CAAnB;AACA;AACA3F,+BAAiBQ,CAAjB,IAAsB,EAAtB;AACA;AACAR,+BAAiBQ,IAAI,CAArB,IAA0BiF,UAA1B;AACA3F,4BAAciG,MAAd,CAAqBvF,IAAI,CAAzB,EAA4B,CAA5B,EAA+B,MAA/B;AACA;AACAA;AACF;AACC,aAXD,MAWO;AACL;AACAR,+BAAiBQ,CAAjB,IAAsBiF,UAAtB;AACA3F,4BAAciG,MAAd,CAAqBvF,CAArB,EAAwB,CAAxB,EAA2B,MAA3B;AACD;AAEF,WAlCD,MAkCO;AACLR,6BAAiBQ,CAAjB,IAAsB,EAAtB;AACD;AACF;;AAED,eAAOR,gBAAP;AACD,OAr2BH;;AAw2BE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BAmB,6BAAwB,+BAAShC,YAAT,EAAuB6G,WAAvB,EAAoC3G,YAApC,EACtB4G,cADsB,EACN1G,OADM,EACGkG,UADH,EAExB;AACE;AACyC;AACvC;AACA,cAAIS,YAAYzH,GAAGI,KAAH,CAASsH,YAAT,CACdhH,aAAaiF,WADC,EACY4B,WADZ,CAAhB;AAGAvH,aAAGe,IAAH,CAAQC,MAAR,CAAe2G,YAAf,CACE,oBADF,EACwBF,SADxB,EACmCF,cAC/B,gDAD+B,GAE/B7G,YAF+B,GAEhB,GAHnB;AAKD;;AAED,YAAIkH,eAAe,sBAASZ,UAAT,EAAqBR,CAArB,EAAwB;AACzC;AACA,cAAIQ,eAAe,EAAnB,EAAuB;AACrB;AACA,gBAAIA,eAAe,MAAnB,EAA2B;AACzBA,2BAAatG,aAAasB,MAAb,GAAsB,CAAnC;AACD;;AAED;AACA,gBAAIwC,OAAO9D,aAAa+B,OAAb,CAAqBuE,UAArB,CAAX;;AAEA;AACA,gBAAIxC,SAASlC,SAAb,EAAwB;AACtBtC,iBAAGwE,IAAH,CAAQM,kBAAR,CAA2BR,kBAA3B,CAA8C1D,YAA9C,EAA4D4G,cAA5D;AACD;;AAED;AACA,gBAAIK,QAAQrB,EAAEsB,OAAF,GAAYD,KAAxB;AACA,gBAAIE,MAAMvB,EAAEsB,OAAF,GAAYC,GAAtB;AACA,gBAAIf,aAAaa,KAAb,IAAsBb,aAAae,GAAvC,EAA4C;AAC1C;AACD;AACF,WApBD,MAoBO;AACL;AACA,gBAAIvD,OAAOgC,EAAEsB,OAAF,EAAX;AACD;;AAED;;;AAOA;AACAtD,iBAAOxE,GAAGwE,IAAH,CAAQM,kBAAR,CAA2BI,cAA3B,CACLV,IADK,EACC5D,YADD,EACe4G,cADf,EAC+B1G,OAD/B,EACwCJ,YADxC,CAAP;;AAIA;;;AAKA;AACA,cAAI6F,MAAJ;AACA,cAAI;AACF,gBAAI/B,SAASlC,SAAb,EAAwB;AACtBiE,uBAASvG,GAAGwE,IAAH,CAAQM,kBAAR,CAA2BT,gBAA3B,CAA4CzD,YAA5C,EAA0D4G,cAA1D,EAA0EhD,IAA1E,CAAT;AACD,aAFD,MAEO;AACN+B,uBAASvG,GAAGwE,IAAH,CAAQM,kBAAR,CAA2BR,kBAA3B,CAA8C1D,YAA9C,EAA4D4G,cAA5D,CAAT;AACA;;AAED;AACA,gBAAI1G,WAAWA,QAAQ8C,QAAvB,EAAiC;AAC/B9C,sBAAQ8C,QAAR,CAAiBlD,YAAjB,EAA+BE,YAA/B,EAA6C4D,IAA7C;AACD;AAEF,WAZD,CAYE,OAAOpB,EAAP,EAAW;AACX,gBAAI,EAAGA,cAAcpD,GAAGe,IAAH,CAAQ0F,eAAzB,CAAJ,EAA+C;AAC7C,oBAAMrD,EAAN;AACD;;AAED,gBAAItC,WAAWA,QAAQ4F,SAAvB,EAAkC;AAChC5F,sBAAQ4F,SAAR,CAAkBtD,EAAlB;AACD,aAFD,MAEO;AACLpD,iBAAG2G,GAAH,CAAOC,MAAP,CAAcC,IAAd,CACE,yBAAyBrC,IAAzB,GAAgC,MAAhC,GAAyC5D,YAAzC,GACG,mBADH,GACyBwC,EAF3B;AAID;AACF;AACD,iBAAOmD,MAAP;AACD,SAzED;;AA2EA;AACA,YAAI,CAACS,UAAL,EAAiB;AACf;AACAA,uBAAa,EAAb;AACD;AACD;AACAY,uBAAe5H,GAAG2C,IAAH,CAAQM,QAAR,CAAiBxC,IAAjB,CAAsBmH,YAAtB,EAAoClH,YAApC,EAAkDsG,UAAlD,CAAf;;AAEA;AACA,YAAIxD,KAAK9C,aAAayC,WAAb,CAAyBoE,WAAzB,EAAsCK,YAAtC,CAAT;;AAEA,eAAOpE,EAAP;AACD,OA5+BH;;AA++BE;;;;;;;;;;;AAWAG,sBAAiB,wBACfH,EADe,EACX9C,YADW,EACG6G,WADH,EACgB3G,YADhB,EAC8B4G,cAD9B,EAGjB;AACE,YAAIQ,IAAJ;;AAEA;AACAA,eAAOtH,aAAauH,UAAb,EAAP;AACA,YAAI,KAAK1H,UAAL,CAAgByH,IAAhB,MAA0B1F,SAA9B,EAAyC;AACvC,eAAK/B,UAAL,CAAgByH,IAAhB,IAAwB,EAAxB;AACD;;AAED,YAAIE,UAAU,CAAC1E,EAAD,EAAK9C,YAAL,EAAmB6G,WAAnB,EAAgC3G,YAAhC,EAA8C4G,cAA9C,CAAd;AACA,aAAKjH,UAAL,CAAgByH,IAAhB,EAAsB/F,IAAtB,CAA2BiG,OAA3B;;AAGA;AACAF,eAAOpH,aAAaqH,UAAb,EAAP;AACA,YAAI,KAAKzH,kBAAL,CAAwBwH,IAAxB,MAAkC1F,SAAtC,EAAiD;AAC/C,eAAK9B,kBAAL,CAAwBwH,IAAxB,IAAgC,EAAhC;AACD;AACD,aAAKxH,kBAAL,CAAwBwH,IAAxB,EAA8B/F,IAA9B,CAAmCiG,OAAnC;AACD,OAhhCH;;AAmhCE;;;;;;;;;;;;;;;;;;;AAmBAhD,sBAAiB,wBACfF,KADe,EACRpE,YADQ,EACMC,mBADN,EAC2BC,OAD3B,EACoCJ,YADpC,EAEf;AACA;AACA,YAAII,WAAWA,QAAQgD,SAAvB,EAAkC;AAChC,cAAIqE,KAAJ;AACA,cAAIvH,aAAawH,QAAjB,EAA2B;AACzBD,oBAAQvH,aAAawH,QAAb,EAAR;AACD;AACD,iBAAOtH,QAAQgD,SAAR,CAAkBkB,KAAlB,EAAyBmD,KAAzB,EAAgCzH,YAAhC,EAA8CE,YAA9C,CAAP;AACF;AACC,SAPD,MAOO;AACL,cAAIyE,aAAa,KAAKC,uBAAL,CAA6BzE,mBAA7B,CAAjB;AACA,cAAI6D,SAAS,KAAKa,oBAAL,CAA0B3E,YAA1B,EAAwCyE,UAAxC,CAAb;AACA,cAAIO,eAAe/E,oBAAoBoG,SAApB,CACjBpG,oBAAoBwH,WAApB,CAAgC,GAAhC,IAAuC,CADtB,EACyBxH,oBAAoBmB,MAD7C,CAAnB;AAGA;AACA,cAAI0C,UAAU,IAAd,EAAoB;AAClB,mBAAOM,KAAP;AACD;;AAED,cAAIsD,sBAAsBtI,GAAGI,KAAH,CAASmI,qBAAT,CACxB7D,OAAOiB,WADiB,EACJC,YADI,CAA1B;AAGA,cAAI4C,QAAQF,uBAAuB,IAAvB,GAA8B,EAA9B,GAAmCA,oBAAoBE,KAAnE;AACA,iBAAO,KAAKC,mBAAL,CAAyBzD,KAAzB,EAAgCwD,KAAhC,CAAP;AACD;AACF,OAlkCH;;AAqkCE;;;;;;;;;;;AAWA/C,6BAAwB,+BAAS/E,YAAT,EAAuBgI,cAAvB,EAAuC;AAC7D;AACA,YAAIJ,sBAAuBtI,GAAGI,KAAH,CAASmI,qBAAT,CACzB7H,aAAaiF,WADY,EACC+C,cADD,CAA3B;;AAIA,YAAIJ,uBAAuB,IAA3B,EAAiC;AAC/B,iBAAO,IAAP;AACD;AACD,eAAOA,oBAAoBK,KAA3B;AACD,OA1lCH;;AA6lCE;;;;;;;;AAQAF,2BAAsB,6BAASjE,IAAT,EAAeoE,WAAf,EAA4B;AAChD,YAAIC,WAAW7I,GAAG2C,IAAH,CAAQmG,IAAR,CAAaC,QAAb,CAAsBvE,IAAtB,CAAf;;AAEA;AACA,YAAI,CAACqE,YAAY,QAAZ,IAAwBA,YAAY,QAArC,MACCD,eAAe,SAAf,IAA4BA,eAAe,iBAD5C,CAAJ,EACoE;AAClEpE,iBAAO6C,SAAS7C,IAAT,EAAe,EAAf,CAAP;AACD;;AAED;AACA,YAAI,CAACqE,YAAY,SAAZ,IAAyBA,YAAY,QAArC,IAAiDA,YAAY,MAA9D,KACCD,eAAe,QADpB,EAC8B;AAC5BpE,iBAAOA,OAAO,EAAd;AACD;;AAED;AACA,YAAI,CAACqE,YAAY,QAAZ,IAAwBA,YAAY,QAArC,MACDD,eAAe,QAAf,IAA2BA,eAAe,gBADzC,CAAJ,EACgE;AAC9DpE,iBAAOwE,WAAWxE,IAAX,CAAP;AACD;;AAED,eAAOA,IAAP;AACD,OA3nCH;;AA8nCE;;;;;;;;AAQAyE,+BAA0B,iCAASvI,YAAT,EAAuB8C,EAAvB,EAA2B;AACnD;AACA,YAAIA,GAAGC,IAAH,IAAW,aAAf,EAA8B;AAC5B;AACA,eAAK,IAAI1B,IAAI,CAAb,EAAgBA,IAAIyB,GAAG/B,OAAH,CAAWO,MAA/B,EAAuCD,GAAvC,EAA4C;AAC1C;AACA,gBAAIyB,GAAG/B,OAAH,CAAWM,CAAX,CAAJ,EAAmB;AACjByB,iBAAG/B,OAAH,CAAWM,CAAX,EAAcsB,kBAAd,CAAiCG,GAAG7B,WAAH,CAAeI,CAAf,CAAjC;AACD;AACF;AACD;AACA,eAAK,IAAIA,IAAI,CAAb,EAAgBA,IAAIyB,GAAGF,OAAH,CAAWtB,MAA/B,EAAuCD,GAAvC,EAA4C;AAC1C;AACA,gBAAIyB,GAAGF,OAAH,CAAWvB,CAAX,CAAJ,EAAmB;AACjByB,iBAAGF,OAAH,CAAWvB,CAAX,EAAcsB,kBAAd,CAAiCG,GAAGE,iBAAH,CAAqB3B,CAArB,CAAjC;AACD;AACF;AACF,SAfD,MAeO;AACL;AACArB,uBAAa2C,kBAAb,CAAgCG,EAAhC;AACD;;AAED;AACA,YAAI0F,WAAW,KAAKC,uBAAL,CAA6BzI,YAA7B,CAAf;AACA;AACA,YAAIwI,YAAY5G,SAAhB,EAA2B;AACzB,eAAK,IAAIP,IAAI,CAAb,EAAgBA,IAAImH,SAASlH,MAA7B,EAAqCD,GAArC,EAA0C;AACxC,gBAAImH,SAASnH,CAAT,EAAY,CAAZ,KAAkByB,EAAtB,EAA0B;AACxB;AACA,kBAAIkB,SAASwE,SAASnH,CAAT,EAAY,CAAZ,CAAb;AACA,kBAAI,KAAKvB,kBAAL,CAAwBkE,OAAOuD,UAAP,EAAxB,CAAJ,EAAkD;AAChDjI,mBAAG2C,IAAH,CAAQyG,KAAR,CAAcC,MAAd,CAAqB,KAAK7I,kBAAL,CAAwBkE,OAAOuD,UAAP,EAAxB,CAArB,EAAmEiB,SAASnH,CAAT,CAAnE;AACD;;AAED;AACA,kBAAIF,SAASqH,SAASnH,CAAT,EAAY,CAAZ,CAAb;AACA,kBAAI,KAAKxB,UAAL,CAAgBsB,OAAOoG,UAAP,EAAhB,CAAJ,EAA0C;AACxCjI,mBAAG2C,IAAH,CAAQyG,KAAR,CAAcC,MAAd,CAAqB,KAAK9I,UAAL,CAAgBsB,OAAOoG,UAAP,EAAhB,CAArB,EAA2DiB,SAASnH,CAAT,CAA3D;AACD;AACD;AACD;AACF;AACF;AACD,cAAM,IAAIoF,KAAJ,CAAU,6BAAV,CAAN;AACD,OAlrCH;;AAqrCE;;;;;;;;;;AAUAmC,kCAA6B,oCAASC,MAAT,EAAiB;AAC5C;;AAEyC;AACvCvJ,aAAGe,IAAH,CAAQC,MAAR,CAAewI,aAAf,CAA6BD,MAA7B,EACE,8CADF;AAED;;AAED;AACA,YAAIL,WAAW,KAAKC,uBAAL,CAA6BI,MAA7B,CAAf;AACA,YAAIL,YAAY5G,SAAhB,EACA;AACE;AACA,eAAK,IAAIP,IAAImH,SAASlH,MAAT,GAAkB,CAA/B,EAAkCD,KAAK,CAAvC,EAA0CA,GAA1C,EAA+C;AAC7C,iBAAKkH,uBAAL,CAA6BM,MAA7B,EAAqCL,SAASnH,CAAT,EAAY,CAAZ,CAArC;AACD;AACF;AACF,OAhtCH;;AAmtCE;;;;;;;;;;;;AAYA0H,6BAAwB,+BAASF,MAAT,EAAiBG,aAAjB,EAAgC;AACtD;AACyC;AACvC1J,aAAGe,IAAH,CAAQC,MAAR,CAAewI,aAAf,CAA6BD,MAA7B,EACE,8CADF;AAEAvJ,aAAGe,IAAH,CAAQC,MAAR,CAAewI,aAAf,CAA6BE,aAA7B,EACE,8CADF;AAED;;AAED;AACA,YAAIR,WAAW,KAAKC,uBAAL,CAA6BI,MAA7B,CAAf;AACA,YAAIL,YAAY5G,SAAhB,EACA;AACE;AACA,eAAK,IAAIP,IAAImH,SAASlH,MAAT,GAAkB,CAA/B,EAAkCD,KAAK,CAAvC,EAA0CA,GAA1C,EAA+C;AAC7C,gBAAIF,SAASqH,SAASnH,CAAT,EAAY,CAAZ,CAAb;AACA,gBAAI2C,SAASwE,SAASnH,CAAT,EAAY,CAAZ,CAAb;AACA,gBAAIF,WAAW6H,aAAX,IAA4BhF,WAAWgF,aAA3C,EAA0D;AACxD,mBAAKT,uBAAL,CAA6BM,MAA7B,EAAqCL,SAASnH,CAAT,EAAY,CAAZ,CAArC;AACD;AACF;AACF;AACF,OArvCH;;AAwvCE;;;;;;;;;;AAUAoH,+BAA0B,iCAASI,MAAT,EAAiB;AACzC,YAAIvB,OAAOuB,OAAOtB,UAAP,EAAX;AACA;AACA,YAAI,KAAK1H,UAAL,CAAgByH,IAAhB,MAA0B1F,SAA9B,EAAyC;AACvC,eAAK/B,UAAL,CAAgByH,IAAhB,IAAwB,EAAxB;AACD;;AAED;AACA,YAAI2B,iBAAiB,KAAKpJ,UAAL,CAAgByH,IAAhB,CAArB;;AAEA;AACA,YAAI4B,iBAAiB,KAAKpJ,kBAAL,CAAwBwH,IAAxB,IAAgC,KAAKxH,kBAAL,CAAwBwH,IAAxB,CAAhC,GAAgE,EAArF;;AAEA,eAAOhI,GAAG2C,IAAH,CAAQyG,KAAR,CAAcS,MAAd,CAAqBF,eAAeG,MAAf,CAAsBF,cAAtB,CAArB,CAAP;AACD,OAhxCH;;AAmxCE;;;;;;AAMAG,yBAAoB,6BAAW;AAC7B;AACA,aAAK,IAAI/B,IAAT,IAAiB,KAAKzH,UAAtB,EAAkC;AAChC,cAAIgJ,SAASvJ,GAAGe,IAAH,CAAQiJ,cAAR,CAAuBC,YAAvB,CAAoCjC,IAApC,CAAb;AACA;AACA,cAAIuB,UAAU,IAAd,EAAoB;AAClB,mBAAO,KAAKhJ,UAAL,CAAgByH,IAAhB,CAAP;AACA;AACD;AACD,eAAKsB,0BAAL,CAAgCC,MAAhC;AACD;AACD;AACA,aAAKhJ,UAAL,GAAkB,EAAlB;AACD,OAtyCH;;AAyyCE;;;;;;;;AAQA2J,sBAAiB,0BAAW;AAC1B,eAAO,KAAK3J,UAAZ;AACD,OAnzCH;;AAszCE;;;;;;;AAOA4J,wBAAmB,0BAASZ,MAAT,EAAiB/F,EAAjB,EAAqB;AACtC,YAAI0E,OAAJ;AACA;AACA,aAAK,IAAInG,IAAI,CAAb,EAAgBA,IAAI,KAAKxB,UAAL,CAAgBgJ,OAAOtB,UAAP,EAAhB,EAAqCjG,MAAzD,EAAiED,GAAjE,EAAsE;AACpE;AACA,cAAI,KAAKxB,UAAL,CAAgBgJ,OAAOtB,UAAP,EAAhB,EAAqClG,CAArC,EAAwC,CAAxC,KAA8CyB,EAAlD,EAAsD;AACpD0E,sBAAU,KAAK3H,UAAL,CAAgBgJ,OAAOtB,UAAP,EAAhB,EAAqClG,CAArC,CAAV;AACA;AACD;AACF;;AAED,YAAImG,YAAY5F,SAAhB,EAA2B;AACzB,cAAI8H,UAAU,yBAAd;AACD,SAFD,MAEO;AACL,cAAIA,UAAU,mBAAmBlC,QAAQ,CAAR,CAAnB,GAAgC,KAAhC,GAAwCA,QAAQ,CAAR,CAAxC,GACZ,mBADY,GACUA,QAAQ,CAAR,CADV,GACuB,KADvB,GAC8BA,QAAQ,CAAR,CAD9B,GAC2C,IADzD;AAED;;AAEDlI,WAAG2G,GAAH,CAAOC,MAAP,CAAcyD,KAAd,CAAoBD,OAApB;AACD,OAh1CH;;AAm1CE;;;;;AAKAE,4BAAuB,gCAAW;AAChC;AACA,aAAK,IAAItC,IAAT,IAAiB,KAAKzH,UAAtB,EAAkC;AAChC,cAAIgJ,SAASvJ,GAAGe,IAAH,CAAQiJ,cAAR,CAAuBC,YAAvB,CAAoCjC,IAApC,CAAb;AACA,cAAIuB,MAAJ,EAAY;AACX,iBAAK,IAAIxH,IAAI,CAAb,EAAgBA,IAAI,KAAKxB,UAAL,CAAgByH,IAAhB,EAAsBhG,MAA1C,EAAkDD,GAAlD,EAAuD;AACrD,mBAAKoI,gBAAL,CAAsBZ,MAAtB,EAA8B,KAAKhJ,UAAL,CAAgByH,IAAhB,EAAsBjG,CAAtB,EAAyB,CAAzB,CAA9B;AACD;AACD;AACF;AACF;;AAl2CH;AAHF,GADA,C;AArBA/B,KAAGwE,IAAH,CAAQM,kBAAR,CAA2B3E,aAA3B,GAA2CA,aAA3C",
  "file": "SingleValueBinding.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (martinwittemann)\n\n************************************************************************ */\n\n/**\n * Single-value binding is a core component of the data binding package.\n */\nqx.Class.define(\"qx.data.SingleValueBinding\",\n{\n\n  statics :\n  {\n    /** internal reference for all bindings indexed by source object */\n    __bindings: {},\n\n    /** internal reference for all bindings indexed by target object */\n    __bindingsByTarget : {},\n\n\n    /**\n     * The function is responsible for binding a source objects property to\n     * a target objects property. Both properties have to have the usual qooxdoo\n     * getter and setter. The source property also needs to fire change-events\n     * on every change of its value.\n     * Please keep in mind, that this binding is unidirectional. If you need\n     * a binding in both directions, you have to use two of this bindings.\n     *\n     * It's also possible to bind some kind of a hierarchy as a source. This\n     * means that you can separate the source properties with a dot and bind\n     * by that the object referenced to this property chain.\n     * Example with an object 'a' which has object 'b' stored in its 'child'\n     * property. Object b has a string property named abc:\n     * <pre><code>\n     * qx.data.SingleValueBinding.bind(a, \"child.abc\", textfield, \"value\");\n     * </code></pre>\n     * In that case, if the property abc of b changes, the textfield will\n     * automatically contain the new value. Also if the child of a changes, the\n     * new value (abc of the new child) will be in the textfield.\n     *\n     * There is also a possibility of binding an array. Therefore the array\n     * {@link qx.data.IListData} is needed because this array has change events\n     * which the native does not. Imagine a qooxdoo object a which has a\n     * children property containing an array holding more of its own kind.\n     * Every object has a name property as a string.\n     * <pre>\n     * var svb = qx.data.SingleValueBinding;\n     * // bind the first child's name of 'a' to a textfield\n     * svb.bind(a, \"children[0].name\", textfield, \"value\");\n     * // bind the last child's name of 'a' to a textfield\n     * svb.bind(a, \"children[last].name\", textfield2, \"value\");\n     * // also deeper bindings are possible\n     * svb.bind(a, \"children[0].children[0].name\", textfield3, \"value\");\n     * </pre>\n     *\n     * As you can see in this example, the abc property of a's b will be bound\n     * to the textfield. If now the value of b changed or even the a will get a\n     * new b, the binding still shows the right value.\n     *\n     * @param sourceObject {qx.core.Object} The source of the binding.\n     * @param sourcePropertyChain {String} The property chain which represents\n     *   the source property.\n     * @param targetObject {qx.core.Object} The object which the source should\n     *   be bind to.\n     * @param targetPropertyChain {String} The property chain to the target\n     *   object.\n     * @param options {Map?null} A map containing the options.\n     *   <li>converter: A converter function which takes four parameters\n     *       and should return the converted value.\n     *       <ol>\n     *         <li>The data to convert</li>\n     *         <li>The corresponding model object, which is only set in case of the use of an controller.</li>\n     *         <li>The source object for the binding</li>\n     *         <li>The target object.</li>\n     *       </ol>\n     *       If no conversion has been done, the given value should be returned.\n     *       e.g. a number to boolean converter\n     *       <code>function(data, model, source, target) {return data > 100;}</code>\n     *   </li>\n     *   <li>onUpdate: A callback function can be given here. This method will be\n     *       called if the binding was updated successful. There will be\n     *       three parameter you do get in that method call.\n     *       <ol>\n     *         <li>The source object</li>\n     *         <li>The target object</li>\n     *         <li>The data</li>\n     *       </ol>\n     *       Here is a sample: <code>onUpdate : function(source, target, data) {...}</code>\n     *   </li>\n     *   <li>onSetFail: A callback function can be given here. This method will\n     *       be called if the set of the value fails.\n     *   </li>\n     *   <li>ignoreConverter: A string which will be matched using the current\n     *       property chain. If it matches, the converter will not be called.\n     *   </li>\n     *\n     * @return {var} Returns the internal id for that binding. This can be used\n     *   for referencing the binding or e.g. for removing. This is not an atomic\n     *   id so you can't you use it as a hash-map index.\n     *\n     * @throws {qx.core.AssertionError} If the event is no data event or\n     *   there is no property definition for object and property (source and\n     *   target).\n     */\n    bind : function(\n      sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options\n    )\n    {\n      // check for the arguments\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertObject(sourceObject, \"sourceObject\");\n        qx.core.Assert.assertString(sourcePropertyChain, \"sourcePropertyChain\");\n        qx.core.Assert.assertObject(targetObject, \"targetObject\");\n        qx.core.Assert.assertString(targetPropertyChain, \"targetPropertyChain\");\n      }\n\n      // set up the target binding\n      var targetListenerMap = this.__setUpTargetBinding(\n        sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options\n      );\n\n      // get the property names\n      var propertyNames = sourcePropertyChain.split(\".\");\n\n      // stuff that's needed to store for the listener function\n      var arrayIndexValues =\n        this.__checkForArrayInPropertyChain(propertyNames);\n      var sources = [];\n      var listeners = [];\n      var listenerIds = [];\n      var eventNames = [];\n      var source = sourceObject;\n      var initialPromise = null;\n\n      // add a try catch to make it possible to remove the listeners of the\n      // chain in case the loop breaks after some listeners already added.\n      try {\n        // go through all property names\n        for (var i = 0; i < propertyNames.length; i++) {\n          // check for the array\n          if (arrayIndexValues[i] !== \"\") {\n            // push the array change event\n            eventNames.push(\"change\");\n          } else {\n            var eventName = this.__getEventNameForProperty(source, propertyNames[i]);\n            if (!eventName) {\n              if (i == 0) { // the root property can not change --> error\n                throw new qx.core.AssertionError(\n                  \"Binding property \" + propertyNames[i] + \" of object \" + source +\n                  \" not possible: No event available. \"\n                );\n              }\n              // call the converter if no event could be found on binding creation\n              initialPromise = this.__setInitialValue(undefined, targetObject, targetPropertyChain, options, sourceObject);\n              break;\n            }\n            eventNames.push(eventName);\n          }\n\n          // save the current source\n          sources[i] = source;\n\n          // check for the last property\n          if (i == propertyNames.length -1) {\n            // if it is an array, set the initial value and bind the event\n            if (arrayIndexValues[i] !== \"\") {\n              // get the current value\n              var itemIndex = arrayIndexValues[i] === \"last\" ?\n                source.length - 1 : arrayIndexValues[i];\n              var currentValue = source.getItem(itemIndex);\n\n              // set the initial value\n              initialPromise = this.__setInitialValue(currentValue, targetObject, targetPropertyChain, options, sourceObject);\n\n              // bind the event\n              listenerIds[i] = this.__bindEventToProperty(\n                source, eventNames[i], targetObject, targetPropertyChain, options, arrayIndexValues[i]\n              );\n            } else {\n              // try to set the initial value\n              if (propertyNames[i] != null && source[\"get\" + qx.lang.String.firstUp(propertyNames[i])] != null) {\n                var currentValue = source[\"get\" + qx.lang.String.firstUp(propertyNames[i])]();\n                initialPromise = this.__setInitialValue(currentValue, targetObject, targetPropertyChain, options, sourceObject);\n              }\n              // bind the property\n              listenerIds[i] = this.__bindEventToProperty(\n                source, eventNames[i], targetObject, targetPropertyChain, options\n              );\n            }\n\n          // if its not the last property\n          } else {\n\n            // create the context for the listener\n            var context = {\n              index: i,\n              propertyNames: propertyNames,\n              sources: sources,\n              listenerIds: listenerIds,\n              arrayIndexValues: arrayIndexValues,\n              targetObject: targetObject,\n              targetPropertyChain: targetPropertyChain,\n              options: options,\n              listeners: listeners\n            };\n\n            // create a listener\n            var listener = qx.lang.Function.bind(this.__chainListener, this, context);\n\n            // store the listener for further processing\n            listeners.push(listener);\n\n            // add the chaining listener\n            listenerIds[i] = source.addListener(eventNames[i], listener);\n          }\n\n          // get and store the next source\n          if (source[\"get\" + qx.lang.String.firstUp(propertyNames[i])] == null) {\n            source = undefined;\n          } else if (arrayIndexValues[i] !== \"\") {\n            var itemIndex = arrayIndexValues[i] === \"last\" ?\n              source.length - 1 : arrayIndexValues[i];\n            source = source[\"get\" + qx.lang.String.firstUp(propertyNames[i])](itemIndex);\n          } else {\n            source = source[\"get\" + qx.lang.String.firstUp(propertyNames[i])]();\n            // the value should be undefined if we can not find the last part of the property chain\n            if (source === null && (propertyNames.length - 1) != i) {\n              source = undefined;\n            }\n          }\n          if (!source) {\n            // call the converter if no source could be found on binding creation\n            this.__setInitialValue(source, targetObject, targetPropertyChain, options, sourceObject);\n            break;\n          }\n        }\n\n      } catch (ex) {\n        // remove the already added listener\n        // go through all added listeners (source)\n\n        for (var i = 0; i < sources.length; i++) {\n          // check if a source is available\n          if (sources[i] && listenerIds[i]) {\n            sources[i].removeListenerById(listenerIds[i]);\n          }\n        }\n        var targets = targetListenerMap.targets;\n        var targetIds = targetListenerMap.listenerIds;\n        // go through all added listeners (target)\n        for (var i = 0; i < targets.length; i++) {\n          // check if a target is available\n          if (targets[i] && targetIds[i]) {\n            targets[i].removeListenerById(targetIds[i]);\n          }\n        }\n\n        throw ex;\n      }\n\n      // create the id map\n      var id = {\n        type: \"deepBinding\",\n        listenerIds: listenerIds,\n        sources: sources,\n        targetListenerIds: targetListenerMap.listenerIds,\n        targets: targetListenerMap.targets,\n        initialPromise: initialPromise\n      };\n      // store the bindings\n      this.__storeBinding(\n        id, sourceObject, sourcePropertyChain, targetObject, targetPropertyChain\n      );\n\n      return id;\n    },\n\n\n    /**\n     * Event listener for the chaining of the properties.\n     *\n     * @param context {Map} The current context for the listener.\n     */\n    __chainListener : function(context)\n    {\n      // invoke the onUpdate method\n      if (context.options && context.options.onUpdate) {\n        context.options.onUpdate(\n          context.sources[context.index], context.targetObject\n        );\n      }\n\n      // delete all listener after the current one\n      for (var j = context.index + 1; j < context.propertyNames.length; j++) {\n        // remove the old sources\n        var source = context.sources[j];\n        context.sources[j] = null;\n        if (!source) {\n          continue;\n        }\n\n        // remove the listeners\n        source.removeListenerById(context.listenerIds[j]);\n      }\n\n      // get the current source\n      var source = context.sources[context.index];\n      // add new once after the current one\n      for (var j = context.index + 1; j < context.propertyNames.length; j++) {\n        // get and store the new source\n        if (context.arrayIndexValues[j - 1] !== \"\") {\n          source = source[\"get\" + qx.lang.String.firstUp(context.propertyNames[j - 1])](context.arrayIndexValues[j - 1]);\n        } else {\n          source = source[\"get\" + qx.lang.String.firstUp(context.propertyNames[j - 1])]();\n        }\n        context.sources[j] = source;\n        // reset the target object if no new source could be found\n        if (!source) {\n          // use the converter if the property chain breaks [BUG# 6880]\n          if (context.options && context.options.converter) {\n\n            var ignoreConverter = false;\n            // take care of the ignore pattern used for the controller\n            if (context.options.ignoreConverter) {\n              // the current property chain as string\n              var currentSourceChain = context.propertyNames.slice(0,j).join(\".\");\n              // match for the current pattern given in the options\n              var match = currentSourceChain.match(\n                new RegExp(\"^\" + context.options.ignoreConverter)\n              );\n              ignoreConverter = match ? match.length > 0 : false;\n            }\n\n            if (!ignoreConverter) {\n              this.__setTargetValue(\n                context.targetObject,\n                context.targetPropertyChain,\n                context.options.converter()\n              );\n            } else {\n              this.__resetTargetValue(context.targetObject, context.targetPropertyChain);\n            }\n          } else {\n            this.__resetTargetValue(context.targetObject, context.targetPropertyChain);\n          }\n\n          break;\n        }\n\n        // if its the last property\n        if (j == context.propertyNames.length - 1) {\n          // if its an array\n          if (qx.Class.implementsInterface(source, qx.data.IListData)) {\n            // set the initial value\n            var itemIndex = context.arrayIndexValues[j] === \"last\" ?\n              source.length - 1 : context.arrayIndexValues[j];\n            var currentValue = source.getItem(itemIndex);\n            this.__setInitialValue(\n              currentValue, context.targetObject, context.targetPropertyChain, context.options, context.sources[context.index]\n            );\n\n            // bind the item event to the new target\n            context.listenerIds[j] = this.__bindEventToProperty(\n              source, \"change\", context.targetObject, context.targetPropertyChain, context.options, context.arrayIndexValues[j]\n            );\n\n          } else {\n            if (context.propertyNames[j] != null && source[\"get\" + qx.lang.String.firstUp(context.propertyNames[j])] != null) {\n              var currentValue = source[\"get\" + qx.lang.String.firstUp(context.propertyNames[j])]();\n              this.__setInitialValue(currentValue, context.targetObject, context.targetPropertyChain, context.options, context.sources[context.index]);\n            }\n            var eventName = this.__getEventNameForProperty(source, context.propertyNames[j]);\n            if (!eventName) {\n              context.sources[j] = null;\n              this.__resetTargetValue(context.targetObject, context.targetPropertyChain);\n              return;\n            }\n            // bind the last property to the new target\n            context.listenerIds[j] = this.__bindEventToProperty(\n              source, eventName, context.targetObject, context.targetPropertyChain, context.options\n            );\n          }\n        } else {\n          // check if a listener already created\n          if (context.listeners[j] == null) {\n            var listener = qx.lang.Function.bind(this.__chainListener, this, context);\n            // store the listener for further processing\n            context.listeners.push(listener);\n          }\n          // add a new listener\n          if (qx.Class.implementsInterface(source, qx.data.IListData)) {\n            var eventName = \"change\";\n          } else {\n            var eventName = this.__getEventNameForProperty(source, context.propertyNames[j]);\n          }\n\n          if (!eventName) {\n            context.sources[j] = null;\n            this.__resetTargetValue(context.targetObject, context.targetPropertyChain);\n            return;\n          }\n          context.listenerIds[j] = source.addListener(eventName, context.listeners[j]);\n        }\n      }\n    },\n\n\n    /**\n     * Internal helper for setting up the listening to the changes on the\n     * target side of the binding. Only works if the target property is a\n     * property chain\n     *\n     * @param sourceObject {qx.core.Object} The source of the binding.\n     * @param sourcePropertyChain {String} The property chain which represents\n     *   the source property.\n     * @param targetObject {qx.core.Object} The object which the source should\n     *   be bind to.\n     * @param targetPropertyChain {String} The property name of the target\n     *   object.\n     * @param options {Map} The options map perhaps containing the user defined\n     *   converter.\n     * @return {var} A map containing the listener ids and the targets.\n     */\n    __setUpTargetBinding : function(\n      sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options\n    ) {\n      // get the property names\n      var propertyNames = targetPropertyChain.split(\".\");\n\n      var arrayIndexValues =\n        this.__checkForArrayInPropertyChain(propertyNames);\n      var targets = [];\n      var listeners = [];\n      var listenerIds = [];\n      var eventNames = [];\n      var target = targetObject;\n\n      // go through all property names\n      for (var i = 0; i < propertyNames.length - 1; i++) {\n        // check for the array\n        if (arrayIndexValues[i] !== \"\") {\n          // push the array change event\n          eventNames.push(\"change\");\n        } else {\n          var eventName = this.__getEventNameForProperty(target, propertyNames[i]);\n          if (!eventName) {\n            // if the event names could not be terminated,\n            // just ignore the target chain listening\n            break;\n          }\n          eventNames.push(eventName);\n        }\n\n        // save the current source\n        targets[i] = target;\n\n        // create a listener\n        var listener = function() {\n          // delete all listener after the current one\n          for (var j = i + 1; j < propertyNames.length - 1; j++) {\n            // remove the old sources\n            var target = targets[j];\n            targets[j] = null;\n            if (!target) {\n              continue;\n            }\n\n            // remove the listeners\n            target.removeListenerById(listenerIds[j]);\n          }\n\n          // get the current target\n          var target = targets[i];\n          // add new once after the current one\n          for (var j = i + 1; j < propertyNames.length - 1; j++) {\n\n            var firstUpPropName = qx.lang.String.firstUp(propertyNames[j - 1]);\n            // get and store the new target\n            if (arrayIndexValues[j - 1] !== \"\") {\n              var currentIndex = arrayIndexValues[j - 1] === \"last\" ?\n                target.getLength() - 1 : arrayIndexValues[j - 1];\n              target = target[\"get\" + firstUpPropName](currentIndex);\n            } else {\n              target = target[\"get\" + firstUpPropName]();\n            }\n            targets[j] = target;\n            if (!target) {\n              break;\n            }\n\n            // check if a listener already created\n            if (listeners[j] == null) {\n              // store the listener for further processing\n              listeners.push(listener);\n            }\n\n            // add a new listener\n            if (qx.Class.implementsInterface(target, qx.data.IListData)) {\n              var eventName = \"change\";\n            } else {\n              var eventName =\n                qx.data.SingleValueBinding.__getEventNameForProperty(\n                  target, propertyNames[j]\n                );\n              if (!eventName) {\n                // if the event name could not be terminated,\n                // ignore the rest\n                break;\n              }\n            }\n\n            listenerIds[j] = target.addListener(eventName, listeners[j]);\n           }\n\n          qx.data.SingleValueBinding.updateTarget(\n            sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options\n          );\n        };\n\n        // store the listener for further processing\n        listeners.push(listener);\n\n        // add the chaining listener\n        listenerIds[i] = target.addListener(eventNames[i], listener);\n\n        var firstUpPropName = qx.lang.String.firstUp(propertyNames[i]);\n        // get and store the next target\n        if (target[\"get\" + firstUpPropName] == null) {\n          target = null;\n        } else if (arrayIndexValues[i] !== \"\") {\n          target = target[\"get\" + firstUpPropName](arrayIndexValues[i]);\n        } else {\n          target = target[\"get\" + firstUpPropName]();\n        }\n        if (!target) {\n          break;\n        }\n      }\n\n      return {listenerIds: listenerIds, targets: targets};\n    },\n\n\n    /**\n     * Helper for updating the target. Gets the current set data from the source\n     * and set that on the target.\n     *\n     * @param sourceObject {qx.core.Object} The source of the binding.\n     * @param sourcePropertyChain {String} The property chain which represents\n     *   the source property.\n     * @param targetObject {qx.core.Object} The object which the source should\n     *   be bind to.\n     * @param targetPropertyChain {String} The property name of the target\n     *   object.\n     * @param options {Map} The options map perhaps containing the user defined\n     *   converter.\n     *\n     * @internal\n     */\n    updateTarget : function(\n      sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options\n    )\n    {\n      var value = this.resolvePropertyChain(sourceObject, sourcePropertyChain);\n\n      // convert the data before setting\n      value = qx.data.SingleValueBinding.__convertValue(\n        value, targetObject, targetPropertyChain, options, sourceObject\n      );\n\n      this.__setTargetValue(targetObject, targetPropertyChain, value);\n    },\n\n\n    /**\n     * Internal helper for getting the current set value at the property chain.\n     *\n     * @param o {qx.core.Object} The source of the binding.\n     * @param propertyChain {String} The property chain which represents\n     *   the source property.\n     * @return {var?undefined} Returns the set value if defined.\n     */\n    resolvePropertyChain : function(o, propertyChain) {\n      var properties = this.__getPropertyChainArray(propertyChain);\n      return this.__getTargetFromChain(o, properties, properties.length);\n    },\n\n\n    /**\n     * Tries to return a fitting event name to the given source object and\n     * property name. First, it assumes that the property name is a real property\n     * and therefore it checks the property definition for the event. The second\n     * possibility is to check if there is an event with the given name. The\n     * third and last possibility checked is if there is an event which is named\n     * change + propertyName. If this three possibilities fail, an error will be\n     * thrown.\n     *\n     * @param source {qx.core.Object} The source where the property is stored.\n     * @param propertyName {String} The name of the property.\n     * @return {String|null} The name of the corresponding event or null.\n     */\n    __getEventNameForProperty : function(source, propertyName)\n    {\n      // get the current event name from the property definition\n      var eventName = this.__getEventForProperty(source, propertyName);\n      // if no event name could be found\n      if (eventName == null) {\n        // check if the propertyName is the event name\n        if (qx.Class.supportsEvent(source.constructor, propertyName)) {\n          eventName = propertyName;\n        // check if the change + propertyName is the event name\n        } else if (qx.Class.supportsEvent(\n          source.constructor, \"change\" + qx.lang.String.firstUp(propertyName))\n        ) {\n          eventName = \"change\" + qx.lang.String.firstUp(propertyName);\n        } else {\n          return null;\n        }\n      }\n      return eventName;\n    },\n\n\n    /**\n     * Resets the value of the given target after resolving the target property\n     * chain.\n     *\n     * @param targetObject {qx.core.Object} The object where the property chain\n     *   starts.\n     * @param targetPropertyChain {String} The names of the properties,\n     *   separated with a dot.\n     */\n    __resetTargetValue : function(targetObject, targetPropertyChain)\n    {\n      // get the last target object of the chain\n      var properties = this.__getPropertyChainArray(targetPropertyChain);\n      var target = this.__getTargetFromChain(targetObject, properties);\n      if (target != null) {\n        // get the name of the last property\n        var lastProperty = properties[properties.length - 1];\n        // check for an array and set the value to null\n        var index = this.__getArrayIndex(lastProperty);\n        if (index) {\n          this.__setTargetValue(targetObject, targetPropertyChain, null);\n          return;\n        }\n\n        // try to reset the property\n        if (target[\"reset\" + qx.lang.String.firstUp(lastProperty)] != undefined) {\n          target[\"reset\" + qx.lang.String.firstUp(lastProperty)]();\n        } else {\n          // fallback if no resetter is given (see bug #2456)\n          if( typeof target[\"set\" + qx.lang.String.firstUp(lastProperty)] != \"function\") {\n            throw new qx.core.AssertionError(\"No setter for '\" + lastProperty + \"' on target \" + target + \".\");\n          }\n          target[\"set\" + qx.lang.String.firstUp(lastProperty)](null);\n        }\n      }\n    },\n\n\n    /**\n     * Sets the given value to the given target after resolving the\n     * target property chain.\n     *\n     * @param targetObject {qx.core.Object} The object where the property chain\n     *   starts.\n     * @param targetPropertyChain {String} The names of the properties,\n     *   separated with a dot.\n     * @param value {var} The value to set.\n     */\n    __setTargetValue : function(targetObject, targetPropertyChain, value)\n    {\n      // get the last target object of the chain\n      var properties = this.__getPropertyChainArray(targetPropertyChain);\n      var target = this.__getTargetFromChain(targetObject, properties);\n      if (target) {\n        // get the name of the last property\n        var lastProperty = properties[properties.length - 1];\n\n        // check for array notation\n        var index = this.__getArrayIndex(lastProperty);\n        if (index) {\n          if (index === \"last\") {\n            // check for the 'last' notation\n            index = target.length - 1;\n          }\n          target.setItem(index, value);\n        } else {\n          if( typeof target[\"set\" + qx.lang.String.firstUp(lastProperty)] != \"function\" ){\n            throw new qx.core.AssertionError(\"No setter for '\" + lastProperty + \"' on target \" + target + \".\");\n          }\n          return target[\"set\" + qx.lang.String.firstUp(lastProperty)](value);\n        }\n      }\n    },\n\n\n    /**\n     * Returns the index from a property using bracket notation, e.g.\n     * \"[42]\" returns \"42\", \"[last]\" returns \"last\"\n     *\n     * @param propertyName {String} A property name\n     * @return {String|null} Array index or null if the property name does\n     * not use bracket notation\n     */\n    __getArrayIndex: function(propertyName) {\n      var arrayExp = /^\\[(\\d+|last)\\]$/;\n        var arrayMatch = propertyName.match(arrayExp);\n        if (arrayMatch) {\n          return  arrayMatch[1];\n        }\n        return null;\n    },\n\n\n    /**\n     * Converts a property chain string into a list of properties and/or\n     * array indexes\n     * @param targetPropertyChain {String} property chain\n     * @return {String[]} Array of property names\n     */\n    __getPropertyChainArray: function(targetPropertyChain) {\n      // split properties (dot notation) and array indexes (bracket notation)\n      return targetPropertyChain.replace(/\\[/g, \".[\").split(\".\")\n        .filter(function(prop) {\n          return prop !== \"\";\n        });\n    },\n\n\n    /**\n     * Helper-Function resolving the object on which the last property of the\n     * chain should be set.\n     *\n     * @param targetObject {qx.core.Object} The object where the property chain\n     *   starts.\n     * @param targetProperties {String[]} Array containing the names of the properties\n     * @param index {Number?} The array index of the last property to be considered.\n     * Default: The last item's index\n     * @return {qx.core.Object | null} The object on which the last property\n     *   should be set.\n     */\n    __getTargetFromChain : function(targetObject, targetProperties, index)\n    {\n      index = index || targetProperties.length - 1;\n      var target = targetObject;\n\n      for (var i = 0; target !== null && i < index; i++) {\n        try {\n          var property = targetProperties[i];\n\n          // array notation\n          var arrIndex = this.__getArrayIndex(property);\n          if (arrIndex) {\n            if (arrIndex === \"last\") {\n              // check for the 'last' notation\n              arrIndex = target.length - 1;\n            }\n            target = target.getItem(arrIndex);\n          }\n          else {\n            target = target[\"get\" + qx.lang.String.firstUp(property)]();\n          }\n        } catch (ex) {\n          return null;\n        }\n      }\n      return target;\n    },\n\n\n    /**\n     * Set the given value to the target property. This method is used for\n     * initially set the value.\n     *\n     * @param value {var} The value to set.\n     * @param targetObject {qx.core.Object} The object which contains the target\n     *   property.\n     * @param targetPropertyChain {String} The name of the target property in the\n     *   target object.\n     * @param options {Map} The options map perhaps containing the user defined\n     *   converter.\n     * @param sourceObject {qx.core.Object} The source object of the binding (\n     *   used for the onUpdate callback).\n     */\n    __setInitialValue : function(value, targetObject, targetPropertyChain, options, sourceObject)\n    {\n      // first convert the initial value\n      value = this.__convertValue(\n        value, targetObject, targetPropertyChain, options, sourceObject\n      );\n      // check if the converted value is undefined\n      if (value === undefined) {\n        this.__resetTargetValue(targetObject, targetPropertyChain);\n      }\n      // only set the initial value if one is given (may be null)\n      if (value !== undefined) {\n        try {\n          var result = this.__setTargetValue(targetObject, targetPropertyChain, value);\n\n          // tell the user that the setter was invoked probably\n          if (options && options.onUpdate) {\n            options.onUpdate(sourceObject, targetObject, value);\n          }\n          return result;\n        } catch (e) {\n          if (! (e instanceof qx.core.ValidationError)) {\n            throw e;\n          }\n\n          if (options && options.onSetFail) {\n            options.onSetFail(e);\n          } else {\n            qx.log.Logger.warn(\n              \"Failed so set value \" + value + \" on \" + targetObject\n               + \". Error message: \" + e\n            );\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Checks for an array element in the given property names and adapts the\n     * arrays to fit the algorithm.\n     *\n     * @param propertyNames {Array} The array containing the property names.\n     *   Attention, this method can change this parameter!!!\n     * @return {Array} An array containing the values of the array properties\n     *   corresponding to the property names.\n     */\n    __checkForArrayInPropertyChain: function(propertyNames) {\n      // array for the values of the array properties\n      var arrayIndexValues = [];\n\n      // go through all properties and check for array notations\n      for (var i = 0; i < propertyNames.length; i++) {\n        var name = propertyNames[i];\n        // if its an array property in the chain\n        if (name.endsWith(\"]\")) {\n          // get the inner value of the array notation\n          var arrayIndex = name.substring(name.indexOf(\"[\") + 1, name.indexOf(\"]\"));\n\n          // check the arrayIndex\n          if (name.indexOf(\"]\") != name.length - 1) {\n            throw new Error(\"Please use only one array at a time: \"\n              + name + \" does not work.\");\n          }\n          if (arrayIndex !== \"last\") {\n            if (arrayIndex == \"\" || isNaN(parseInt(arrayIndex, 10))) {\n              throw new Error(\"No number or 'last' value has been given\"\n                + \" in an array binding: \" + name + \" does not work.\");\n            }\n          }\n\n          // if a property is in front of the array notation\n          if (name.indexOf(\"[\") != 0) {\n            // store the property name without the array notation\n            propertyNames[i] = name.substring(0, name.indexOf(\"[\"));\n            // store the values in the array for the current iteration\n            arrayIndexValues[i] = \"\";\n            // store the properties for the next iteration (the item of the array)\n            arrayIndexValues[i + 1] = arrayIndex;\n            propertyNames.splice(i + 1, 0, \"item\");\n            // skip the next iteration. its the array item and its already set\n            i++;\n          // it the array notation is the beginning\n          } else {\n            // store the array index and override the entry in the property names\n            arrayIndexValues[i] = arrayIndex;\n            propertyNames.splice(i, 1, \"item\");\n          }\n\n        } else {\n          arrayIndexValues[i] = \"\";\n        }\n      }\n\n      return arrayIndexValues;\n    },\n\n\n    /**\n     * Internal helper method which is actually doing all bindings. That means\n     * that an event listener will be added to the source object which listens\n     * to the given event and invokes an set on the target property on the\n     * targetObject.\n     * This method does not store the binding in the internal reference store\n     * so it should NOT be used from outside this class. For an outside usage,\n     * use {@link #bind}.\n     *\n     * @param sourceObject {qx.core.Object} The source of the binding.\n     * @param sourceEvent {String} The event of the source object which could\n     *   be the change event in common but has to be an\n     *   {@link qx.event.type.Data} event.\n     * @param targetObject {qx.core.Object} The object which the source should\n     *   be bind to.\n     * @param targetProperty {String} The property name of the target object.\n     * @param options {Map} A map containing the options. See\n     *   {@link #bind} for more information.\n     * @param arrayIndex {String} The index of the given array if its an array\n     *   to bind.\n     *\n     * @return {var} Returns the internal id for that binding. This can be used\n     *   for referencing the binding or e.g. for removing. This is not an atomic\n     *   id so you can't you use it as a hash-map index. It's the id which will\n     *   be returned by the {@link qx.core.Object#addListener} method.\n     * @throws {qx.core.AssertionError} If the event is no data event or\n     *   there is no property definition for the target object and target\n     *   property.\n     */\n    __bindEventToProperty : function(sourceObject, sourceEvent, targetObject,\n      targetProperty, options, arrayIndex)\n    {\n      // checks\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        // check for the data event\n        var eventType = qx.Class.getEventType(\n          sourceObject.constructor, sourceEvent\n        );\n        qx.core.Assert.assertEquals(\n          \"qx.event.type.Data\", eventType, sourceEvent\n          + \" is not an data (qx.event.type.Data) event on \"\n          + sourceObject + \".\"\n        );\n      }\n\n      var bindListener = function(arrayIndex, e) {\n        // if an array value is given\n        if (arrayIndex !== \"\") {\n          //check if its the \"last\" value\n          if (arrayIndex === \"last\") {\n            arrayIndex = sourceObject.length - 1;\n          }\n\n          // get the data of the array\n          var data = sourceObject.getItem(arrayIndex);\n\n          // reset the target if the data is not set\n          if (data === undefined) {\n            qx.data.SingleValueBinding.__resetTargetValue(targetObject, targetProperty);\n          }\n\n          // only do something if the current array has been changed\n          var start = e.getData().start;\n          var end = e.getData().end;\n          if (arrayIndex < start || arrayIndex > end) {\n            return;\n          }\n        } else {\n          // get the data out of the event\n          var data = e.getData();\n        }\n\n        // debug message\n        if (qx.core.Environment.get(\"qx.debug.databinding\")) {\n          qx.log.Logger.debug(\"Binding executed from \" + sourceObject + \" by \" +\n            sourceEvent + \" to \" + targetObject + \" (\" + targetProperty + \")\");\n          qx.log.Logger.debug(\"Data before conversion: \" + data);\n        }\n\n        // convert the data\n        data = qx.data.SingleValueBinding.__convertValue(\n          data, targetObject, targetProperty, options, sourceObject\n        );\n\n        // debug message\n        if (qx.core.Environment.get(\"qx.debug.databinding\")) {\n          qx.log.Logger.debug(\"Data after conversion: \" + data);\n        }\n\n        // try to set the value\n        var result;\n        try {\n          if (data !== undefined) {\n            result = qx.data.SingleValueBinding.__setTargetValue(targetObject, targetProperty, data);\n          } else {\n          \tresult = qx.data.SingleValueBinding.__resetTargetValue(targetObject, targetProperty);\n          }\n\n          // tell the user that the setter was invoked probably\n          if (options && options.onUpdate) {\n            options.onUpdate(sourceObject, targetObject, data);\n          }\n\n        } catch (ex) {\n          if (! (ex instanceof qx.core.ValidationError)) {\n            throw ex;\n          }\n\n          if (options && options.onSetFail) {\n            options.onSetFail(ex);\n          } else {\n            qx.log.Logger.warn(\n              \"Failed so set value \" + data + \" on \" + targetObject\n               + \". Error message: \" + ex\n            );\n          }\n        }\n        return result;\n      };\n\n      // check if an array index is given\n      if (!arrayIndex) {\n        // if not, signal it a s an empty string\n        arrayIndex = \"\";\n      }\n      // bind the listener function (make the array index in the listener available)\n      bindListener = qx.lang.Function.bind(bindListener, sourceObject, arrayIndex);\n\n      // add the listener\n      var id = sourceObject.addListener(sourceEvent, bindListener);\n\n      return id;\n    },\n\n\n    /**\n     * This method stores the given value as a binding in the internal structure\n     * of all bindings.\n     *\n     * @param id {var} The listener id of the id for a deeper binding.\n     * @param sourceObject {qx.core.Object} The source Object of the binding.\n     * @param sourceEvent {String} The name of the source event.\n     * @param targetObject {qx.core.Object} The target object.\n     * @param targetProperty {String} The name of the property on the target\n     *   object.\n     */\n    __storeBinding : function(\n      id, sourceObject, sourceEvent, targetObject, targetProperty\n    )\n    {\n      var hash;\n\n      // add the listener id to the internal registry\n      hash = sourceObject.toHashCode();\n      if (this.__bindings[hash] === undefined) {\n        this.__bindings[hash] = [];\n      }\n\n      var binding = [id, sourceObject, sourceEvent, targetObject, targetProperty];\n      this.__bindings[hash].push(binding);\n\n\n      // add same binding data indexed by target object\n      hash = targetObject.toHashCode();\n      if (this.__bindingsByTarget[hash] === undefined) {\n        this.__bindingsByTarget[hash] = [];\n      }\n      this.__bindingsByTarget[hash].push(binding);\n    },\n\n\n    /**\n     * This method takes the given value, checks if the user has given a\n     * converter and converts the value to its target type. If no converter is\n     * given by the user, the {@link #__defaultConversion} will try to convert\n     * the value.\n     *\n     * @param value {var} The value which possibly should be converted.\n     * @param targetObject {qx.core.Object} The target object.\n     * @param targetPropertyChain {String} The property name of the target object.\n     * @param options {Map} The options map which can includes the converter.\n     *   For a detailed information on the map, take a look at\n     *   {@link #bind}.\n     * @param sourceObject {qx.core.Object} The source object for the binding.\n     *\n     * @return {var} The converted value. If no conversion has been done, the\n     *   value property will be returned.\n     * @throws {qx.core.AssertionError} If there is no property definition\n     *   of the given target object and target property.\n     */\n    __convertValue : function(\n      value, targetObject, targetPropertyChain, options, sourceObject\n    ) {\n      // do the conversion given by the user\n      if (options && options.converter) {\n        var model;\n        if (targetObject.getModel) {\n          model = targetObject.getModel();\n        }\n        return options.converter(value, model, sourceObject, targetObject);\n      // try default conversion\n      } else {\n        var properties = this.__getPropertyChainArray(targetPropertyChain);\n        var target = this.__getTargetFromChain(targetObject, properties);\n        var lastProperty = targetPropertyChain.substring(\n          targetPropertyChain.lastIndexOf(\".\") + 1, targetPropertyChain.length\n        );\n        // if no target is currently available, return the original value\n        if (target == null) {\n          return value;\n        }\n\n        var propertieDefinition = qx.Class.getPropertyDefinition(\n          target.constructor, lastProperty\n        );\n        var check = propertieDefinition == null ? \"\" : propertieDefinition.check;\n        return this.__defaultConversion(value, check);\n      }\n    },\n\n\n    /**\n     * Helper method which tries to figure out if the given property on the\n     * given object does have a change event and if returns the name of it.\n     *\n     * @param sourceObject {qx.core.Object} The object to check.\n     * @param sourceProperty {String} The name of the property.\n     *\n     * @return {String} The name of the change event.\n     * @throws {qx.core.AssertionError} If there is no property definition of\n     *   the given object property pair.\n     */\n    __getEventForProperty : function(sourceObject, sourceProperty) {\n      // get the event name\n      var propertieDefinition =  qx.Class.getPropertyDefinition(\n        sourceObject.constructor, sourceProperty\n      );\n\n      if (propertieDefinition == null) {\n        return null;\n      }\n      return propertieDefinition.event;\n    },\n\n\n    /**\n     * Tries to convert the data to the type given in the targetCheck argument.\n     *\n     * @param data {var} The data to convert.\n     * @param targetCheck {String} The value of the check property. That usually\n     *   contains the target type.\n     * @return {Integer|String|Float} The converted data\n     */\n    __defaultConversion : function(data, targetCheck) {\n      var dataType = qx.lang.Type.getClass(data);\n\n      // to integer\n      if ((dataType == \"Number\" || dataType == \"String\") &&\n          (targetCheck == \"Integer\" || targetCheck == \"PositiveInteger\")) {\n        data = parseInt(data, 10);\n      }\n\n      // to string\n      if ((dataType == \"Boolean\" || dataType == \"Number\" || dataType == \"Date\")\n        && targetCheck == \"String\") {\n        data = data + \"\";\n      }\n\n      // to float\n      if ((dataType == \"Number\" || dataType == \"String\") &&\n        (targetCheck == \"Number\" || targetCheck == \"PositiveNumber\")) {\n        data = parseFloat(data);\n      }\n\n      return data;\n    },\n\n\n    /**\n     * Removes the binding with the given id from the given sourceObject. The\n     * id has to be the id returned by any of the bind functions.\n     *\n     * @param sourceObject {qx.core.Object} The source object of the binding.\n     * @param id {var} The id of the binding.\n     * @throws {Error} If the binding could not be found.\n     */\n    removeBindingFromObject : function(sourceObject, id) {\n      // check for a deep binding\n      if (id.type == \"deepBinding\") {\n        // go through all added listeners (source)\n        for (var i = 0; i < id.sources.length; i++) {\n          // check if a source is available\n          if (id.sources[i]) {\n            id.sources[i].removeListenerById(id.listenerIds[i]);\n          }\n        }\n        // go through all added listeners (target)\n        for (var i = 0; i < id.targets.length; i++) {\n          // check if a target is available\n          if (id.targets[i]) {\n            id.targets[i].removeListenerById(id.targetListenerIds[i]);\n          }\n        }\n      } else {\n        // remove the listener\n        sourceObject.removeListenerById(id);\n      }\n\n      // remove the id from the internal reference system\n      var bindings = this.getAllBindingsForObject(sourceObject);\n      // check if the binding exists\n      if (bindings != undefined) {\n        for (var i = 0; i < bindings.length; i++) {\n          if (bindings[i][0] == id) {\n            // remove binding data from internal reference indexed by target object\n            var target = bindings[i][3];\n            if (this.__bindingsByTarget[target.toHashCode()]) {\n              qx.lang.Array.remove(this.__bindingsByTarget[target.toHashCode()], bindings[i]);\n            }\n\n            // remove binding data from internal reference indexed by source object\n            var source = bindings[i][1];\n            if (this.__bindings[source.toHashCode()]) {\n              qx.lang.Array.remove(this.__bindings[source.toHashCode()], bindings[i]);\n            }\n            return;\n          }\n        }\n      }\n      throw new Error(\"Binding could not be found!\");\n    },\n\n\n    /**\n     * Removes all bindings for the given object.\n     *\n     * @param object {qx.core.Object} The object of which the bindings should be\n     *   removed.\n     * @throws {qx.core.AssertionError} If the object is not in the internal\n     *   registry of the bindings.\n     * @throws {Error} If one of the bindings listed internally can not be\n     *   removed.\n     */\n    removeAllBindingsForObject : function(object) {\n      // check for the null value\n\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertNotNull(object,\n          \"Can not remove the bindings for null object!\");\n      }\n\n      // get the bindings\n      var bindings = this.getAllBindingsForObject(object);\n      if (bindings != undefined)\n      {\n        // remove every binding with the removeBindingFromObject function\n        for (var i = bindings.length - 1; i >= 0; i--) {\n          this.removeBindingFromObject(object, bindings[i][0]);\n        }\n      }\n    },\n\n\n    /**\n     * Removes all bindings between given objects.\n     *\n     * @param object {qx.core.Object} The object of which the bindings should be\n     *   removed.\n     * @param relatedObject {qx.core.Object} The object of which related\n     *   bindings should be removed.\n     * @throws {qx.core.AssertionError} If the object is not in the internal\n     *   registry of the bindings.\n     * @throws {Error} If one of the bindings listed internally can not be\n     *   removed.\n     */\n    removeRelatedBindings : function(object, relatedObject) {\n      // check for the null value\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert.assertNotNull(object,\n          \"Can not remove the bindings for null object!\");\n        qx.core.Assert.assertNotNull(relatedObject,\n          \"Can not remove the bindings for null object!\");\n      }\n\n      // get the bindings\n      var bindings = this.getAllBindingsForObject(object);\n      if (bindings != undefined)\n      {\n        // remove every binding with the removeBindingFromObject function\n        for (var i = bindings.length - 1; i >= 0; i--) {\n          var source = bindings[i][1];\n          var target = bindings[i][3];\n          if (source === relatedObject || target === relatedObject) {\n            this.removeBindingFromObject(object, bindings[i][0]);\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Returns an array which lists all bindings.\n     *\n     * @param object {qx.core.Object} The object of which the bindings should\n     *   be returned.\n     *\n     * @return {Array} An array of binding informations. Every binding\n     *   information is an array itself containing id, sourceObject,\n     *   sourceEvent, targetObject and targetProperty in that order.\n     */\n    getAllBindingsForObject : function(object) {\n      var hash = object.toHashCode();\n      // create an empty array if no binding exists\n      if (this.__bindings[hash] === undefined) {\n        this.__bindings[hash] = [];\n      }\n\n      // get all bindings of object as source\n      var sourceBindings = this.__bindings[hash];\n\n      // get all bindings of object as target\n      var targetBindings = this.__bindingsByTarget[hash] ? this.__bindingsByTarget[hash] : [];\n\n      return qx.lang.Array.unique(sourceBindings.concat(targetBindings));\n    },\n\n\n    /**\n     * Removes all binding in the whole application. After that not a single\n     * binding is left.\n     * @deprecated {6.0} dispose and destructors are deprecated because of automatic memory management; this\n     * will only work for objects explicitly registered with ObjectRegistry.register\n     */\n    removeAllBindings : function() {\n      // go through all registered objects\n      for (var hash in this.__bindings) {\n        var object = qx.core.ObjectRegistry.fromHashCode(hash);\n        // check for the object, perhaps its already deleted\n        if (object == null) {\n          delete this.__bindings[hash];\n          continue;\n        }\n        this.removeAllBindingsForObject(object);\n      }\n      // reset the bindings map\n      this.__bindings = {};\n    },\n\n\n    /**\n     * Returns a map containing for every bound object an array of data binding\n     * information. The key of the map is the hash code of the bound objects.\n     * Every binding is represented by an array containing id, sourceObject,\n     * sourceEvent, targetObject and targetProperty.\n     *\n     * @return {Map} Map containing all bindings.\n     */\n    getAllBindings : function() {\n      return this.__bindings;\n    },\n\n\n    /**\n     * Debug function which shows some valuable information about the given\n     * binding in console. For that it uses {@link qx.log.Logger}.\n     *\n     * @param object {qx.core.Object} the source of the binding.\n     * @param id {var} The id of the binding.\n     */\n    showBindingInLog : function(object, id) {\n      var binding;\n      // go through all bindings of the given object\n      for (var i = 0; i < this.__bindings[object.toHashCode()].length; i++) {\n        // the first array item is the id\n        if (this.__bindings[object.toHashCode()][i][0] == id) {\n          binding = this.__bindings[object.toHashCode()][i];\n          break;\n        }\n      }\n\n      if (binding === undefined) {\n        var message = \"Binding does not exist!\"\n      } else {\n        var message = \"Binding from '\" + binding[1] + \"' (\" + binding[2] +\n          \") to the object '\" + binding[3] + \"' (\"+ binding[4] + \").\";\n      }\n\n      qx.log.Logger.debug(message);\n    },\n\n\n    /**\n     * Debug function which shows all bindings in the log console. To get only\n     * one binding in the console use {@link #showBindingInLog}\n     * @deprecated {6.0} qx.core.ObjectRegistry no longer stores most objects\n     */\n    showAllBindingsInLog : function() {\n      // go through all objects in the registry\n      for (var hash in this.__bindings) {\n        var object = qx.core.ObjectRegistry.fromHashCode(hash);\n        if (object) {\n\t        for (var i = 0; i < this.__bindings[hash].length; i++) {\n\t          this.showBindingInLog(object, this.__bindings[hash][i][0]);\n\t        }\n        }\n      }\n    }\n\n  }\n});\n"
  ]
}