{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/data/controller/MSelection.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Mixin",
    "define",
    "construct",
    "Class",
    "hasProperty",
    "constructor",
    "Error",
    "getSelection",
    "__ownSelection",
    "data",
    "Array",
    "setSelection",
    "properties",
    "selection",
    "check",
    "event",
    "apply",
    "init",
    "events",
    "members",
    "_modifingSelection",
    "__selectionListenerId",
    "__selectionArrayListenerId",
    "setValue",
    "resetSelection",
    "getValue",
    "resetValue",
    "_applySelection",
    "value",
    "old",
    "undefined",
    "removeListenerById",
    "addListener",
    "__changeSelectionArray",
    "_updateSelection",
    "_changeTargetSelection",
    "getTarget",
    "__targetSupportsMultiSelection",
    "__targetSupportsSingleSelection",
    "_inSelectionModification",
    "targetSelection",
    "spliceArgs",
    "getLength",
    "i",
    "length",
    "model",
    "getModel",
    "push",
    "splice",
    "dispose",
    "fireDataEvent",
    "_addChangeTargetListener",
    "_startSelectionModification",
    "getItem",
    "selectable",
    "__getSelectableForModel",
    "targetSelectionItems",
    "includes",
    "item",
    "__selectItem",
    "_endSelectionModification",
    "targetClass",
    "implementsInterface",
    "ui",
    "core",
    "IMultiSelection",
    "ISingleSelection",
    "addToSelection",
    "children",
    "getSelectables",
    "destruct",
    "controller",
    "MSelection"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;AAAAA,KAAGC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC,EA0BAH,GAAGI,KAAH,CAASC,MAAT,CAAgB,+BAAhB,EACA;;AAEE;;;;;;AAMAC,eAAY,qBACZ;AACE;AACA,UAAI,CAACN,GAAGO,KAAH,CAASC,WAAT,CAAqB,KAAKC,WAA1B,EAAuC,QAAvC,CAAL,EAAuD;AACrD,cAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED;AACA,UAAI,KAAKC,YAAL,MAAuB,IAA3B,EAAiC;AAC/B,aAAKC,cAAL,GAAsB,IAAIZ,GAAGa,IAAH,CAAQC,KAAZ,EAAtB;AACA,aAAKC,YAAL,CAAkB,KAAKH,cAAvB;AACD;AACF,KApBH;;AAwBE;;;;;;AAMAI,gBAAa;AACX;;;;;AAKAC,iBACA;AACEC,eAAO,eADT;AAEEC,eAAO,iBAFT;AAGEC,eAAO,iBAHT;AAIEC,cAAM;AAJR;AAPW,KA9Bf;;AA8CEC,YAAS;AACP;;;;;;;;AAQA,yBAAoB,oBATb;;AAWP;AACA,qBAAgB;AAZT,KA9CX;;AA8DE;;;;;;AAMAC,aACA;AACE;AACA;AACAC,0BAAqB,CAHvB;AAIEC,6BAAwB,IAJ1B;AAKEC,kCAA6B,IAL/B;AAMEd,sBAAiB,IANnB;;AASE;;;;;;AAMAe,gBAAW,kBAASV,SAAT,EAAoB;AAC7B,YAAI,SAASA,SAAb,EAAwB;AACtB,eAAKW,cAAL;AACD,SAFD,MAEO;AACL,eAAKb,YAAL,CAAkBE,SAAlB;AACD;;AAED,eAAO,IAAP;AACD,OAvBH;;AA0BE;;;;;AAKAY,gBAAW,oBAAW;AACpB,eAAO,KAAKlB,YAAL,EAAP;AACD,OAjCH;;AAoCE;;;AAGAmB,kBAAa,sBAAW;AACtB,aAAKF,cAAL;AACD,OAzCH;;AA6CE;;;;;AAKA;;;;;;;AAOAG,uBAAiB,yBAASC,KAAT,EAAgBC,GAAhB,EAAqB;AACpC;AACA,YAAI,KAAKP,0BAAL,IAAmCQ,SAAnC,IAAgDD,OAAOC,SAA3D,EAAsE;AACpED,cAAIE,kBAAJ,CAAuB,KAAKT,0BAA5B;AACA,eAAKA,0BAAL,GAAkC,IAAlC;AACD;AACD;AACA,YAAIM,KAAJ,EAAW;AACT,eAAKN,0BAAL,GAAkCM,MAAMI,WAAN,CAChC,QADgC,EACtB,KAAKC,sBADiB,EACO,IADP,CAAlC;AAGD;;AAED;AACA,aAAKC,gBAAL;AACD,OAxEH;;AA2EE;;;;;AAKA;;;;;AAKAD,8BAAwB,kCAAW;AACjC,aAAKC,gBAAL;AACD,OAvFH;;AA0FE;;;;;AAKAC,8BAAwB,kCAAW;AACjC;AACA,YAAI,KAAKC,SAAL,MAAoB,IAAxB,EAA8B;AAC5B;AACD;;AAED;AACA,YAAI,CAAC,KAAKC,8BAAL,EAAD,IACC,CAAC,KAAKC,+BAAL,EADN,EAC8C;AAC5C;AACD;;AAED;AACA,YAAI,KAAKC,wBAAL,EAAJ,EAAqC;AACnC;AACD;;AAED;AACA,YAAIC,kBAAkB,KAAKJ,SAAL,GAAiB7B,YAAjB,EAAtB;AACA,YAAIM,YAAY,KAAKN,YAAL,EAAhB;AACA,YAAIM,aAAa,IAAjB,EAAuB;AACrBA,sBAAY,IAAIjB,GAAGa,IAAH,CAAQC,KAAZ,EAAZ;AACA,eAAKF,cAAL,GAAsBK,SAAtB;AACA,eAAKF,YAAL,CAAkBE,SAAlB;AACD;;AAED;AACA,YAAI4B,aAAa,CAAC,CAAD,EAAI5B,UAAU6B,SAAV,EAAJ,CAAjB;AACA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIH,gBAAgBI,MAApC,EAA4CD,GAA5C,EAAiD;AAC/C,cAAIE,QAAQL,gBAAgBG,CAAhB,EAAmBG,QAAnB,EAAZ;AACA,cAAID,UAAU,IAAd,EAAoB;AAClBJ,uBAAWM,IAAX,CAAgBF,KAAhB;AACD;AACF;AACD;AACAhC,kBAAUmC,MAAV,CAAiBhC,KAAjB,CAAuBH,SAAvB,EAAkC4B,UAAlC,EAA8CQ,OAA9C;;AAEA;AACA,aAAKC,aAAL,CAAmB,iBAAnB,EAAsC,KAAK3C,YAAL,EAAtC;AACD,OAtIH;;AAyIE;;;;;AAKA;;;;;;;AAOA4C,gCAA0B,kCAASvB,KAAT,EAAgBC,GAAhB,EAAqB;AAC7C;AACA,YAAI,KAAKR,qBAAL,IAA8BS,SAA9B,IAA2CD,OAAOC,SAAtD,EAAiE;AAC/DD,cAAIE,kBAAJ,CAAuB,KAAKV,qBAA5B;AACD;;AAED,YAAIO,SAAS,IAAb,EAAmB;AACjB;AACA,cACE,KAAKS,8BAAL,MACG,KAAKC,+BAAL,EAFL,EAGE;AACA;AACA,iBAAKjB,qBAAL,GAA6BO,MAAMI,WAAN,CAC3B,iBAD2B,EACR,KAAKG,sBADG,EACqB,IADrB,CAA7B;AAGD;AACF;AACF,OAvKH;;AA0KE;;;;;AAKAD,wBAAkB,4BAAW;AAC3B;AACA,YAAI,CAAC,KAAKE,SAAL,EAAD,IAAqB,CAAC,KAAK7B,YAAL,EAA1B,EAA+C;AAC7C;AACD;AACD;AACA,aAAK6C,2BAAL;;AAEA;AACA,YAAI,KAAKf,8BAAL,EAAJ,EAA2C;;AAEzC,cAAIG,kBAAkB,EAAtB;AACA;AACA,eAAK,IAAIG,IAAI,CAAb,EAAgBA,IAAI,KAAKpC,YAAL,GAAoBqC,MAAxC,EAAgDD,GAAhD,EAAqD;AACnD;AACA,gBAAIE,QAAQ,KAAKtC,YAAL,GAAoB8C,OAApB,CAA4BV,CAA5B,CAAZ;AACA,gBAAIW,aAAa,KAAKC,uBAAL,CAA6BV,KAA7B,CAAjB;AACA,gBAAIS,cAAc,IAAlB,EAAwB;AACtBd,8BAAgBO,IAAhB,CAAqBO,UAArB;AACD;AACF;AACD,eAAKlB,SAAL,GAAiBzB,YAAjB,CAA8B6B,eAA9B;;AAEA;AACAA,4BAAkB,KAAKJ,SAAL,GAAiB7B,YAAjB,EAAlB;AACA;AACA,cAAIiD,uBAAuB,EAA3B;AACA,eAAK,IAAIb,IAAI,CAAb,EAAgBA,IAAIH,gBAAgBI,MAApC,EAA4CD,GAA5C,EAAiD;AAC/Ca,iCAAqBb,CAArB,IAA0BH,gBAAgBG,CAAhB,EAAmBG,QAAnB,EAA1B;AACD;;AAED;AACA,eAAK,IAAIH,IAAI,KAAKpC,YAAL,GAAoBqC,MAApB,GAA6B,CAA1C,EAA6CD,KAAK,CAAlD,EAAqDA,GAArD,EAA0D;AACxD;AACA,gBAAI,CAACa,qBAAqBC,QAArB,CAA8B,KAAKlD,YAAL,GAAoB8C,OAApB,CAA4BV,CAA5B,CAA9B,CAAL,EAAoE;AAClE;AACA,mBAAKpC,YAAL,GAAoByC,MAApB,CAA2BL,CAA3B,EAA8B,CAA9B,EAAiCM,OAAjC;AACD;AACF;;AAEH;AACC,SAhCD,MAgCO,IAAI,KAAKX,+BAAL,EAAJ,EAA4C;AACjD;AACA,cAAIoB,OAAO,KAAKnD,YAAL,GAAoB8C,OAApB,CAA4B,KAAK9C,YAAL,GAAoBqC,MAApB,GAA6B,CAAzD,CAAX;AACA,cAAIc,SAAS5B,SAAb,EAAwB;AACtB;AACA,iBAAK6B,YAAL,CAAkBD,IAAlB;AACA;AACA;AACA,iBAAKnD,YAAL,GAAoByC,MAApB,CACE,CADF,EACK,KAAKzC,YAAL,GAAoBmC,SAApB,KAAkC,CADvC,EAEEO,OAFF;AAGD,WARD,MAQO;AACL;AACA;AACA,iBAAKb,SAAL,GAAiBZ,cAAjB;AACD;AAEF;;AAED;AACA,aAAKoC,yBAAL;AACA,aAAKV,aAAL,CAAmB,aAAnB,EAAkC,KAAK3C,YAAL,EAAlC;AACD,OA9OH;;AAiPE;;;;AAIA8B,sCAAgC,0CAAW;AACzC,YAAIwB,cAAc,KAAKzB,SAAL,GAAiB/B,WAAnC;AACA,eAAOT,GAAGO,KAAH,CAAS2D,mBAAT,CAA6BD,WAA7B,EAA0CjE,GAAGmE,EAAH,CAAMC,IAAN,CAAWC,eAArD,CAAP;AACD,OAxPH;;AA2PE;;;;AAIA3B,uCAAiC,2CAAW;AAC1C,YAAIuB,cAAc,KAAKzB,SAAL,GAAiB/B,WAAnC;AACA,eAAOT,GAAGO,KAAH,CAAS2D,mBAAT,CAA6BD,WAA7B,EAA0CjE,GAAGmE,EAAH,CAAMC,IAAN,CAAWE,gBAArD,CAAP;AACD,OAlQH;;AAqQE;;;;;;AAMAP,oBAAc,sBAASD,IAAT,EAAe;AAC3B,YAAIJ,aAAa,KAAKC,uBAAL,CAA6BG,IAA7B,CAAjB;AACA;AACA,YAAIJ,cAAc,IAAlB,EAAwB;AACtB;AACD;AACD;AACA,YAAI,KAAKjB,8BAAL,EAAJ,EAA2C;AACzC;AACA,eAAKD,SAAL,GAAiB+B,cAAjB,CAAgCb,UAAhC;AACF;AACC,SAJD,MAIO,IAAI,KAAKhB,+BAAL,EAAJ,EAA4C;AACjD,eAAKF,SAAL,GAAiBzB,YAAjB,CAA8B,CAAC2C,UAAD,CAA9B;AACD;AACF,OAzRH;;AA4RE;;;;;;AAMAC,+BAA0B,iCAASV,KAAT,EAC1B;AACE;AACA,YAAIuB,WAAW,KAAKhC,SAAL,GAAiBiC,cAAjB,CAAgC,IAAhC,CAAf;;AAEA;AACA,aAAK,IAAI1B,IAAI,CAAb,EAAgBA,IAAIyB,SAASxB,MAA7B,EAAqCD,GAArC,EAA0C;AACxC,cAAIyB,SAASzB,CAAT,EAAYG,QAAZ,MAA0BD,KAA9B,EAAqC;AACnC,mBAAOuB,SAASzB,CAAT,CAAP;AACD;AACF;AACD;AACA,eAAO,IAAP;AACD,OA/SH;;AAkTE;;;;;AAKAS,mCAA6B,uCAAW;AACtC,aAAKhC,kBAAL;AACD,OAzTH;;AA4TE;;;;;AAKAwC,iCAA2B,qCAAW;AACpC,aAAKxC,kBAAL,GAA0B,CAA1B,GAA8B,KAAKA,kBAAL,EAA9B,GAA0D,IAA1D;AACD,OAnUH;;AAsUE;;;;;;AAMAmB,gCAA0B,oCAAW;AACnC,eAAO,KAAKnB,kBAAL,GAA0B,CAAjC;AACD;;AA9UH,KArEF;;AAwZE;;;;;;AAMAkD,cAAW,oBACX;AACE,UAAI,KAAK9D,cAAT,EAAyB;AACvB,aAAKA,cAAL,CAAoByC,OAApB;AACD;AACF;AAnaH,GADA,C;AA1BArD,KAAGa,IAAH,CAAQ8D,UAAR,CAAmBC,UAAnB,CAA8BzE,aAA9B,GAA8CA,aAA9C",
  "file": "MSelection.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (martinwittemann)\n\n************************************************************************ */\n\n/**\n * Mixin for the selection in the data binding controller.\n * It contains an selection property which can be manipulated.\n * Remember to call the method {@link #_addChangeTargetListener} on every\n * change of the target.\n * It is also important that the elements stored in the target e.g. ListItems\n * do have the corresponding model stored as user data under the \"model\" key.\n */\nqx.Mixin.define(\"qx.data.controller.MSelection\",\n{\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct : function()\n  {\n    // check for a target property\n    if (!qx.Class.hasProperty(this.constructor, \"target\")) {\n      throw new Error(\"Target property is needed.\");\n    }\n\n    // create a default selection array\n    if (this.getSelection() == null) {\n      this.__ownSelection = new qx.data.Array();\n      this.setSelection(this.__ownSelection);\n    }\n  },\n\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties : {\n    /**\n     * Data array containing the selected model objects. This property can be\n     * manipulated directly which means that a push to the selection will also\n     * select the corresponding element in the target.\n     */\n    selection :\n    {\n      check: \"qx.data.Array\",\n      event: \"changeSelection\",\n      apply: \"_applySelection\",\n      init: null\n    }\n  },\n\n\n  events : {\n    /**\n     * This event is fired as soon as the content of the selection property changes, but\n     * this is not equal to the change of the selection of the widget. If the selection\n     * of the widget changes, the content of the array stored in the selection property\n     * changes. This means you have to listen to the change event of the selection array\n     * to get an event as soon as the user changes the selected item.\n     * <pre class=\"javascript\">obj.getSelection().addListener(\"change\", listener, this);</pre>\n     */\n    \"changeSelection\" : \"qx.event.type.Data\",\n\n    /** Fires after the value was modified */\n    \"changeValue\" : \"qx.event.type.Data\"\n  },\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    // private members //\n    // set the semaphore-like variable for the selection change\n    _modifingSelection : 0,\n    __selectionListenerId : null,\n    __selectionArrayListenerId : null,\n    __ownSelection : null,\n\n\n    /**\n     * setValue implements part of the {@link qx.ui.form.IField} interface.\n     *\n     * @param selection {qx.data.IListData|null} List data to select as value.\n     * @return {null} The status of this operation.\n     */\n    setValue : function(selection) {\n      if (null === selection) {\n        this.resetSelection();\n      } else {\n        this.setSelection(selection);\n      }\n\n      return null;\n    },\n\n\n    /**\n     * getValue implements part of the {@link qx.ui.form.IField} interface.\n     *\n     * @return {qx.data.IListData} The current selection.\n     */\n    getValue : function() {\n      return this.getSelection();\n    },\n\n\n    /**\n     * resetValue implements part of the {@link qx.ui.form.IField} interface.\n     */\n    resetValue : function() {\n      this.resetSelection();\n    },\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n       APPLY METHODS\n    ---------------------------------------------------------------------------\n    */\n    /**\n     * Apply-method for setting a new selection array. Only the change listener\n     * will be removed from the old array and added to the new.\n     *\n     * @param value {qx.data.Array} The new data array for the selection.\n     * @param old {qx.data.Array|null} The old data array for the selection.\n     */\n    _applySelection: function(value, old) {\n      // remove the old listener if necessary\n      if (this.__selectionArrayListenerId != undefined && old != undefined) {\n        old.removeListenerById(this.__selectionArrayListenerId);\n        this.__selectionArrayListenerId = null;\n      }\n      // add a new change listener to the changeArray\n      if (value) {\n        this.__selectionArrayListenerId = value.addListener(\n          \"change\", this.__changeSelectionArray, this\n        );\n      }\n\n      // apply the new selection\n      this._updateSelection();\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n       EVENT HANDLER\n    ---------------------------------------------------------------------------\n    */\n    /**\n     * Event handler for the change of the data array holding the selection.\n     * If a change is in the selection array, the selection update will be\n     * invoked.\n     */\n    __changeSelectionArray: function() {\n      this._updateSelection();\n    },\n\n\n    /**\n     * Event handler for a change in the target selection.\n     * If the selection in the target has changed, the selected model objects\n     * will be found and added to the selection array.\n     */\n    _changeTargetSelection: function() {\n      // dont do anything without a target\n      if (this.getTarget() == null) {\n        return;\n      }\n\n      // if a selection API is supported\n      if (!this.__targetSupportsMultiSelection()\n        && !this.__targetSupportsSingleSelection()) {\n        return;\n      }\n\n      // if __changeSelectionArray is currently working, do nothing\n      if (this._inSelectionModification()) {\n        return;\n      }\n\n      // get both selections\n      var targetSelection = this.getTarget().getSelection();\n      var selection = this.getSelection();\n      if (selection == null) {\n        selection = new qx.data.Array();\n        this.__ownSelection = selection;\n        this.setSelection(selection);\n      }\n\n      // go through the target selection\n      var spliceArgs = [0, selection.getLength()];\n      for (var i = 0; i < targetSelection.length; i++) {\n        var model = targetSelection[i].getModel();\n        if (model !== null) {\n          spliceArgs.push(model);\n        }\n      }\n      // use splice to ensure a correct change event [BUG #4728]\n      selection.splice.apply(selection, spliceArgs).dispose();\n\n      // fire the change event manually\n      this.fireDataEvent(\"changeSelection\", this.getSelection());\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n       SELECTION\n    ---------------------------------------------------------------------------\n    */\n    /**\n     * Helper method which should be called by the classes including this\n     * Mixin when the target changes.\n     *\n     * @param value {qx.ui.core.Widget|null} The new target.\n     * @param old {qx.ui.core.Widget|null} The old target.\n     */\n    _addChangeTargetListener: function(value, old) {\n      // remove the old selection listener\n      if (this.__selectionListenerId != undefined && old != undefined) {\n        old.removeListenerById(this.__selectionListenerId);\n      }\n\n      if (value != null) {\n        // if a selection API is supported\n        if (\n          this.__targetSupportsMultiSelection()\n          || this.__targetSupportsSingleSelection()\n        ) {\n          // add a new selection listener\n          this.__selectionListenerId = value.addListener(\n            \"changeSelection\", this._changeTargetSelection, this\n          );\n        }\n      }\n    },\n\n\n    /**\n     * Method for updating the selection. It checks for the case of single or\n     * multi selection and after that checks if the selection in the selection\n     * array is the same as in the target widget.\n     */\n    _updateSelection: function() {\n      // do not update if no target is given\n      if (!this.getTarget() || !this.getSelection()) {\n        return;\n      }\n      // mark the change process in a flag\n      this._startSelectionModification();\n\n      // if its a multi selection target\n      if (this.__targetSupportsMultiSelection()) {\n\n        var targetSelection = [];\n        // go through the selection array\n        for (var i = 0; i < this.getSelection().length; i++) {\n          // store each item\n          var model = this.getSelection().getItem(i);\n          var selectable = this.__getSelectableForModel(model);\n          if (selectable != null) {\n            targetSelection.push(selectable);\n          }\n        }\n        this.getTarget().setSelection(targetSelection);\n\n        // get the selection of the target\n        targetSelection = this.getTarget().getSelection();\n        // get all items selected in the list\n        var targetSelectionItems = [];\n        for (var i = 0; i < targetSelection.length; i++) {\n          targetSelectionItems[i] = targetSelection[i].getModel();\n        }\n\n        // go through the controller selection\n        for (var i = this.getSelection().length - 1; i >= 0; i--) {\n          // if the item in the controller selection is not selected in the list\n          if (!targetSelectionItems.includes(this.getSelection().getItem(i))) {\n            // remove the current element and get rid of the return array\n            this.getSelection().splice(i, 1).dispose();\n          }\n        }\n\n      // if its a single selection target\n      } else if (this.__targetSupportsSingleSelection()) {\n        // get the model which should be selected\n        var item = this.getSelection().getItem(this.getSelection().length - 1);\n        if (item !== undefined) {\n          // select the last selected item (old selection will be removed anyway)\n          this.__selectItem(item);\n          // remove the other items from the selection data array and get\n          // rid of the return array\n          this.getSelection().splice(\n            0, this.getSelection().getLength() - 1\n          ).dispose();\n        } else {\n          // if there is no item to select (e.g. new model set [BUG #4125]),\n          // reset the selection\n          this.getTarget().resetSelection();\n        }\n\n      }\n\n      // reset the changing flag\n      this._endSelectionModification();\n      this.fireDataEvent(\"changeValue\", this.getSelection());\n    },\n\n\n    /**\n     * Helper-method returning true, if the target supports multi selection.\n     * @return {Boolean} true, if the target supports multi selection.\n     */\n    __targetSupportsMultiSelection: function() {\n      var targetClass = this.getTarget().constructor;\n      return qx.Class.implementsInterface(targetClass, qx.ui.core.IMultiSelection);\n    },\n\n\n    /**\n     * Helper-method returning true, if the target supports single selection.\n     * @return {Boolean} true, if the target supports single selection.\n     */\n    __targetSupportsSingleSelection: function() {\n      var targetClass = this.getTarget().constructor;\n      return qx.Class.implementsInterface(targetClass, qx.ui.core.ISingleSelection);\n    },\n\n\n    /**\n     * Internal helper for selecting an item in the target. The item to select\n     * is defined by a given model item.\n     *\n     * @param item {qx.core.Object} A model element.\n     */\n    __selectItem: function(item) {\n      var selectable = this.__getSelectableForModel(item);\n      // if no selectable could be found, just return\n      if (selectable == null) {\n        return;\n      }\n      // if the target is multi selection able\n      if (this.__targetSupportsMultiSelection()) {\n        // select the item in the target\n        this.getTarget().addToSelection(selectable);\n      // if the target is single selection able\n      } else if (this.__targetSupportsSingleSelection()) {\n        this.getTarget().setSelection([selectable]);\n      }\n    },\n\n\n    /**\n     * Returns the list item storing the given model in its model property.\n     *\n     * @param model {var} The representing model of a selectable.\n     * @return {Object|null} List item or <code>null</code> if none was found\n     */\n    __getSelectableForModel : function(model)\n    {\n      // get all list items\n      var children = this.getTarget().getSelectables(true);\n\n      // go through all children and search for the child to select\n      for (var i = 0; i < children.length; i++) {\n        if (children[i].getModel() == model) {\n          return children[i];\n        }\n      }\n      // if no selectable was found\n      return null;\n    },\n\n\n    /**\n     * Helper-Method signaling that currently the selection of the target is\n     * in change. That will block the change of the internal selection.\n     * {@link #_endSelectionModification}\n     */\n    _startSelectionModification: function() {\n      this._modifingSelection++;\n    },\n\n\n    /**\n     * Helper-Method signaling that the internal changing of the targets\n     * selection is over.\n     * {@link #_startSelectionModification}\n     */\n    _endSelectionModification: function() {\n      this._modifingSelection > 0 ? this._modifingSelection-- : null;\n    },\n\n\n    /**\n     * Helper-Method for checking the state of the selection modification.\n     * {@link #_startSelectionModification}\n     * {@link #_endSelectionModification}\n     * @return {Boolean} <code>true</code> if selection modification is active\n     */\n    _inSelectionModification: function() {\n      return this._modifingSelection > 0;\n    }\n\n  },\n\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n\n  destruct : function()\n  {\n    if (this.__ownSelection) {\n      this.__ownSelection.dispose();\n    }\n  }\n});\n"
  ]
}