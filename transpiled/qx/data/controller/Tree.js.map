{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/data/controller/Tree.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "include",
    "data",
    "controller",
    "MSelection",
    "implement",
    "ISelection",
    "construct",
    "model",
    "target",
    "childPath",
    "labelPath",
    "__bindings",
    "__boundProperties",
    "__childrenRef",
    "a",
    "setChildPath",
    "setLabelPath",
    "setModel",
    "setTarget",
    "properties",
    "check",
    "apply",
    "event",
    "nullable",
    "dereference",
    "init",
    "iconPath",
    "labelOptions",
    "iconOptions",
    "delegate",
    "members",
    "__oldChildrenPath",
    "_applyDelegate",
    "value",
    "old",
    "_setConfigureItem",
    "_setCreateItem",
    "_setBindItem",
    "_applyIconOptions",
    "__renewBindings",
    "_applyLabelOptions",
    "_applyTarget",
    "undefined",
    "__emptyTarget",
    "getModel",
    "__buildTree",
    "_addChangeTargetListener",
    "_applyModel",
    "_applyChildPath",
    "_applyIconPath",
    "_applyLabelPath",
    "__changeModelChildren",
    "ev",
    "children",
    "getTarget",
    "ObjectRegistry",
    "register",
    "treeNode",
    "toHashCode",
    "modelNode",
    "__updateTreeChildren",
    "_updateSelection",
    "__changeChildrenArray",
    "e",
    "getData",
    "oldChildren",
    "getOldData",
    "oldRef",
    "removeListenerById",
    "changeListenerId",
    "debug",
    "changeChildernListenerId",
    "property",
    "getPropertyDefinition",
    "constructor",
    "getChildPath",
    "eventName",
    "addListener",
    "_createItem",
    "getDelegate",
    "createItem",
    "item",
    "ui",
    "tree",
    "TreeFolder",
    "configureItem",
    "getLabelPath",
    "bindItem",
    "rootNode",
    "__addBinding",
    "setRoot",
    "lang",
    "String",
    "firstUp",
    "i",
    "length",
    "getChildren",
    "getItem",
    "j",
    "oldIndex",
    "currentNode",
    "isSelected",
    "wasSelected",
    "removeAt",
    "addAt",
    "addToSelection",
    "treeFolder",
    "__removeFolder",
    "root",
    "getRoot",
    "__removeAllFolders",
    "__removeBinding",
    "destroy",
    "b",
    "node",
    "childrenGetterName",
    "remove",
    "bindProperty",
    "sourcePath",
    "targetPath",
    "options",
    "targetWidget",
    "id",
    "bind",
    "storage",
    "Error",
    "reverseId",
    "includes",
    "push",
    "bindPropertyReverse",
    "sourceWidget",
    "bindDefaultProperties",
    "getLabelOptions",
    "getIconPath",
    "getIconOptions",
    "firstProp",
    "key",
    "hash",
    "fromHashCode",
    "bindingsMap",
    "removeBinding",
    "getItems",
    "_startSelectionModification",
    "_endSelectionModification",
    "destruct",
    "isDisposed",
    "Tree"
  ],
  "mappings": "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",
  "file": "Tree.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2009 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (martinwittemann)\n\n************************************************************************ */\n\n/**\n * <h2>Tree Controller</h2>\n *\n * *General idea*\n *\n * The tree controller is the controller made for the {@link qx.ui.tree.Tree}\n * widget in qooxdoo. Therefore, it is responsible for creating and adding the\n * tree folders to the tree given as target.\n *\n * *Features*\n *\n * * Synchronize the model and the target\n * * Label and icon are bindable\n * * Takes care of the selection\n * * Passes on the options used by {@link qx.data.SingleValueBinding#bind}\n *\n * *Usage*\n *\n * As model, you can use every qooxdoo widget structure having one property,\n * which is a data array holding the children of the current node. There can\n * be as many additional as you like.\n * You need to specify a model, a target, a child path and a label path to\n * make the controller work.\n *\n * *Cross reference*\n *\n * * If you want to bind single values, use {@link qx.data.controller.Object}\n * * If you want to bind a list like widget, use {@link qx.data.controller.List}\n * * If you want to bin a form widget, use {@link qx.data.controller.Form}\n */\nqx.Class.define(\"qx.data.controller.Tree\",\n{\n  extend : qx.core.Object,\n  include: qx.data.controller.MSelection,\n  implement : [ qx.data.controller.ISelection ],\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * @param model {qx.core.Object?null} The root element of the model, which holds\n   *   the data.\n   *\n   * @param target {qx.ui.tree.Tree?null} The target widgets which should be a tree.\n   *\n   * @param childPath {String?null} The name of the property in the model, which\n   *   holds the data array containing the children.\n   *\n   * @param labelPath {String?null} The name of the property in the model,\n   *   which holds the value to be displayed as the label of the tree items.\n   */\n  construct : function(model, target, childPath, labelPath)  {\n    this.base(arguments);\n\n    // internal bindings reference\n    this.__bindings = {};\n    this.__boundProperties = [];\n\n    // reference to the child\n    this.__childrenRef = { a:1 };\n\n    if (childPath != null) {\n      this.setChildPath(childPath);\n    }\n    if (labelPath != null) {\n      this.setLabelPath(labelPath);\n    }\n    if (model != null) {\n      this.setModel(model);\n    }\n    if (target != null) {\n      this.setTarget(target);\n    }\n  },\n\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n    /** The root element of the data. */\n    model :\n    {\n      check: \"qx.core.Object\",\n      apply: \"_applyModel\",\n      event: \"changeModel\",\n      nullable: true,\n      dereference: true\n    },\n\n\n    /** The tree to bind the data to. */\n    target :\n    {\n      apply: \"_applyTarget\",\n      event: \"changeTarget\",\n      init: null,\n      nullable: true,\n      dereference: true\n    },\n\n\n    /** The name of the property, where the children are stored in the model. */\n    childPath :\n    {\n      check: \"String\",\n      apply: \"_applyChildPath\",\n      nullable: true\n    },\n\n\n    /**\n     * The name of the property, where the value for the tree folders label\n     * is stored in the model classes.\n     */\n    labelPath :\n    {\n      check: \"String\",\n      apply: \"_applyLabelPath\",\n      nullable: true\n    },\n\n\n    /**\n     * The name of the property, where the source for the tree folders icon\n     * is stored in the model classes.\n     */\n    iconPath :\n    {\n      check: \"String\",\n      apply: \"_applyIconPath\",\n      nullable: true\n    },\n\n\n    /**\n     * A map containing the options for the label binding. The possible keys\n     * can be found in the {@link qx.data.SingleValueBinding} documentation.\n     */\n    labelOptions :\n    {\n      apply: \"_applyLabelOptions\",\n      nullable: true\n    },\n\n\n    /**\n     * A map containing the options for the icon binding. The possible keys\n     * can be found in the {@link qx.data.SingleValueBinding} documentation.\n     */\n    iconOptions :\n    {\n      apply: \"_applyIconOptions\",\n      nullable: true\n    },\n\n\n    /**\n     * Delegation object, which can have one ore more function defined by the\n     * {@link IControllerDelegate} interface.\n     */\n    delegate :\n    {\n      apply: \"_applyDelegate\",\n      init: null,\n      nullable: true\n    }\n  },\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    // private members\n    __childrenRef : null,\n    __bindings : null,\n    __boundProperties : null,\n    __oldChildrenPath : null,\n\n\n    /*\n    ---------------------------------------------------------------------------\n       APPLY METHODS\n    ---------------------------------------------------------------------------\n    */\n    /**\n     * If a new delegate is set, it applies the stored configuration for the\n     * tree folder to the already created folders once.\n     *\n     * @param value {qx.core.Object|null} The new delegate.\n     * @param old {qx.core.Object|null} The old delegate.\n     */\n    _applyDelegate: function(value, old) {\n      this._setConfigureItem(value, old);\n      this._setCreateItem(value, old);\n      this._setBindItem(value, old);\n    },\n\n\n    /**\n     * Apply-method which will be called after the icon options had been\n     * changed. This method will invoke a renewing of all bindings.\n     *\n     * @param value {Map|null} The new options map.\n     * @param old {Map|null} The old options map.\n     */\n    _applyIconOptions: function(value, old) {\n      this.__renewBindings();\n    },\n\n\n    /**\n     * Apply-method which will be called after the label options had been\n     * changed. This method will invoke a renewing of all bindings.\n     *\n     * @param value {Map|null} The new options map.\n     * @param old {Map|null} The old options map.\n     */\n    _applyLabelOptions: function(value, old) {\n      this.__renewBindings();\n    },\n\n\n    /**\n     * Apply-method which will be called after the target had been\n     * changed. This method will clean up the old tree and will initially\n     * build up the new tree containing the data from the model.\n     *\n     * @param value {qx.ui.tree.Tree|null} The new tree.\n     * @param old {qx.ui.tree.Tree|null} The old tree.\n     */\n    _applyTarget: function(value, old) {\n      // if there was an old target\n      if (old != undefined) {\n        this.__emptyTarget(old);\n      }\n\n      // if a model is set\n      if (this.getModel() != null) {\n        // build up the tree\n        this.__buildTree();\n      }\n\n      // add a listener for the target change\n      this._addChangeTargetListener(value, old);\n    },\n\n\n    /**\n     * Apply-method which will be called after the model had been\n     * changed. This method invoke a new building of the tree.\n     *\n     * @param value {qx.core.Object|null} The new tree.\n     * @param old {qx.core.Object|null} The old tree.\n     */\n    _applyModel: function(value, old) {\n      this.__buildTree();\n    },\n\n\n    /**\n     * Apply-method which will be called after the child path had been\n     * changed. This method invoke a new building of the tree.\n     *\n     * @param value {String|null} The new path to the children property.\n     * @param old {String|null} The old path to the children property.\n     */\n    _applyChildPath: function(value, old) {\n      // save the old name because it is needed to remove the old bindings\n      this.__oldChildrenPath = old;\n      this.__buildTree();\n      // reset the old name\n      this.__oldChildrenPath = null;\n    },\n\n\n    /**\n     * Apply-method which will be called after the icon path had been\n     * changed. This method invoke a new building of the tree.\n     *\n     * @param value {String|null} The new path to the icon property.\n     * @param old {String|null} The old path or the icon property.\n     */\n    _applyIconPath: function(value, old) {\n      this.__renewBindings();\n    },\n\n\n    /**\n     * Apply-method which will be called after the label path had been\n     * changed. This method invoke a new building of the tree.\n     *\n     * @param value {String|null} The new path to the label property.\n     * @param old {String|null} The old path of the label property.\n     */\n    _applyLabelPath: function(value, old) {\n      this.__buildTree();\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n       EVENT HANDLER\n    ---------------------------------------------------------------------------\n    */\n    /**\n     * Handler function handling the change of a length of a children array.\n     * This method invokes a rebuild of the corresponding subtree.\n     *\n     * @param ev {qx.event.type.Event} The changeLength event of a data array.\n     */\n    __changeModelChildren: function(ev) {\n      // get the stored data\n      var children =  ev.getTarget();\n      qx.core.ObjectRegistry.register(children);\n      var treeNode = this.__childrenRef[children.toHashCode()].treeNode;\n      var modelNode = this.__childrenRef[children.toHashCode()].modelNode;\n      // update the subtree\n      this.__updateTreeChildren(treeNode, modelNode);\n\n      // update the selection in case a selected element has been removed\n      this._updateSelection();\n    },\n\n\n    /**\n     * Handler function taking care of the changes of the children array itself.\n     *\n     * @param e {qx.event.type.Data} Change event for the children property.\n     */\n    __changeChildrenArray: function(e) {\n      var children = e.getData();\n      var oldChildren = e.getOldData();\n\n      // get the old ref and delete it\n      var oldRef = this.__childrenRef[oldChildren.toHashCode()];\n      oldChildren.removeListenerById(oldRef.changeListenerId);\n      this.debug(\"1: removing children=\"+ oldChildren.toHashCode() + \" from this=\" + this.toHashCode());\n      delete this.__childrenRef[oldChildren.toHashCode()];\n      // remove the old change listener for the children\n      oldRef.modelNode.removeListenerById(oldRef.changeChildernListenerId);\n\n      // add a new change listener\n      var modelNode = oldRef.modelNode;\n      var property = qx.Class.getPropertyDefinition(\n        oldRef.modelNode.constructor, this.getChildPath()\n      );\n      var eventName = property.event;\n      var changeChildernListenerId = modelNode.addListener(\n        eventName, this.__changeChildrenArray, this\n      );\n\n      // add the new ref\n      var treeNode = oldRef.treeNode;\n      this.debug(\"1: adding children=\"+ children.toHashCode() + \" to this=\" + this.toHashCode());\n      this.__childrenRef[children.toHashCode()] =\n      {\n        modelNode: modelNode,\n        treeNode: treeNode,\n        changeListenerId: oldRef.changeListenerId,\n        changeChildernListenerId : changeChildernListenerId\n      };\n\n      // update the subtree\n      this.__updateTreeChildren(treeNode, modelNode);\n\n      // update the selection in case a selected element has been removed\n      this._updateSelection();\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n       ITEM HANDLING\n    ---------------------------------------------------------------------------\n    */\n    /**\n     * Creates a TreeFolder and delegates the configure method if a delegate is\n     * set and the needed function (configureItem) is available.\n     *\n     * @return {qx.ui.tree.core.AbstractTreeItem} The created and configured TreeFolder.\n     */\n    _createItem: function() {\n      var delegate = this.getDelegate();\n      // check if a delegate and a create method is set\n      if (delegate != null && delegate.createItem != null) {\n        var item = delegate.createItem();\n      } else {\n        var item = new qx.ui.tree.TreeFolder();\n      }\n\n      // check if a delegate is set and if the configure function is available\n      if (delegate != null && delegate.configureItem != null) {\n        delegate.configureItem(item);\n      }\n      return item;\n    },\n\n\n    /**\n     * Internal helper function to build up the tree corresponding to the data\n     * stored in the model. This function creates the root node and hands the\n     * recursive creation of all subtrees to the {#__updateTreeChildren}\n     * function.\n     */\n    __buildTree: function() {\n      // only fill the target if there is a target, its known how to\n      // access the children and what needs to be displayed as label\n      if (this.getTarget() == null || this.getChildPath() == null) {\n        return;\n      }\n\n      // check for the binding knowledge\n      if (\n        (this.getLabelPath() == null && this.getDelegate() == null)\n        || (this.getLabelPath() == null && this.getDelegate() != null && this.getDelegate().bindItem == null)\n      ) {\n        return;\n      }\n\n      // Clean the target completely\n      this.__emptyTarget();\n\n      // only build up a new tree if a model is given\n      if (this.getModel() != null) {\n        // create a new root node\n        var rootNode = this._createItem();\n        rootNode.setModel(this.getModel());\n        // bind the root node\n        this.__addBinding(this.getModel(), rootNode);\n        this.__updateTreeChildren(rootNode, this.getModel());\n        // assign the new root once the tree has been built\n        this.getTarget().setRoot(rootNode);\n      }\n    },\n\n\n    /**\n     * Main method building up the tree folders corresponding to the given\n     * model node. The new created subtree will be added to the given tree node.\n     *\n     * @param rootNode {qx.ui.tree.TreeFolder} The tree folder to add the new\n     *   created subtree.\n     *\n     * @param modelNode {qx.core.Object} The model nodes which represent the\n     *   data in the current subtree.\n     */\n    __updateTreeChildren: function(rootNode, modelNode) {\n      // ignore items which don't have children\n      if (modelNode[\"get\" + qx.lang.String.firstUp(this.getChildPath())] == undefined) {\n        return;\n      }\n      // get all children of the current model node\n      var children =\n        modelNode[\"get\" + qx.lang.String.firstUp(this.getChildPath())]();\n\n      // store the children reference\n      if (this.__childrenRef[children.toHashCode()] == undefined) {\n        // add the listener for the change\n        var changeListenerId = children.addListener(\n          \"change\", this.__changeModelChildren, this\n        );\n        // add a listener for the change of the children array itself\n        var property = qx.Class.getPropertyDefinition(\n          modelNode.constructor, this.getChildPath()\n        );\n        var eventName = property.event;\n        var changeChildernListenerId = modelNode.addListener(\n          eventName, this.__changeChildrenArray, this\n        );\n        this.debug(\"2: adding children=\"+ children.toHashCode() + \" to this=\" + this.toHashCode());\n        this.__childrenRef[children.toHashCode()] =\n        {\n          modelNode: modelNode,\n          treeNode: rootNode,\n          changeListenerId: changeListenerId,\n          changeChildernListenerId : changeChildernListenerId\n        };\n      }\n\n      // go threw all children in the model\n      for (var i = 0; i < children.length; i++) {\n        // if there is no node in the tree or the current node does not fit\n        if (rootNode.getChildren()[i] == null || children.getItem(i) != rootNode.getChildren()[i].getModel())\n        {\n          //check if the node was just moved\n          for (var j = i; j < rootNode.getChildren().length; j++) {\n            if (rootNode.getChildren()[j].getModel() === children.getItem(i)) {\n              var oldIndex = j;\n              break;\n            }\n          }\n          // if it is in the tree\n          if (oldIndex != undefined) {\n            // get the corresponding node\n            var currentNode = rootNode.getChildren()[oldIndex];\n            // check if it is selected\n            if (this.getTarget().isSelected(currentNode)) {\n              var wasSelected = true;\n            }\n            // remove the item at its old place (will remove the selection)\n            rootNode.removeAt(oldIndex);\n            // add the node at the current position\n            rootNode.addAt(currentNode, i);\n            // select it again if it was selected\n            if (wasSelected) {\n              this.getTarget().addToSelection(currentNode);\n            }\n\n          // if the node is new\n          } else {\n            // add the child node\n            var treeNode = this._createItem();\n            treeNode.setModel(children.getItem(i));\n            rootNode.addAt(treeNode, i);\n            this.__addBinding(children.getItem(i), treeNode);\n\n            // add all children recursive\n            this.__updateTreeChildren(treeNode, children.getItem(i));\n          }\n        }\n      }\n      // remove the rest of the tree items if they exist\n      for (var i = rootNode.getChildren().length -1; i >= children.length; i--) {\n        var treeFolder = rootNode.getChildren()[i];\n        this.__removeFolder(treeFolder, rootNode);\n      }\n    },\n\n\n    /**\n     * Removes all folders and bindings for the current set target.\n     * @param tree {qx.ui.tree.Tree} The tree to empty.\n     */\n    __emptyTarget: function(tree) {\n      if (tree == null) {\n        tree = this.getTarget();\n      }\n      // only do something if a tree is set\n      if (tree == null) {\n        return;\n      }\n      // remove the root node\n      var root = tree.getRoot();\n      if (root != null) {\n        tree.setRoot(null);\n        this.__removeAllFolders(root);\n        var model = root.getModel();\n        if (model) {\n          this.__removeBinding(model);\n        }\n        root.destroy();\n        this.debug(\"erasing all children from this=\" + this.toHashCode());\n        this.__childrenRef = { b: 2};\n      }\n    },\n\n\n    /**\n     * Removes all child folders of the given tree node. Also removes all\n     * bindings for the removed folders.\n     *\n     * @param node {qx.ui.tree.core.AbstractTreeItem} The used tree folder.\n     */\n    __removeAllFolders: function(node) {\n      var children = node.getChildren() || [];\n      // remove all subchildren\n      for (var i = children.length - 1; i >= 0; i--) {\n        if (children[i].getChildren().length > 0) {\n          this.__removeAllFolders(children[i]);\n        }\n        this.__removeFolder(children[i], node);\n      }\n    },\n\n\n    /**\n     * Internal helper method removing the given folder form the given root\n     * node. All set bindings will be removed and the old tree folder will be\n     * destroyed.\n     *\n     * @param treeFolder {qx.ui.tree.core.AbstractTreeItem} The folder to remove.\n     * @param rootNode {qx.ui.tree.core.AbstractTreeItem} The folder holding the\n     *   treeFolder.\n     */\n    __removeFolder: function(treeFolder, rootNode) {\n      // get the model\n      var model = treeFolder.getModel();\n      var childPath = this.__oldChildrenPath || this.getChildPath();\n      var childrenGetterName = \"get\" + qx.lang.String.firstUp(childPath);\n\n      // if the model does have a child path\n      if (model[childrenGetterName] != undefined)\n      {\n        // remove the old children listener\n        var children = model[childrenGetterName]();\n      \tthis.debug(\"2: removing children=\"+ children.toHashCode() + \" from this=\" + this.toHashCode());\n        var oldRef = this.__childrenRef[children.toHashCode()];\n        children.removeListenerById(oldRef.changeListenerId);\n        model.removeListenerById(oldRef.changeChildernListenerId);\n        // also remove all its children [BUG #4296]\n        this.__removeAllFolders(treeFolder);\n\n        // delete the model reference\n        delete this.__childrenRef[children.toHashCode()];\n      }\n      // get the binding and remove it\n      this.__removeBinding(model);\n      // remove the folder from the tree\n      rootNode.remove(treeFolder);\n      // get rid of the old tree folder\n      treeFolder.destroy();\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n       BINDING STUFF\n    ---------------------------------------------------------------------------\n    */\n    /**\n     * Helper method for binding a given property from the model to the target\n     * widget.\n     * This method should only be called in the\n     * {@link qx.data.controller.IControllerDelegate#bindItem} function\n     * implemented by the {@link #delegate} property.\n     *\n     * @param sourcePath {String | null} The path to the property in the model.\n     *   If you use an empty string, the whole model item will be bound.\n     * @param targetPath {String} The name of the property in the target\n     *   widget.\n     * @param options {Map | null} The options to use by\n     *  {@link qx.data.SingleValueBinding#bind} for the binding.\n     * @param targetWidget {qx.ui.tree.core.AbstractTreeItem} The target widget.\n     * @param modelNode {var} The model node which should be bound to the target.\n     */\n    bindProperty: function(sourcePath, targetPath, options, targetWidget, modelNode) {\n      // set up the binding\n      var id = modelNode.bind(sourcePath, targetWidget, targetPath, options);\n      // check for the storage for the references\n      if (this.__bindings[targetPath] == null) {\n        this.__bindings[targetPath] = {};\n      }\n      // store the binding reference\n      var storage = this.__bindings[targetPath];\n      qx.core.ObjectRegistry.register(modelNode);\n      if (storage[modelNode.toHashCode()]) {\n        if (storage[modelNode.toHashCode()].id) {\n          throw new Error(\n            \"Can not bind the same target property '\" + targetPath + \"' twice.\"\n          );\n        }\n        storage[modelNode.toHashCode()].id = id;\n      } else {\n        storage[modelNode.toHashCode()] = {\n          id: id,\n          reverseId: null,\n          treeNode: targetWidget\n        };\n      }\n\n      // save the bound property\n      if (!this.__boundProperties.includes(targetPath)) {\n        this.__boundProperties.push(targetPath);\n      }\n    },\n\n\n    /**\n     * Helper method for binding a given property from the target widget to\n     * the model.\n     * This method should only be called in the\n     * {@link qx.data.controller.IControllerDelegate#bindItem} function\n     * implemented by the {@link #delegate} property.\n     *\n     * @param targetPath {String | null} The path to the property in the model.\n     * @param sourcePath {String} The name of the property in the target\n     *   widget.\n     * @param options {Map | null} The options to use by\n     *   {@link qx.data.SingleValueBinding#bind} for the binding.\n     * @param sourceWidget {qx.ui.tree.core.AbstractTreeItem} The source widget.\n     * @param modelNode {var} The model node which should be bound to the target.\n     */\n    bindPropertyReverse : function(\n      targetPath, sourcePath, options, sourceWidget, modelNode\n    )\n    {\n      // set up the binding\n      var id = sourceWidget.bind(sourcePath, modelNode, targetPath, options);\n\n      // check for the storage for the references\n      if (this.__bindings[sourcePath] == null) {\n        this.__bindings[sourcePath] = {};\n      }\n      // check if there is already a stored item\n      var storage = this.__bindings[sourcePath];\n      qx.core.ObjectRegistry.register(modelNode);\n      if (storage[modelNode.toHashCode()]) {\n        if (storage[modelNode.toHashCode()].reverseId) {\n          throw new Error(\n            \"Can not reverse bind the same target property '\" + targetPath + \"' twice.\"\n          );\n        }\n        storage[modelNode.toHashCode()].reverseId = id;\n      } else {\n        storage[modelNode.toHashCode()] = {\n          id: null,\n          reverseId: id,\n          treeNode: sourceWidget\n        };\n      }\n\n      // save the bound property\n      if (!this.__boundProperties.includes(sourcePath)) {\n        this.__boundProperties.push(sourcePath);\n      }\n    },\n\n\n    /**\n     * Helper method for binding the default properties (label and icon) from\n     * the model to the target widget.\n     *\n     * This method should only be called in the\n     * {@link qx.data.controller.IControllerDelegate#bindItem} function\n     * implemented by the {@link #delegate} property.\n     *\n     * @param treeNode {qx.ui.tree.core.AbstractTreeItem} The tree node\n     *   corresponding to the model node.\n     * @param modelNode {qx.core.Object} The model node holding the data.\n     */\n    bindDefaultProperties : function(treeNode, modelNode)\n    {\n      // label binding\n      this.bindProperty(this.getLabelPath(), \"label\", this.getLabelOptions(), treeNode, modelNode);\n\n      // icon binding\n      if (this.getIconPath() != null) {\n        this.bindProperty(this.getIconPath(), \"icon\", this.getIconOptions(), treeNode, modelNode);\n      }\n    },\n\n\n    /**\n     * Helper method renewing all bindings with the currently saved options and\n     * paths.\n     */\n    __renewBindings: function() {\n      // get the first bound property\n      var firstProp;\n      for (var key in this.__bindings) {\n        firstProp = key;\n        break;\n      }\n      // go through all stored bindings for that property\n      // (should have all the same amount of entries and tree nodes)\n      for (var hash in this.__bindings[firstProp]) {\n        // get the data\n        var treeNode = this.__bindings[firstProp][hash].treeNode;\n        var modelNode = qx.core.ObjectRegistry.fromHashCode(hash);\n        // remove the old bindings\n        this.__removeBinding(modelNode);\n        // add the new bindings\n        this.__addBinding(modelNode, treeNode);\n      }\n    },\n\n\n    /**\n     * Internal helper method adding the right bindings from the given\n     * modelNode to the given treeNode.\n     *\n     * @param modelNode {qx.core.Object} The model node holding the data.\n     * @param treeNode {qx.ui.tree.TreeFolder} The corresponding tree folder\n     *   to the model node.\n     */\n    __addBinding: function(modelNode, treeNode) {\n      var delegate = this.getDelegate();\n      // if a delegate for creating the binding is given, use it\n      if (delegate != null && delegate.bindItem != null) {\n        delegate.bindItem(this, treeNode, modelNode);\n\n      // otherwise, try to bind the listItem by default\n      } else {\n        this.bindDefaultProperties(treeNode, modelNode);\n      }\n    },\n\n\n    /**\n     * Internal helper method for removing bindings for a given model node.\n     *\n     * @param modelNode {qx.core.Object} the model node for which the bindings\n     *   should be removed.\n     */\n    __removeBinding: function(modelNode) {\n      for (var i = 0; i < this.__boundProperties.length; i++) {\n        var property = this.__boundProperties[i];\n        var bindingsMap = this.__bindings[property][modelNode.toHashCode()];\n        if (bindingsMap != null) {\n          if (bindingsMap.id) {\n            modelNode.removeBinding(bindingsMap.id);\n            bindingsMap.id = null;\n          }\n          if (bindingsMap.reverseId) {\n            bindingsMap.treeNode.removeBinding(bindingsMap.reverseId);\n            bindingsMap.reverseId = null;\n          }\n          delete this.__bindings[property][modelNode.toHashCode()];\n        }\n      }\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n       DELEGATE HELPER\n    ---------------------------------------------------------------------------\n    */\n    /**\n     * Helper method for applying the delegate It checks if a configureItem\n     * is set end invokes the initial process to apply the given function.\n     *\n     * @param value {Object} The new delegate.\n     * @param old {Object} The old delegate.\n     */\n    _setConfigureItem: function(value, old) {\n      if (\n        value != null && value.configureItem != null &&\n        this.getTarget() != null && this.getModel() != null\n      ) {\n        var children = this.getTarget().getRoot().getItems(true, true, false);\n        for (var i = 0; i < children.length; i++) {\n          value.configureItem(children[i]);\n        }\n      }\n    },\n\n\n    /**\n     * Helper method for applying the delegate. It checks if a createItem\n     * is set and invokes the initial process to apply the given function.\n     *\n     * @param value {Object} The new delegate.\n     * @param old {Object} The old delegate.\n     */\n    _setCreateItem: function(value, old) {\n      // do nothing if no tree can be build\n      if (this.getTarget() == null || this.getModel() == null) {\n        return;\n      }\n      // do nothing if no delegate function is set\n      if (value == null || value.createItem == null) {\n        return;\n      }\n      // do nothing it the delegate function has not changed\n      if (old && old.createItem && value && value.createItem && old.createItem == value.createItem) {\n        return;\n      }\n      this._startSelectionModification();\n\n      this.__emptyTarget();\n      this.__buildTree();\n\n      this._endSelectionModification();\n      this._updateSelection();\n    },\n\n\n    /**\n     * Helper method for applying the delegate It checks if a bindItem\n     * is set end invokes the initial process to apply the given function.\n     *\n     * @param value {Object} The new delegate.\n     * @param old {Object} The old delegate.\n     */\n    _setBindItem: function(value, old) {\n      // if a new bindItem function is set\n      if (value != null && value.bindItem != null) {\n        // do nothing if the bindItem function did not change\n        if (old != null && old.bindItem != null && value.bindItem == old.bindItem) {\n          return;\n        }\n        this.__buildTree();\n      }\n    }\n  },\n\n\n\n  /*\n   *****************************************************************************\n      DESTRUCTOR\n   *****************************************************************************\n   */\n\n   destruct : function() {\n  \t if (this.getTarget() && !this.getTarget().isDisposed()) {\n  \t\t this.setTarget(null);\n  \t }\n     if (this.getModel() != null && !this.getModel().isDisposed()) {\n    \t this.setModel(null);\n     }\n     this.__bindings = this.__childrenRef = this.__boundProperties = null;\n   }\n});\n"
  ]
}