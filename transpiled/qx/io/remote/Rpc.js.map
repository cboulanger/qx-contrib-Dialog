{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/io/remote/Rpc.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "url",
    "serviceName",
    "undefined",
    "setUrl",
    "setServiceName",
    "ServerSettings",
    "__currentServerSuffix",
    "serverPathSuffix",
    "events",
    "statics",
    "origin",
    "server",
    "application",
    "transport",
    "local",
    "localError",
    "timeout",
    "abort",
    "nodata",
    "CONVERT_DATES",
    "RESPONSE_JSON",
    "makeServerURL",
    "instanceId",
    "retVal",
    "serverPathPrefix",
    "properties",
    "check",
    "nullable",
    "crossDomain",
    "init",
    "serverData",
    "username",
    "password",
    "useBasicHttpAuth",
    "protocol",
    "val",
    "members",
    "__previousServerSuffix",
    "createRequest",
    "io",
    "remote",
    "Request",
    "getUrl",
    "createRpcData",
    "id",
    "method",
    "parameters",
    "requestObject",
    "service",
    "getProtocol",
    "getServiceName",
    "server_data",
    "_callInternal",
    "args",
    "callType",
    "refreshSession",
    "self",
    "offset",
    "whichMethod",
    "handler",
    "argsArray",
    "eventTarget",
    "i",
    "length",
    "push",
    "req",
    "getServerData",
    "rpcData",
    "getSequenceNumber",
    "setCrossDomain",
    "getCrossDomain",
    "getUsername",
    "setUseBasicHttpAuth",
    "getUseBasicHttpAuth",
    "setUsername",
    "setPassword",
    "getPassword",
    "setTimeout",
    "getTimeout",
    "ex",
    "result",
    "response",
    "handleRequestFinished",
    "eventType",
    "e",
    "error",
    "lang",
    "Json",
    "stringify",
    "fireDataEvent",
    "addToStringToObject",
    "obj",
    "toString",
    "Rpc",
    "code",
    "message",
    "ret",
    "data",
    "makeException",
    "addListener",
    "evt",
    "getStatusCode",
    "Exchange",
    "statusCodeToString",
    "debug",
    "getContent",
    "Type",
    "isObject",
    "_isConvertDates",
    "_isResponseJson",
    "parse",
    "key",
    "value",
    "indexOf",
    "m",
    "match",
    "Date",
    "UTC",
    "eval",
    "warn",
    "exTest",
    "newSuffix",
    "fixUrl",
    "replacer",
    "isDate",
    "dateParams",
    "getUTCFullYear",
    "getUTCMonth",
    "getUTCDate",
    "getUTCHours",
    "getUTCMinutes",
    "getUTCSeconds",
    "getUTCMilliseconds",
    "setData",
    "setAsynchronous",
    "setRequestHeader",
    "setParseJson",
    "send",
    "Error",
    "rpcdetails",
    "index",
    "substring",
    "callSync",
    "methodName",
    "arguments",
    "callAsync",
    "callAsyncListeners",
    "coalesce",
    "timeDiff",
    "getTime",
    "lastSessionRefresh",
    "sessionTimeoutInSeconds",
    "opaqueCallRef"
  ],
  "mappings": "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",
  "file": "Rpc.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006 STZ-IDA, Germany, http://www.stz-ida.de\n     2006 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Andreas Junghans (lucidcake)\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Provides a Remote Procedure Call (RPC) implementation.\n *\n * Each instance of this class represents a \"Service\". These services can\n * correspond to various concepts on the server side (depending on the\n * programming language/environment being used), but usually, a service means\n * a class on the server.\n *\n * In case multiple instances of the same service are needed, they can be\n * distinguished by ids. If such an id is specified, the server routes all\n * calls to a service that have the same id to the same server-side instance.\n *\n * When calling a server-side method, the parameters and return values are\n * converted automatically. Supported types are int (and Integer), double\n * (and Double), String, Date, Map, and JavaBeans. Beans must have a default\n * constructor on the server side and are represented by simple JavaScript\n * objects on the client side (used as associative arrays with keys matching\n * the server-side properties). Beans can also be nested, but be careful not to\n * create circular references! There are no checks to detect these (which would\n * be expensive), so you as the user are responsible for avoiding them.\n *\n * A simple example:\n * <pre class='javascript'>\n *   function callRpcServer ()\n *   {\n *     var rpc = new qx.io.remote.Rpc();\n *     rpc.setTimeout(10000);\n *     rpc.setUrl(\"http://127.0.0.1:8007\");\n *     rpc.setServiceName(\"qooxdoo.admin\");\n *\n *     // call a remote procedure -- takes no arguments, returns a string\n *     var that = this;\n *     this.RpcRunning = rpc.callAsync(\n *       function(result, ex, id)\n *       {\n *         that.RpcRunning = null;\n *         if (ex == null) {\n *             alert(result);\n *         } else {\n *             alert(\"Async(\" + id + \") exception: \" + ex);\n *         }\n *       },\n *       \"fss.getBaseDir\");\n *   }\n * </pre>\n * __fss.getBaseDir__ is the remote procedure in this case, potential arguments\n * would be listed after the procedure name.\n * <p>\n * Passing data from the client (qooxdoo) side is demonstrated in the\n * qooxdoo-contrib project RpcExample. There are three ways to issue a remote\n * procedure call: synchronously (qx.io.remote.Rpc.callSync -- dangerous\n * because it blocks the whole browser, not just your application, so is\n * highly discouraged); async with results via a callback function\n * (qx.io.remote.Rpc.callAsync) and async with results via an event listener\n * (qx.io.remote.Rpc.callAsyncListeners).\n * <p>\n * You may also find the server writer's guide helpful:\n *   http://manual.qooxdoo.org/${qxversion}/pages/communication/rpc_server_writer_guide.html\n *\n * @ignore(qx.core.ServerSettings.*)\n*/\n\nqx.Class.define(\"qx.io.remote.Rpc\",\n{\n  extend : qx.core.Object,\n\n\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * @param url {String}            identifies the url where the service\n   *                                is found.  Note that if the url is to\n   *                                a domain (server) other than where the\n   *                                qooxdoo script came from, i.e. it is\n   *                                cross-domain, then you must also call\n   *                                the setCrossDomain(true) method to\n   *                                enable the ScriptTransport instead of\n   *                                the XmlHttpTransport, since the latter\n   *                                can not handle cross-domain requests.\n   *\n   * @param serviceName {String}    identifies the service. For the Java\n   *                                implementation, this is the fully\n   *                                qualified name of the class that offers\n   *                                the service methods\n   *                                (e.g. \"my.pkg.MyService\").\n   */\n  construct : function(url, serviceName)\n  {\n    this.base(arguments);\n\n    if (url !== undefined)\n    {\n      this.setUrl(url);\n    }\n\n    if (serviceName != null)\n    {\n      this.setServiceName(serviceName);\n    }\n\n    if (qx.core.ServerSettings)\n    {\n      this.__currentServerSuffix = qx.core.ServerSettings.serverPathSuffix;\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     EVENTS\n  *****************************************************************************\n  */\n\n  events :\n  {\n    /**\n     * Fired when call is completed.\n     */\n    \"completed\" : \"qx.event.type.Event\",\n\n    /**\n     * Fired when call aborted.\n     */\n    \"aborted\" : \"qx.event.type.Event\",\n\n    /**\n     * Fired when call failed.\n     */\n    \"failed\" : \"qx.event.type.Event\",\n\n    /**\n     * Fired when call timed out.\n     */\n    \"timeout\" : \"qx.event.type.Event\"\n  },\n\n\n\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics :\n  {\n    /**\n     * Origins of errors\n     */\n    origin :\n    {\n      server      : 1,\n      application : 2,\n      transport   : 3,\n      local       : 4\n    },\n\n\n    /**\n     *  Locally-detected errors\n     */\n    localError :\n    {\n      timeout : 1,\n      abort   : 2,\n      nodata  : 3\n    },\n\n\n    /**\n     * Boolean flag which controls the stringification of date objects.\n     * <code>null</code> for the default behavior, acts like false\n     * <code>true</code> for stringifying dates the old, qooxdoo specific way\n     * <code>false</code> using the native toJSON of date objects.\n     *\n     * When enabled, dates are converted to and parsed from\n     * a literal that complies to the format\n     *\n     * <code>new Date(Date.UTC(year,month,day,hour,min,sec,ms))</code>\n     *\n     * The server can fairly easily parse this in its JSON\n     * implementation by stripping off \"new Date(Date.UTC(\"\n     * from the beginning of the string, and \"))\" from the\n     * end of the string. What remains is the set of\n     * comma-separated date components, which are also very\n     * easy to parse.\n     *\n     * The work-around compensates for the fact that while the\n     * Date object is a primitive type in Javascript, the\n     * specification neglects to provide a literal form for it.\n     */\n    CONVERT_DATES : null,\n\n\n    /**\n     * Boolean flag which controls whether to expect and verify a JSON\n     * response.\n     *\n     * Should be <code>true</code> when backend returns valid JSON.\n     *\n     * Date literals are parsed when CONVERT_DATES is <code>true</code>\n     * and comply to the format\n     *\n     * <code>\"new Date(Date.UTC(year,month,day,hour,min,sec,ms))\"</code>\n     *\n     * Note the surrounding quotes that encode the literal as string.\n     *\n     * Using valid JSON is recommended, because it allows to use\n     * {@link qx.lang.Json#parse} for parsing. {@link qx.lang.Json#parse}\n     * is preferred over the potentially insecure <code>eval</code>.\n     */\n    RESPONSE_JSON : null,\n\n\n    /**\n     * Creates an URL for talking to a local service. A local service is one that\n     * lives in the same application as the page calling the service. For backends\n     * that don't support this auto-generation, this method returns null.\n     *\n     * @param instanceId {String ? null} an optional identifier for the\n     *                                   server side instance that should be\n     *                                   used. All calls to the same service\n     *                                   with the same instance id are\n     *                                   routed to the same object instance\n     *                                   on the server. The instance id can\n     *                                   also be used to provide additional\n     *                                   data for the service instantiation\n     *                                   on the server.\n     * @return {String} the url.\n     */\n    makeServerURL : function(instanceId)\n    {\n      var retVal = null;\n\n      if (qx.core.ServerSettings)\n      {\n        retVal =\n          qx.core.ServerSettings.serverPathPrefix +\n          \"/.qxrpc\" +\n          qx.core.ServerSettings.serverPathSuffix;\n\n        if (instanceId != null)\n        {\n          retVal += \"?instanceId=\" + instanceId;\n        }\n      }\n\n      return retVal;\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n    /*\n    ---------------------------------------------------------------------------\n      PROPERTIES\n    ---------------------------------------------------------------------------\n    */\n\n    /** The timeout for asynchronous calls in milliseconds. */\n    timeout :\n    {\n      check : \"Integer\",\n      nullable : true\n    },\n\n\n    /**\n     * Indicate that the request is cross domain.\n     *\n     * A request is cross domain if the request's URL points to a host other\n     * than the local host. This switches the concrete implementation that is\n     * used for sending the request from qx.io.remote.transport.XmlHttp to\n     * qx.io.remote.transport.Script because only the latter can handle cross\n     * domain requests.\n     */\n    crossDomain :\n    {\n      check : \"Boolean\",\n      init : false\n    },\n\n\n    /** The URL at which the service is located. */\n    url :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n\n    /** The service name.  */\n    serviceName :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n\n    /**\n     * Data sent as \"out of band\" data in the request to the server.  The\n     * format of the data is opaque to RPC and may be recognized only by\n     * particular servers It is up to the server to decide what to do with\n     * it: whether to ignore it, handle it locally before calling the\n     * specified method, or pass it on to the method.  This server data is\n     * not sent to the server if it has been set to 'null'.\n     */\n    serverData :\n    {\n      check : \"Object\",\n      nullable : true\n    },\n\n\n    /**\n     * Username to use for HTTP authentication. Null if HTTP authentication\n     * is not used.\n     */\n    username :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n\n    /**\n     * Password to use for HTTP authentication. Null if HTTP authentication\n     * is not used.\n     */\n    password :\n    {\n      check : \"String\",\n      nullable : true\n    },\n\n\n    /**\n      Use Basic HTTP Authentication\n    */\n    useBasicHttpAuth :\n    {\n      check : \"Boolean\",\n      nullable : true\n    },\n\n    /**\n     * EXPERIMENTAL\n     *\n     * Whether to use the original qooxdoo RPC protocol or the\n     * now-standardized Version 2 protocol.  Defaults to the original qooxdoo\n     * protocol for backward compatibility.\n     *\n     * Valid values are \"qx1\" and \"2.0\".\n     */\n    protocol :\n    {\n      init : \"qx1\",\n      check : function(val) { return val == \"qx1\" || val == \"2.0\"; }\n    }\n  },\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n\n    __previousServerSuffix : null,\n    __currentServerSuffix : null,\n\n    /**\n     * Factory method to create a request object. By default, a POST request\n     * will be made, and the expected response type will be\n     * \"application/json\". Classes extending this one may override this method\n     * to obtain a Request object with different parameters.\n     *\n     * @return {qx.io.remote.Request}\n     */\n    createRequest: function()\n    {\n      return new qx.io.remote.Request(this.getUrl(),\n                                \"POST\",\n                                \"application/json\");\n    },\n\n    /**\n     * Factory method to create the object containing the remote procedure\n     * call data. By default, a qooxdoo-style RPC request is built, which\n     * contains the following members: \"service\", \"method\", \"id\", and\n     * \"params\". If a different style of RPC request is desired, a class\n     * extending this one may override this method.\n     *\n     * @param id {Integer}\n     *   The unique sequence number of this request.\n     *\n     * @param method {String}\n     *   The name of the method to be called\n     *\n     * @param parameters {Array}\n     *   An array containing the arguments to the called method.\n     *\n     * @param serverData {var}\n     *   \"Out-of-band\" data to be provided to the server.\n     *\n     * @return {Object}\n     *   The object to be converted to JSON and passed to the JSON-RPC\n     *   server.\n     */\n    createRpcData: function(id, method, parameters, serverData)\n    {\n      var             requestObject;\n      var             service;\n\n      // Create a protocol-dependent request object\n      if (this.getProtocol() == \"qx1\")\n      {\n        // Create a qooxdoo-modified version 1.0 rpc data object\n        requestObject =\n          {\n            \"service\" :\n              method == \"refreshSession\" ? null : this.getServiceName(),\n            \"method\"  : method,\n            \"id\"      : id,\n            \"params\"  : parameters\n          };\n\n        // Only add the server_data member if there is actually server data\n        if (serverData)\n        {\n          requestObject.server_data = serverData;\n        }\n      }\n      else\n      {\n        // If there's a service name, we'll prepend it to the method name\n        service = this.getServiceName();\n        if (service && service != \"\")\n        {\n          service += \".\";\n        }\n        else\n        {\n          service = \"\";\n        }\n\n        // Create a standard version 2.0 rpc data object\n        requestObject =\n          {\n            \"jsonrpc\" : \"2.0\",\n            \"method\"  : service + method,\n            \"id\"      : id,\n            \"params\" : parameters\n          };\n      }\n\n      return requestObject;\n    },\n\n\n    /**\n     * Internal RPC call method\n     *\n     * @lint ignoreDeprecated(eval)\n     *\n     * @param args {Array}\n     *   array of arguments\n     *\n     * @param callType {Integer}\n     *   0 = sync,\n     *   1 = async with handler,\n     *   2 = async event listeners\n     *\n     * @param refreshSession {Boolean}\n     *   whether a new session should be requested\n     *\n     * @return {var} the method call reference.\n     * @throws {Error} An error.\n     */\n    _callInternal : function(args, callType, refreshSession)\n    {\n      var self = this;\n      var offset = (callType == 0 ? 0 : 1);\n      var whichMethod = (refreshSession ? \"refreshSession\" : args[offset]);\n      var handler = args[0];\n      var argsArray = [];\n      var eventTarget = this;\n      var protocol = this.getProtocol();\n\n      for (var i=offset+1; i<args.length; ++i)\n      {\n        argsArray.push(args[i]);\n      }\n\n      var req = this.createRequest();\n\n      // Get any additional out-of-band data to be sent to the server\n      var serverData = this.getServerData();\n\n      // Create the request object\n      var rpcData = this.createRpcData(req.getSequenceNumber(),\n                                       whichMethod,\n                                       argsArray,\n                                       serverData);\n\n      req.setCrossDomain(this.getCrossDomain());\n\n      if (this.getUsername())\n      {\n        req.setUseBasicHttpAuth(this.getUseBasicHttpAuth());\n        req.setUsername(this.getUsername());\n        req.setPassword(this.getPassword());\n      }\n\n      req.setTimeout(this.getTimeout());\n      var ex = null;\n      var id = null;\n      var result = null;\n      var response = null;\n\n      var handleRequestFinished = function(eventType, eventTarget)\n      {\n        switch(callType)\n        {\n          case 0: // sync\n            break;\n\n          case 1: // async with handler function\n            try\n            {\n              handler(result, ex, id);\n            }\n            catch(e)\n            {\n              eventTarget.error(\n                \"rpc handler threw an error:\" +\n                  \" id=\" + id +\n                  \" result=\" + qx.lang.Json.stringify(result) +\n                  \" ex=\" + qx.lang.Json.stringify(ex),\n                e);\n            }\n            break;\n\n          case 2: // async with event listeners\n            // Dispatch the event to our listeners.\n            if (!ex)\n            {\n              eventTarget.fireDataEvent(eventType, response);\n            }\n            else\n            {\n              // Add the id to the exception\n              ex.id = id;\n\n              if (args[0])      // coalesce\n              {\n                // They requested that we coalesce all failure types to\n                // \"failed\"\n                eventTarget.fireDataEvent(\"failed\", ex);\n              }\n              else\n              {\n                // No coalese so use original event type\n                eventTarget.fireDataEvent(eventType, ex);\n              }\n            }\n        }\n      };\n\n      var addToStringToObject = function(obj)\n      {\n        if (protocol == \"qx1\")\n        {\n          obj.toString = function()\n          {\n            switch(obj.origin)\n            {\n              case qx.io.remote.Rpc.origin.server:\n                return \"Server error \" + obj.code + \": \" + obj.message;\n\n              case qx.io.remote.Rpc.origin.application:\n                return \"Application error \" + obj.code + \": \" + obj.message;\n\n              case qx.io.remote.Rpc.origin.transport:\n                return \"Transport error \" + obj.code + \": \" + obj.message;\n\n              case qx.io.remote.Rpc.origin.local:\n                return \"Local error \" + obj.code + \": \" + obj.message;\n\n              default:\n                return (\"UNEXPECTED origin \" + obj.origin +\n                        \" error \" + obj.code + \": \" + obj.message);\n            }\n          };\n        }\n        else // protocol == \"2.0\"\n        {\n          obj.toString = function()\n          {\n            var             ret;\n\n            ret =  \"Error \" + obj.code + \": \" + obj.message;\n            if (obj.data)\n            {\n              ret += \" (\" + obj.data + \")\";\n            }\n\n            return ret;\n          };\n        }\n      };\n\n      var makeException = function(origin, code, message)\n      {\n        var ex = new Object();\n\n        if (protocol == \"qx1\")\n        {\n          ex.origin = origin;\n        }\n        ex.code = code;\n        ex.message = message;\n        addToStringToObject(ex);\n\n        return ex;\n      };\n\n      req.addListener(\"failed\", function(evt)\n      {\n        var code = evt.getStatusCode();\n        ex = makeException(qx.io.remote.Rpc.origin.transport,\n                           code,\n                           qx.io.remote.Exchange.statusCodeToString(code));\n        id = this.getSequenceNumber();\n        handleRequestFinished(\"failed\", eventTarget);\n      });\n\n      req.addListener(\"timeout\", function(evt)\n      {\n        this.debug(\"TIMEOUT OCCURRED\");\n        ex = makeException(qx.io.remote.Rpc.origin.local,\n                           qx.io.remote.Rpc.localError.timeout,\n                           \"Local time-out expired for \"+ whichMethod);\n        id = this.getSequenceNumber();\n        handleRequestFinished(\"timeout\", eventTarget);\n      });\n\n      req.addListener(\"aborted\", function(evt)\n      {\n        ex = makeException(qx.io.remote.Rpc.origin.local,\n                           qx.io.remote.Rpc.localError.abort,\n                           \"Aborted \" + whichMethod);\n        id = this.getSequenceNumber();\n        handleRequestFinished(\"aborted\", eventTarget);\n      });\n\n      req.addListener(\"completed\", function(evt)\n      {\n        response = evt.getContent();\n\n        // server may have reset, giving us no data on our requests\n        if (response === null)\n        {\n          ex = makeException(qx.io.remote.Rpc.origin.local,\n                             qx.io.remote.Rpc.localError.nodata,\n                             \"No data in response to \" + whichMethod);\n          id = this.getSequenceNumber();\n          handleRequestFinished(\"failed\", eventTarget);\n          return;\n        }\n\n        // Parse. Skip when response is already an object\n        // because the script transport was used.\n        if (!qx.lang.Type.isObject(response)) {\n\n          // Handle converted dates\n          if (self._isConvertDates()) {\n\n            // Parse as JSON and revive date literals\n            if (self._isResponseJson()) {\n              response = qx.lang.Json.parse(response, function(key, value) {\n                if (value && typeof value === \"string\") {\n                  if (value.indexOf(\"new Date(Date.UTC(\") >= 0) {\n                    var m = value.match(/new Date\\(Date.UTC\\((\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)\\)\\)/);\n                    return new Date(Date.UTC(m[1],m[2],m[3],m[4],m[5],m[6],m[7]));\n                  }\n                }\n                return value;\n              });\n\n            // Eval\n            } else {\n              response = response && response.length > 0 ? eval('(' + response + ')') : null;\n            }\n\n          // No special date handling required, JSON assumed\n          } else {\n            response = qx.lang.Json.parse(response);\n          }\n        }\n\n        id = response[\"id\"];\n\n        if (id != this.getSequenceNumber())\n        {\n          this.warn(\"Received id (\" + id + \") does not match requested id \" +\n                    \"(\" + this.getSequenceNumber() + \")!\");\n        }\n\n        // Determine if an error was returned. Assume no error, initially.\n        var eventType = \"completed\";\n        var exTest = response[\"error\"];\n\n        if (exTest != null)\n        {\n          // There was an error\n          result = null;\n          addToStringToObject(exTest);\n          ex = exTest;\n\n          // Change the event type\n          eventType = \"failed\";\n        }\n        else\n        {\n          result = response[\"result\"];\n\n          if (refreshSession)\n          {\n            result = eval(\"(\" + result + \")\");\n            var newSuffix = qx.core.ServerSettings.serverPathSuffix;\n\n            if (self.__currentServerSuffix != newSuffix)\n            {\n              self.__previousServerSuffix = self.__currentServerSuffix;\n              self.__currentServerSuffix = newSuffix;\n            }\n\n            self.setUrl(self.fixUrl(self.getUrl()));\n          }\n        }\n\n        handleRequestFinished(eventType, eventTarget);\n      });\n\n      // Provide a replacer when convert dates is enabled\n      var replacer = null;\n      if (this._isConvertDates()) {\n        replacer = function(key, value) {\n          // The value passed in is of type string, because the Date's\n          // toJson gets applied before. Get value from containing object.\n          value = this[key];\n\n          if (qx.lang.Type.isDate(value)) {\n            var dateParams =\n              value.getUTCFullYear() + \",\" +\n              value.getUTCMonth() + \",\" +\n              value.getUTCDate() + \",\" +\n              value.getUTCHours() + \",\" +\n              value.getUTCMinutes() + \",\" +\n              value.getUTCSeconds() + \",\" +\n              value.getUTCMilliseconds();\n            return \"new Date(Date.UTC(\" + dateParams + \"))\";\n          }\n          return value;\n        };\n      }\n\n      req.setData(qx.lang.Json.stringify(rpcData, replacer));\n      req.setAsynchronous(callType > 0);\n\n      if (req.getCrossDomain())\n      {\n        // Our choice here has no effect anyway.  This is purely informational.\n        req.setRequestHeader(\"Content-Type\",\n                             \"application/x-www-form-urlencoded\");\n      }\n      else\n      {\n        // When not cross-domain, set type to text/json\n        req.setRequestHeader(\"Content-Type\", \"application/json\");\n      }\n\n      // Do not parse as JSON. Later done conditionally.\n      req.setParseJson(false);\n\n      req.send();\n\n      if (callType == 0)\n      {\n        if (ex != null)\n        {\n          var error = new Error(ex.toString());\n          error.rpcdetails = ex;\n          throw error;\n        }\n\n        return result;\n      }\n      else\n      {\n        return req;\n      }\n    },\n\n\n    /**\n     * Helper method to rewrite a URL with a stale session id (so that it includes\n     * the correct session id afterwards).\n     *\n     * @param url {String} the URL to examine.\n     * @return {String} the (possibly re-written) URL.\n     */\n    fixUrl : function(url)\n    {\n      if (this.__previousServerSuffix == null ||\n          this.__currentServerSuffix == null ||\n          this.__previousServerSuffix == \"\" ||\n          this.__previousServerSuffix == this.__currentServerSuffix)\n      {\n        return url;\n      }\n\n      var index = url.indexOf(this.__previousServerSuffix);\n\n      if (index == -1)\n      {\n        return url;\n      }\n\n      return (url.substring(0, index) +\n              this.__currentServerSuffix +\n              url.substring(index + this.__previousServerSuffix.length));\n    },\n\n\n    /**\n     * Makes a synchronous server call. The method arguments (if any) follow\n     * after the method name (as normal JavaScript arguments, separated by\n     * commas, not as an array).\n     *\n     * If a problem occurs when making the call, an exception is thrown.\n     *\n     *\n     * WARNING.  With some browsers, the synchronous interface\n     * causes the browser to hang while awaiting a response!  If the server\n     * decides to pause for a minute or two, your browser may do nothing\n     * (including refreshing following window changes) until the response is\n     * received.  Instead, use the asynchronous interface.\n     *\n     *\n     * YOU HAVE BEEN WARNED.\n     *\n     *\n     * @param methodName {String} the name of the method to call.\n     * @param args {Array} an array of values passed through to the backend.\n     * @return {var} the result returned by the server.\n     */\n    callSync : function(methodName,args)\n    {\n      return this._callInternal(arguments, 0);\n    },\n\n\n    /**\n     * Makes an asynchronous server call. The method arguments (if any) follow\n     * after the method name (as normal JavaScript arguments, separated by\n     * commas, not as an array).\n     *\n     * When an answer from the server arrives, the <code>handler</code>\n     * function is called with the result of the call as the first, an\n     * exception as the second parameter, and the id (aka sequence number) of\n     * the invoking request as the third parameter. If the call was\n     * successful, the second parameter is <code>null</code>. If there was a\n     * problem, the second parameter contains an exception, and the first one\n     * is <code>null</code>.\n     *\n     *\n     * The return value of this method is a call reference that you can store\n     * if you want to abort the request later on. This value should be treated\n     * as opaque and can change completely in the future! The only thing you\n     * can rely on is that the <code>abort</code> method will accept this\n     * reference and that you can retrieve the sequence number of the request\n     * by invoking the getSequenceNumber() method (see below).\n     *\n     *\n     * If a specific method is being called, asynchronously, a number of times\n     * in succession, the getSequenceNumber() method may be used to\n     * disambiguate which request a response corresponds to.  The sequence\n     * number value is a value which increments with each request.)\n     *\n     *\n     * @param handler {Function} the callback function.\n     * @param methodName {String} the name of the method to call.\n     * @param args {Array} an array of values passed through to the backend.\n     * @return {var} the method call reference.\n     */\n    callAsync : function(handler, methodName, args)\n    {\n      return this._callInternal(arguments, 1);\n    },\n\n\n    /**\n     * Makes an asynchronous server call and dispatches an event upon completion\n     * or failure. The method arguments (if any) follow after the method name\n     * (as normal JavaScript arguments, separated by commas, not as an array).\n     *\n     * When an answer from the server arrives (or fails to arrive on time), if\n     * an exception occurred, a \"failed\", \"timeout\" or \"aborted\" event, as\n     * appropriate, is dispatched to any waiting event listeners.  If no\n     * exception occurred, a \"completed\" event is dispatched.\n     *\n     *\n     * When a \"failed\", \"timeout\" or \"aborted\" event is dispatched, the event\n     * data contains an object with the properties 'origin', 'code', 'message'\n     * and 'id'.  The object has a toString() function which may be called to\n     * convert the exception to a string.\n     *\n     *\n     * When a \"completed\" event is dispatched, the event data contains a\n     * map with the JSON-RPC sequence number and result:\n     * <p>\n     * {\n     *   id: rpc_id,\n     *   result: json-rpc result\n     * }\n     *\n     *\n     * The return value of this method is a call reference that you can store\n     * if you want to abort the request later on. This value should be treated\n     * as opaque and can change completely in the future! The only thing you\n     * can rely on is that the <code>abort</code> method will accept this\n     * reference and that you can retrieve the sequence number of the request\n     * by invoking the getSequenceNumber() method (see below).\n     *\n     *\n     * If a specific method is being called, asynchronously, a number of times\n     * in succession, the getSequenceNumber() method may be used to\n     * disambiguate which request a response corresponds to.  The sequence\n     * number value is a value which increments with each request.)\n     *\n     *\n     * @param coalesce {Boolean} coalesce all failure types (\"failed\",\n     *                           \"timeout\", and \"aborted\") to \"failed\".\n     *                           This is reasonable in many cases, as\n     *                           the provided exception contains adequate\n     *                           disambiguating information.\n     * @param methodName {String} the name of the method to call.\n     * @param args {Array} an array of values passed through to the backend.\n     * @return {var} the method call reference.\n     */\n    callAsyncListeners : function(coalesce, methodName, args)\n    {\n      return this._callInternal(arguments, 2);\n    },\n\n\n    /**\n     * Refreshes a server session by retrieving the session id again from the\n     * server.\n     *\n     * The specified handler function is called when the refresh is\n     * complete. The first parameter can be <code>true</code> (indicating that\n     * a refresh either wasn't necessary at this time or it was successful) or\n     * <code>false</code> (indicating that a refresh would have been necessary\n     * but can't be performed because the server backend doesn't support\n     * it). If there is a non-null second parameter, it's an exception\n     * indicating that there was an error when refreshing the session.\n     *\n     *\n     * @param handler {Function} a callback function that is called when the\n     *                           refresh is complete (or failed).\n     */\n    refreshSession : function(handler)\n    {\n      if (qx.core.ServerSettings &&\n          qx.core.ServerSettings.serverPathSuffix)\n      {\n        var timeDiff =\n          (new Date()).getTime() - qx.core.ServerSettings.lastSessionRefresh;\n\n        if (timeDiff / 1000 >\n            (qx.core.ServerSettings.sessionTimeoutInSeconds - 30))\n        {\n          // this.info(\"refreshing session\");\n          this._callInternal([ handler ], 1, true);\n        }\n        else\n        {\n          handler(true); // session refresh was OK (in this case: not needed)\n        }\n      }\n      else\n      {\n        handler(false); // no refresh possible, but would be necessary\n      }\n    },\n\n\n    /**\n     * Whether to convert date objects to pseudo literals and\n     * parse with eval.\n     *\n     * Controlled by {@link #CONVERT_DATES}.\n     *\n     * @return {Boolean} Whether to convert.\n     */\n    _isConvertDates: function() {\n      return !!(qx.io.remote.Rpc.CONVERT_DATES);\n    },\n\n\n    /**\n     * Whether to expect and verify a JSON response.\n     *\n     * Controlled by {@link #RESPONSE_JSON}.\n     *\n     * @return {Boolean} Whether to expect JSON.\n     */\n    _isResponseJson: function() {\n      return !!(qx.io.remote.Rpc.RESPONSE_JSON);\n    },\n\n\n    /**\n     * Aborts an asynchronous server call. Consequently, the callback function\n     * provided to <code>callAsync</code> or <code>callAsyncListeners</code>\n     * will be called with an exception.\n     *\n     * @param opaqueCallRef {var} the call reference as returned by\n     *                            <code>callAsync</code> or\n     *                            <code>callAsyncListeners</code>\n     */\n    abort : function(opaqueCallRef)\n    {\n      opaqueCallRef.abort();\n    }\n  }\n});\n"
  ]
}