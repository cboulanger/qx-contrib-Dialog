{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/locale/Manager.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "type",
    "extend",
    "core",
    "Object",
    "construct",
    "__translations",
    "$$translations",
    "__locales",
    "$$locales",
    "initLocale",
    "__clientLocale",
    "getLocale",
    "statics",
    "tr",
    "messageId",
    "varargs",
    "args",
    "lang",
    "Array",
    "fromArguments",
    "arguments",
    "splice",
    "locale",
    "Manager",
    "getInstance",
    "translate",
    "trn",
    "singularMessageId",
    "pluralMessageId",
    "count",
    "trc",
    "hint",
    "trnc",
    "marktr",
    "properties",
    "check",
    "apply",
    "event",
    "init",
    "Environment",
    "get",
    "variant",
    "members",
    "__defaultLocale",
    "__locale",
    "__language",
    "getLanguage",
    "getTerritory",
    "split",
    "getAvailableLocales",
    "includeNonloaded",
    "locales",
    "push",
    "__extractLanguage",
    "language",
    "pos",
    "indexOf",
    "substring",
    "_applyLocale",
    "value",
    "old",
    "log",
    "Logger",
    "warn",
    "addTranslation",
    "languageCode",
    "translationMap",
    "catalog",
    "key",
    "addLocale",
    "localeCode",
    "localeMap",
    "__lookupAndExpand",
    "localize",
    "assertObject",
    "assertString",
    "assertArray",
    "txt",
    "length",
    "translatedArgs",
    "i",
    "arg",
    "String",
    "format",
    "LocalizedString"
  ],
  "mappings": "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",
  "file": "Manager.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Andreas Ecker (ecker)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\n/**\n * The qx.locale.Manager provides static translation methods (like tr()) and\n * general locale information.\n *\n * @require(qx.event.dispatch.Direct)\n * @require(qx.locale.LocalizedString)\n *\n * @cldr()\n */\n\nqx.Class.define(\"qx.locale.Manager\",\n{\n  type : \"singleton\",\n  extend : qx.core.Object,\n\n\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct : function()\n  {\n    this.base(arguments);\n\n    this.__translations = qx.$$translations || {};\n    this.__locales      = qx.$$locales || {};\n\n    this.initLocale();\n    this.__clientLocale = this.getLocale();\n  },\n\n\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics :\n  {\n    /**\n     * Translate a message\n     *\n     * @param messageId {String} message id (may contain format strings)\n     * @param varargs {Object} variable number of arguments applied to the format string\n     * @return {String | LocalizedString} The translated message or localized string\n     * @see qx.lang.String.format\n     */\n    tr : function(messageId, varargs)\n    {\n      var args = qx.lang.Array.fromArguments(arguments);\n      args.splice(0, 1);\n\n      return qx.locale.Manager.getInstance().translate(messageId, args);\n    },\n\n\n    /**\n     * Translate a plural message\n     *\n     * Depending on the third argument the plural or the singular form is chosen.\n     *\n     * @param singularMessageId {String} message id of the singular form (may contain format strings)\n     * @param pluralMessageId {String} message id of the plural form (may contain format strings)\n     * @param count {Integer} singular form if equals 1, otherwise plural\n     * @param varargs {Object} variable number of arguments applied to the format string\n     * @return {String | LocalizedString} The translated message or localized string\n     * @see qx.lang.String.format\n     */\n    trn : function(singularMessageId, pluralMessageId, count, varargs)\n    {\n      var args = qx.lang.Array.fromArguments(arguments);\n      args.splice(0, 3);\n\n      // assumes \"Two forms, singular used for one only\" (seems to be the most common form)\n      // (http://www.gnu.org/software/gettext/manual/html_node/gettext_150.html#Plural-forms)\n      // closely related with bug #745\n      if (count != 1) {\n        return qx.locale.Manager.getInstance().translate(pluralMessageId, args);\n      } else {\n        return qx.locale.Manager.getInstance().translate(singularMessageId, args);\n      }\n    },\n\n\n    /**\n     * Translate a message with translation hint (from developer addressed to translator).\n     *\n     * @param hint {String} hint for the translator of the message. Will be included in the .po file.\n     * @param messageId {String} message id (may contain format strings)\n     * @param varargs {Object} variable number of arguments applied to the format string\n     * @return {String | LocalizedString} The translated message or localized string\n     * @see qx.lang.String.format\n     */\n    trc : function(hint, messageId, varargs)\n    {\n      var args = qx.lang.Array.fromArguments(arguments);\n      args.splice(0, 2);\n\n      return qx.locale.Manager.getInstance().translate(messageId, args);\n    },\n\n    /**\n     * Translate a plural message with translation hint (from developer addressed to translator).\n     *\n     * Depending on the third argument the plural or the singular form is chosen.\n     *\n     * @param hint {String} hint for the translator of the message. Will be included in the .po file.\n     * @param singularMessageId {String} message id of the singular form (may contain format strings)\n     * @param pluralMessageId {String} message id of the plural form (may contain format strings)\n     * @param count {Integer} singular form if equals 1, otherwise plural\n     * @param varargs {Object} variable number of arguments applied to the format string\n     * @return {String | LocalizedString} The translated message or localized string\n     * @see qx.lang.String.format\n     */\n    trnc : function(hint, singularMessageId, pluralMessageId, count, varargs)\n    {\n      var args = qx.lang.Array.fromArguments(arguments);\n      args.splice(0, 4);\n\n      // see trn()\n      if (count != 1) {\n        return qx.locale.Manager.getInstance().translate(pluralMessageId, args);\n      } else {\n        return qx.locale.Manager.getInstance().translate(singularMessageId, args);\n      }\n    },\n\n    /**\n     * Mark the message for translation but return the original message.\n     *\n     * @param messageId {String} the message ID\n     * @return {String} messageId\n     */\n    marktr : function(messageId) {\n      return messageId;\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n    /** current locale. locale is an language code like de, de_AT, en, en_GB, fr, ... */\n    locale :\n    {\n      check : \"String\",\n      apply : \"_applyLocale\",\n      event : \"changeLocale\",\n      init : (function() { \n        var locale = qx.core.Environment.get(\"locale\");\n        if(!locale || locale === \"\") {\n          return qx.core.Environment.get(\"locale.default\");\n        }\n        var variant = qx.core.Environment.get(\"locale.variant\");\n        if (variant !== \"\") {\n          locale += \"_\" + variant;\n        }\n        return locale; })()\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n\n    __defaultLocale : qx.core.Environment.get(\"locale.default\"),\n    __locale : null,\n    __language : null,\n    __translations : null,\n    __locales : null,\n    __clientLocale : null,\n\n    /**\n     * Get the language code of the current locale\n     *\n     * This is the first part of a locale definition. The language for \"de_DE\" would be \"de\"\n     *\n     * @return {String} language code\n     */\n    getLanguage : function() {\n      return this.__language;\n    },\n\n\n    /**\n     * Get the territory code of the current locale\n     *\n     * This is the second part of a locale definition. The territory for \"de_DE\" would be \"DE\"\n     *\n     * @return {String} territory code\n     */\n    getTerritory : function() {\n      return this.getLocale().split(\"_\")[1] || \"\";\n    },\n\n\n    /**\n     * Return the available application locales\n     *\n     * This corresponds to the LOCALES setting in config.json. Without argument,\n     * it only returns the currently loaded locales, with an argument of true\n     * all locales that went into the build. This is particularly interesting if\n     * locales were generated as dedicated I18N parts, and have to be loaded\n     * explicitly before being available.\n     *\n     * @param includeNonloaded {Boolean?null} include locales not yet loaded\n     * @return {String[]} array of available locales\n     */\n    getAvailableLocales : function(includeNonloaded)\n    {\n      var locales = [];\n\n      for (var locale in this.__locales)\n      {\n        if (locale != this.__defaultLocale) {\n          if (this.__locales[locale] === null && !includeNonloaded) {\n            continue;  // skip not yet loaded locales\n          }\n          locales.push(locale);\n        }\n      }\n\n      return locales;\n    },\n\n\n    /**\n     * Extract the language part from a locale.\n     *\n     * @param locale {String} locale to be used\n     * @return {String} language\n     */\n    __extractLanguage : function(locale)\n    {\n      var language;\n      if (locale == null) {\n        return null;\n      }\n      var pos = locale.indexOf(\"_\");\n\n      if (pos == -1) {\n        language = locale;\n      } else {\n        language = locale.substring(0, pos);\n      }\n\n      return language;\n    },\n\n\n    // property apply\n    _applyLocale : function(value, old)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (!(value in this.__locales || value == this.__clientLocale)) {\n          qx.log.Logger.warn(\"Locale: \" + value+\" not available.\");\n        }\n      }\n\n      this.__locale = value;\n      this.__language = this.__extractLanguage(value);\n    },\n\n\n    /**\n     * Add a translation to the translation manager.\n     *\n     * If <code>languageCode</code> already exists, its map will be updated with\n     * <code>translationMap</code> (new keys will be added, existing keys will be\n     * overwritten).\n     *\n     * @param languageCode {String} language code of the translation like <i>de, de_AT, en, en_GB, fr, ...</i>\n     * @param translationMap {Map} mapping of message identifiers to message strings in the target\n     *                             language, e.g. <i>{\"greeting_short\" : \"Hello\"}</i>. Plural forms\n     *                             are separate keys.\n     */\n    addTranslation : function(languageCode, translationMap)\n    {\n      var catalog = this.__translations;\n      if (catalog[languageCode])\n      {\n        for (var key in translationMap) {\n          catalog[languageCode][key] = translationMap[key];\n        }\n      }\n      else\n      {\n        catalog[languageCode] = translationMap;\n      }\n    },\n\n\n    /**\n     * Add a localization to the localization manager.\n     *\n     * If <code>localeCode</code> already exists, its map will be updated with\n     * <code>localeMap</code> (new keys will be added, existing keys will be overwritten).\n     *\n     * @param localeCode {String} locale code of the translation like <i>de, de_AT, en, en_GB, fr, ...</i>\n     * @param localeMap {Map} mapping of locale keys to the target locale values, e.g.\n     *                        <i>{\"cldr_date_format_short\" : \"M/d/yy\"}</i>.\n     */\n    addLocale : function(localeCode, localeMap)\n    {\n      var catalog = this.__locales;\n      if (catalog[localeCode])\n      {\n        for (var key in localeMap) {\n          catalog[localeCode][key] = localeMap[key];\n        }\n      }\n      else\n      {\n        catalog[localeCode] = localeMap;\n      }\n    },\n\n\n    /**\n     * Translate a message using the current locale and apply format string to the arguments.\n     *\n     * Implements the lookup chain locale (e.g. en_US) -> language (e.g. en) ->\n     * default locale (e.g. C). Localizes the arguments if possible and splices\n     * them into the message. If qx.dynlocale is on, returns a {@link\n     * LocalizedString}.\n     *\n     * @param messageId {String} message id (may contain format strings)\n     * @param args {Object[]} array of objects, which are inserted into the format string\n     * @param locale {String ? #locale} locale to be used; if not given, defaults to the value of {@link #locale}\n     * @return {String | LocalizedString} translated message or localized string\n     */\n    translate : function(messageId, args, locale)\n    {\n      var catalog = this.__translations;\n      return this.__lookupAndExpand(catalog, messageId, args, locale);\n    },\n\n    /**\n     * Provide localization (CLDR) data.\n     *\n     * Implements the lookup chain locale (e.g. en_US) -> language (e.g. en) ->\n     * default locale (e.g. C). Localizes the arguments if possible and splices\n     * them into the message. If qx.dynlocale is on, returns a {@link\n     * LocalizedString}.\n     *\n     * @param messageId {String} message id (may contain format strings)\n     * @param args {Object[]} array of objects, which are inserted into the format string\n     * @param locale {String ? #locale} locale to be used; if not given, defaults to the value of {@link #locale}\n     * @return {String | LocalizedString} translated message or localized string\n     */\n    localize : function(messageId, args, locale)\n    {\n      var catalog = this.__locales;\n      return this.__lookupAndExpand(catalog, messageId, args, locale);\n    },\n\n\n    /**\n     * Look up an I18N key in a catalog and expand format strings.\n     *\n     * Implements the lookup chain locale (e.g. en_US) -> language (e.g. en) ->\n     * default locale (e.g. C). Localizes the arguments if possible and splices\n     * them into the message. If qx.dynlocale is on, returns a {@link\n     * LocalizedString}.\n     *\n     * @param catalog {Map} map of I18N keys and their values\n     * @param messageId {String} message id (may contain format strings)\n     * @param args {Object[]} array of objects, which are inserted into the format string\n     * @param locale {String ? #locale} locale to be used; if not given, defaults to the value of {@link #locale}\n     * @return {String | LocalizedString} translated message or localized string\n     */\n    __lookupAndExpand : function(catalog, messageId, args, locale)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        this.assertObject(catalog);\n        this.assertString(messageId);\n        this.assertArray(args);\n      }\n      var txt;\n\n      if (!catalog) {\n        return messageId;\n      }\n\n      if (locale) {\n        var language = this.__extractLanguage(locale);\n      }\n      else\n      {\n        locale = this.__locale;\n        language = this.__language;\n      }\n\n      // e.g. DE_at\n      if (!txt && catalog[locale]) {\n        txt = catalog[locale][messageId];\n      }\n\n      // e.g. DE\n      if (!txt && catalog[language]) {\n        txt = catalog[language][messageId];\n      }\n\n      // C\n      if (!txt && catalog[this.__defaultLocale]) {\n        txt = catalog[this.__defaultLocale][messageId];\n      }\n\n      if (!txt) {\n        txt = messageId;\n      }\n\n      if (args.length > 0)\n      {\n        var translatedArgs = [];\n        for ( var i = 0; i < args.length; i++)\n        {\n          var arg = args[i];\n          if (arg && arg.translate) {\n            translatedArgs[i] = arg.translate();\n          } else {\n            translatedArgs[i] = arg;\n          }\n        }\n        txt = qx.lang.String.format(txt, translatedArgs);\n      }\n\n      if (qx.core.Environment.get(\"qx.dynlocale\")) {\n        txt = new qx.locale.LocalizedString(txt, messageId, args, catalog === this.__locales);\n      }\n\n      return txt;\n    }\n  }\n});\n"
  ]
}