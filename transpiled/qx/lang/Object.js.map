{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/lang/Object.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "empty",
    "map",
    "core",
    "Assert",
    "assertMap",
    "key",
    "hasOwnProperty",
    "isEmpty",
    "getLength",
    "objectGetLength",
    "getValues",
    "Object",
    "values",
    "mergeWith",
    "objectMergeWith",
    "clone",
    "source",
    "deep",
    "lang",
    "Type",
    "isObject",
    "isArray",
    "i",
    "length",
    "equals",
    "object1",
    "object2",
    "__equals",
    "aStack",
    "bStack",
    "className",
    "prototype",
    "toString",
    "call",
    "String",
    "global",
    "multiline",
    "ignoreCase",
    "aCtor",
    "constructor",
    "bCtor",
    "isFunction",
    "push",
    "size",
    "result",
    "pop",
    "invert",
    "getKeyFromValue",
    "value",
    "contains",
    "fromArray",
    "array",
    "assertArray",
    "obj",
    "l",
    "Error"
  ],
  "mappings": "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",
  "file": "Object.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Andreas Ecker (ecker)\n\n   ======================================================================\n\n   This class contains code based on the following work:\n\n   * Underscore.js\n     http://underscorejs.org\n\n     Copyright:\n       2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\n     License:\n       MIT: http://www.opensource.org/licenses/mit-license.php\n\n************************************************************************ */\n\n/**\n * Helper functions to handle Object as a Hash map.\n *\n * @require(qx.lang.normalize.Object)\n * @ignore(qx.core.Assert)\n */\nqx.Bootstrap.define(\"qx.lang.Object\",\n{\n  statics :\n  {\n    /**\n     * Clears the map from all values\n     *\n     * @param map {Object} the map to clear\n     */\n    empty : function(map)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert && qx.core.Assert.assertMap(map, \"Invalid argument 'map'\");\n      }\n\n      for (var key in map)\n      {\n        if (map.hasOwnProperty(key)) {\n          delete map[key];\n        }\n      }\n    },\n\n\n    /**\n     * Check if the hash has any keys\n     *\n     * @signature function(map)\n     * @param map {Object} the map to check\n     * @return {Boolean} whether the map has any keys\n     * @lint ignoreUnused(key)\n     */\n    isEmpty : function(map)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert && qx.core.Assert.assertMap(map, \"Invalid argument 'map'\");\n      }\n\n      for (var key in map) {\n        return false;\n      }\n\n      return true;\n    },\n\n\n    /**\n     * Get the number of objects in the map\n     *\n     * @signature function(map)\n     * @param map {Object} the map\n     * @return {Integer} number of objects in the map\n     */\n    getLength : qx.Bootstrap.objectGetLength,\n\n\n    /**\n     * Get the values of a map as array\n     *\n     * @deprecated {6.0} Please use Object instance values method instead\n     *\n     * @param map {Object} the map\n     * @return {Array} array of the values of the map\n     */\n    getValues : function(map)\n    {\n      return Object.values(map); \n    },\n\n\n    /**\n     * Inserts all keys of the source object into the\n     * target objects. Attention: The target map gets modified.\n     *\n     * @signature function(target, source, overwrite)\n     * @param target {Object} target object\n     * @param source {Object} object to be merged\n     * @param overwrite {Boolean ? true} If enabled existing keys will be overwritten\n     * @return {Object} Target with merged values from the source object\n     */\n    mergeWith : qx.Bootstrap.objectMergeWith,\n\n\n    /**\n     * Return a copy of an Object\n     *\n     * @param source {Object} Object to copy\n     * @param deep {Boolean} If the clone should be a deep clone.\n     * @return {Object} A copy of the object\n     */\n    clone : function(source, deep)\n    {\n      if (qx.lang.Type.isObject(source)) {\n        var clone = {};\n        for (var key in source) {\n          if (deep) {\n            clone[key] = qx.lang.Object.clone(source[key], deep);\n          } else {\n            clone[key] = source[key];\n          }\n        }\n        return clone;\n\n      } else if (qx.lang.Type.isArray(source)) {\n        var clone = [];\n        for (var i=0; i < source.length; i++) {\n          if (deep) {\n            clone[i] = qx.lang.Object.clone(source[i], deep);\n          } else {\n            clone[i] = source[i];\n          }\n        };\n        return clone;\n\n      }\n      return source;\n    },\n\n\n  /**\n   * Perform a deep comparison to check if two objects are equal\n   *\n   * @param object1 {Object} the object that is compared to\n   * @param object2 {Object} the object that is compared with\n   * @return {Boolean} The result of the comparison\n   */\n    equals : function(object1, object2){\n      return qx.lang.Object.__equals(object1, object2, [], []);\n    },\n\n    /**\n    * Internal recursive comparison function for equals\n    *\n    * @param object1 {Object} the object that is compared to\n    * @param object2 {Object} the object that is compared with\n    * @param aStack {Object} Stack of object1 sub-objects to be traversed\n    * @param bStack {Object} Stack of object2 sub-objects to be traversed\n    * @return {Boolean} The result of the comparison\n    *\n    */\n    __equals : function(object1, object2, aStack, bStack){\n      // Identical objects are equal. `0 === -0`, but they aren't identical.\n      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n      if (object1 === object2){\n        return object1 !== 0 || 1 / object1 == 1 / object2;\n      }\n      // A strict comparison is necessary because `null == undefined`.\n      if (object1 == null || object2 == null){\n        return object1 === object2;\n      }\n      // Compare `[[Class]]` names.\n      var className = Object.prototype.toString.call(object1);\n      if (className != Object.prototype.toString.call(object2)){ return false; }\n      switch (className) {\n        // Strings, numbers, dates, and booleans are compared by value.\n        case '[object String]':\n          // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n          // equivalent to `new String(\"5\")`.\n          return object1 == String(object2);\n        case '[object Number]':\n          // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n          // other numeric values.\n          return object1 != +object1 ? object2 != +object2 : (object1 == 0 ? 1 / object1 == 1 / object2 : object1 == +object2);\n        case '[object Date]':\n        case '[object Boolean]':\n          // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n          // millisecond representations. Note that invalid dates with millisecond representations\n          // of `NaN` are not equivalent.\n          return +object1 == +object2;\n          // RegExps are compared by their source patterns and flags.\n        case '[object RegExp]':\n          return object1.source == object2.source &&\n            object1.global == object2.global &&\n            object1.multiline == object2.multiline &&\n            object1.ignoreCase == object2.ignoreCase;\n      }\n      if (typeof object1 != 'object' || typeof object2 != 'object'){ return false; }\n      // Assume equality for cyclic structures. The algorithm for detecting cyclic\n      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n      var length = aStack.length;\n      while (length--) {\n        // Linear search. Performance is inversely proportional to the number of\n        // unique nested structures.\n        if (aStack[length] == object1){ return bStack[length] == object2; }\n      }\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = object1.constructor,\n        bCtor = object2.constructor;\n      if (aCtor !== bCtor && !(qx.Bootstrap.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n        qx.Bootstrap.isFunction(bCtor) && (bCtor instanceof bCtor)) && ('constructor' in object1 && 'constructor' in object2)) {\n        return false;\n      }\n      // Add the first object to the stack of traversed objects.\n      aStack.push(object1);\n      bStack.push(object2);\n      var size = 0,\n        result = true;\n      // Recursively compare objects and arrays.\n      if (className == '[object Array]') {\n        // Compare array lengths to determine if a deep comparison is necessary.\n        size = object1.length;\n        result = size == object2.length;\n        if (result) {\n          // Deep compare the contents, ignoring non-numeric properties.\n          while (size--) {\n            if (!(result = qx.lang.Object.__equals(object1[size], object2[size], aStack, bStack))){ break; }\n          }\n        }\n      } else {\n        // Deep compare objects.\n        for (var key in object1) {\n          if (Object.prototype.hasOwnProperty.call(object1, key)) {\n            // Count the expected number of properties.\n            size++;\n            // Deep compare each member.\n            if (!(result = Object.prototype.hasOwnProperty.call(object2, key) && qx.lang.Object.__equals(object1[key], object2[key], aStack, bStack))){ break; }\n          }\n        }\n        // Ensure that both objects contain the same number of properties.\n        if (result) {\n          for (key in object2) {\n            if (Object.prototype.hasOwnProperty.call(object2, key) && !(size--)){ break; }\n          }\n          result = !size;\n        }\n      }\n      // Remove the first object from the stack of traversed objects.\n      aStack.pop();\n      bStack.pop();\n\n      return result;\n    },\n\n\n    /**\n     * Inverts a map by exchanging the keys with the values.\n     *\n     * If the map has the same values for different keys, information will get lost.\n     * The values will be converted to strings using the toString methods.\n     *\n     * @param map {Object} Map to invert\n     * @return {Object} inverted Map\n     */\n    invert : function(map)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert && qx.core.Assert.assertMap(map, \"Invalid argument 'map'\");\n      }\n\n      var result = {};\n\n      for (var key in map) {\n        result[map[key].toString()] = key;\n      }\n\n      return result;\n    },\n\n\n    /**\n     * Get the key of the given value from a map.\n     * If the map has more than one key matching the value, the first match is returned.\n     * If the map does not contain the value, <code>null</code> is returned.\n     *\n     * @param map {Object} Map to search for the key\n     * @param value {var} Value to look for\n     * @return {String|null} Name of the key (null if not found).\n     */\n    getKeyFromValue: function(map, value)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert && qx.core.Assert.assertMap(map, \"Invalid argument 'map'\");\n      }\n\n      for (var key in map)\n      {\n        if (map.hasOwnProperty(key) && map[key] === value) {\n          return key;\n        }\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Whether the map contains the given value.\n     *\n     * @param map {Object} Map to search for the value\n     * @param value {var} Value to look for\n     * @return {Boolean} Whether the value was found in the map.\n     */\n    contains : function(map, value)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert && qx.core.Assert.assertMap(map, \"Invalid argument 'map'\");\n      }\n\n      return this.getKeyFromValue(map, value) !== null;\n    },\n\n\n    /**\n    * Convert an array into a map.\n    *\n    * All elements of the array become keys of the returned map by\n    * calling <code>toString</code> on the array elements. The values of the\n    * map are set to <code>true</code>\n    *\n    * @param array {Array} array to convert\n    * @return {Map} the array converted to a map.\n    */\n    fromArray: function(array)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        qx.core.Assert && qx.core.Assert.assertArray(array, \"Invalid argument 'array'\");\n      }\n\n      var obj = {};\n\n      for (var i=0, l=array.length; i<l; i++)\n      {\n        if (qx.core.Environment.get(\"qx.debug\"))\n        {\n          switch(typeof array[i])\n          {\n            case \"object\":\n            case \"function\":\n            case \"undefined\":\n              throw new Error(\"Could not convert complex objects like \" + array[i] + \" at array index \"+ i +\" to map syntax\");\n          }\n        }\n\n        obj[array[i].toString()] = true;\n      }\n\n      return obj;\n    }\n  }\n});\n"
  ]
}