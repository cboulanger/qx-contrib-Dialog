{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/event/handler/GestureCore.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "extend",
    "Object",
    "implement",
    "core",
    "IDisposable",
    "statics",
    "TYPES",
    "GESTURE_EVENTS",
    "TAP_MAX_DISTANCE",
    "DOUBLETAP_MAX_DISTANCE",
    "SWIPE_DIRECTION",
    "x",
    "y",
    "LONGTAP_TIME",
    "DOUBLETAP_TIME",
    "ROLL_FACTOR",
    "TOUCHPAD_ROLL_FACTOR",
    "TOUCHPAD_WHEEL_EVENTS_THRESHOLD",
    "TOUCHPAD_WHEEL_EVENTS_PERIOD",
    "TOUCHPAD_WHEEL_EVENTS_TIMEOUT",
    "construct",
    "target",
    "emitter",
    "__defaultTarget",
    "__emitter",
    "__gesture",
    "__lastTap",
    "__stopMomentum",
    "__momentum",
    "__rollEvents",
    "_initObserver",
    "members",
    "__eventName",
    "__primaryTarget",
    "__isMultiPointerGesture",
    "__initialAngle",
    "__rollImpulseId",
    "__initialDistance",
    "__rollEventsCountStart",
    "__rollEventsCount",
    "__touchPadDetectionPerformed",
    "__lastRollEventTime",
    "event",
    "handler",
    "GestureCore",
    "forEach",
    "gestureType",
    "qxWeb",
    "on",
    "checkAndFireGesture",
    "bind",
    "Environment",
    "get",
    "_onDblClick",
    "data",
    "type",
    "_fireRoll",
    "_stopObserver",
    "pointerType",
    "off",
    "domEvent",
    "bom",
    "Event",
    "getTarget",
    "gestureBegin",
    "gestureMove",
    "gestureFinish",
    "gestureCancel",
    "pointerId",
    "__stopLongTapTimer",
    "_hasIntermediaryHandler",
    "Date",
    "getTime",
    "clientX",
    "clientY",
    "isPrimary",
    "window",
    "setTimeout",
    "__fireLongTap",
    "__fireTrack",
    "keys",
    "length",
    "_calcAngle",
    "_calcDistance",
    "gesture",
    "oldClientX",
    "oldClientY",
    "lastEventTime",
    "velocityX",
    "velocityY",
    "__fireRotate",
    "__firePinch",
    "isTap",
    "_isBelowTapMaxDistance",
    "$$gestureHandler",
    "parentNode",
    "__handleRollImpulse",
    "_fireEvent",
    "isDblTap",
    "limit",
    "now",
    "time",
    "lastTap",
    "isBelowDoubleTapDistance",
    "__isBelowDoubleTapDistance",
    "getPointerType",
    "isSameTarget",
    "isSameButton",
    "button",
    "swipe",
    "__getSwipeGesture",
    "stopMomentum",
    "id",
    "updateGestureTarget",
    "deltaX",
    "deltaY",
    "oldTimeoutId",
    "timeoutId",
    "Math",
    "abs",
    "getWindow",
    "startFactor",
    "AnimationFrame",
    "request",
    "lang",
    "Function",
    "round",
    "delta",
    "momentum",
    "pointerA",
    "pointerB",
    "atan2",
    "PI",
    "scale",
    "sqrt",
    "pow",
    "_getDeltaCoordinates",
    "maxDistance",
    "x1",
    "y1",
    "x2",
    "y2",
    "clazz",
    "inX",
    "inY",
    "startX",
    "startY",
    "axis",
    "evt",
    "dom",
    "Custom",
    "bubbles",
    "angle",
    "dispatchEvent",
    "currentTarget",
    "srcElement",
    "emit",
    "deltaCoordinates",
    "duration",
    "startTime",
    "distance",
    "direction",
    "velocity",
    "__fireRollEvent",
    "rollFactor",
    "util",
    "Wheel",
    "getDelta",
    "__performAdaptativeRollScrolling",
    "IS_TOUCHPAD",
    "reLength",
    "i",
    "__endTouchPadDetection",
    "_isTouchPadDetectionEnabled",
    "detectionTimeout",
    "Timer",
    "once",
    "push",
    "longTapTimer",
    "clearTimeout",
    "dispose"
  ],
  "mappings": "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",
  "file": "GestureCore.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2014 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Christopher Zuendorf (czuendorf)\n     * Daniel Wagner (danielwagner)\n\n************************************************************************ */\n\n/**\n * Listens for (native or synthetic) pointer events and fires events\n * for gestures like \"tap\" or \"swipe\"\n */\nqx.Bootstrap.define(\"qx.event.handler.GestureCore\", {\n  extend : Object,\n  implement: [ qx.core.IDisposable ],\n\n  statics : {\n\n    TYPES : [\"tap\", \"swipe\", \"longtap\", \"dbltap\", \"track\", \"trackstart\", \"trackend\", \"rotate\", \"pinch\", \"roll\"],\n\n    GESTURE_EVENTS : [\"gesturebegin\", \"gesturefinish\", \"gesturemove\", \"gesturecancel\"],\n\n    /** @type {Map} Maximum distance between a pointer-down and pointer-up event, values are configurable */\n    TAP_MAX_DISTANCE : {\"touch\": 40, \"mouse\": 5, \"pen\": 20}, // values are educated guesses\n\n    /** @type {Map} Maximum distance between two subsequent taps, values are configurable */\n    DOUBLETAP_MAX_DISTANCE : {\"touch\": 10, \"mouse\": 4, \"pen\": 10}, // values are educated guesses\n\n    /** @type {Map} The direction of a swipe relative to the axis */\n    SWIPE_DIRECTION :\n    {\n      x : [\"left\", \"right\"],\n      y : [\"up\", \"down\"]\n    },\n\n    /**\n     * @type {Integer} The time delta in milliseconds to fire a long tap event.\n     */\n    LONGTAP_TIME : 500,\n\n    /**\n     * @type {Integer} Maximum time between two tap events that will still trigger a\n     * dbltap event.\n     */\n    DOUBLETAP_TIME : 500,\n\n    /**\n     * @type {Integer} Factor which is used for adapting the delta of the mouse wheel\n     * event to the roll events,\n     */\n    ROLL_FACTOR: 18,\n\n    /**\n     * @type {Integer} Factor which is used for adapting the delta of the touchpad gesture\n     * event to the roll events,\n     */\n    TOUCHPAD_ROLL_FACTOR: 1,\n\n    /**\n     * @type {Integer} Minimum number of wheel events to receive during the\n     * TOUCHPAD_WHEEL_EVENTS_PERIOD to detect a touchpad.\n     */\n    TOUCHPAD_WHEEL_EVENTS_THRESHOLD: 10,\n\n    /**\n     * @type {Integer} Period (in ms) during which the wheel events are counted in order\n     * to detect a touchpad.\n     */\n    TOUCHPAD_WHEEL_EVENTS_PERIOD: 100,\n\n    /**\n     * @type {Integer} Timeout (in ms) after which the touchpad detection is reset if no wheel\n     * events are received in the meantime.\n     */\n    TOUCHPAD_WHEEL_EVENTS_TIMEOUT: 5000\n  },\n\n  /**\n   * @param target {Element} DOM Element that should fire gesture events\n   * @param emitter {qx.event.Emitter?} Event emitter (used if dispatchEvent\n   * is not supported, e.g. in IE8)\n   */\n  construct : function(target, emitter) {\n    this.__defaultTarget = target;\n    this.__emitter = emitter;\n    this.__gesture = {};\n    this.__lastTap = {};\n    this.__stopMomentum = {};\n    this.__momentum = {};\n    this.__rollEvents = [];\n    this._initObserver();\n  },\n\n  members : {\n    __defaultTarget : null,\n    __emitter : null,\n    __gesture : null,\n    __eventName : null,\n    __primaryTarget : null,\n    __isMultiPointerGesture : null,\n    __initialAngle : null,\n    __lastTap : null,\n    __rollImpulseId : null,\n    __stopMomentum : null,\n    __initialDistance : null,\n    __momentum : null,\n    __rollEvents : null,\n    __rollEventsCountStart : 0,\n    __rollEventsCount : 0,\n    __touchPadDetectionPerformed : false,\n    __lastRollEventTime: 0,\n\n    /**\n     * Register pointer event listeners\n     */\n    _initObserver : function() {\n      qx.event.handler.GestureCore.GESTURE_EVENTS.forEach(function(gestureType) {\n        qxWeb(this.__defaultTarget).on(gestureType, this.checkAndFireGesture, this);\n      }.bind(this));\n\n      if (qx.core.Environment.get(\"engine.name\") == \"mshtml\" &&\n        qx.core.Environment.get(\"browser.documentmode\") < 9)\n      {\n        qxWeb(this.__defaultTarget).on(\"dblclick\", this._onDblClick, this);\n      }\n\n      // list to wheel events\n      var data = qx.core.Environment.get(\"event.mousewheel\");\n      qxWeb(data.target).on(data.type, this._fireRoll, this);\n    },\n\n\n    /**\n     * Remove native pointer event listeners.\n     */\n    _stopObserver : function() {\n      qx.event.handler.GestureCore.GESTURE_EVENTS.forEach(function(pointerType) {\n        qxWeb(this.__defaultTarget).off(pointerType, this.checkAndFireGesture, this);\n      }.bind(this));\n\n      if (qx.core.Environment.get(\"engine.name\") == \"mshtml\" &&\n        qx.core.Environment.get(\"browser.documentmode\") < 9)\n      {\n        qxWeb(this.__defaultTarget).off(\"dblclick\", this._onDblClick, this);\n      }\n\n      var data = qx.core.Environment.get(\"event.mousewheel\");\n      qxWeb(data.target).off(data.type, this._fireRoll, this);\n    },\n\n\n    /**\n     * Checks if a gesture was made and fires the gesture event.\n     *\n     * @param domEvent {qx.event.type.Pointer} DOM event\n     * @param type {String ? null} type of the event\n     * @param target {Element ? null} event target\n     */\n    checkAndFireGesture : function(domEvent, type, target) {\n      if (!type) {\n        type = domEvent.type;\n      }\n\n      if (!target) {\n        target = qx.bom.Event.getTarget(domEvent);\n      }\n\n      if (type == \"gesturebegin\") {\n        this.gestureBegin(domEvent, target);\n      } else if (type == \"gesturemove\") {\n        this.gestureMove(domEvent, target);\n      } else if (type == \"gesturefinish\") {\n        this.gestureFinish(domEvent, target);\n      } else if (type == \"gesturecancel\") {\n        this.gestureCancel(domEvent.pointerId);\n      }\n    },\n\n    /**\n     * Helper method for gesture start.\n     *\n     * @param domEvent {Event} DOM event\n     * @param target {Element} event target\n     */\n    gestureBegin : function(domEvent, target) {\n      if (this.__gesture[domEvent.pointerId]) {\n        this.__stopLongTapTimer(this.__gesture[domEvent.pointerId]);\n        delete this.__gesture[domEvent.pointerId];\n      }\n\n      /*\n        If the dom event's target or one of its ancestors have\n        a gesture handler, we don't need to fire the gesture again\n        since it bubbles.\n       */\n      if (this._hasIntermediaryHandler(target)) {\n        return;\n      }\n\n      this.__gesture[domEvent.pointerId] = {\n        \"startTime\" : new Date().getTime(),\n        \"lastEventTime\" : new Date().getTime(),\n        \"startX\" : domEvent.clientX,\n        \"startY\" : domEvent.clientY,\n        \"clientX\" : domEvent.clientX,\n        \"clientY\" : domEvent.clientY,\n        \"velocityX\" : 0,\n        \"velocityY\" : 0,\n        \"target\" : target,\n        \"isTap\" : true,\n        \"isPrimary\" : domEvent.isPrimary,\n        \"longTapTimer\" : window.setTimeout(\n          this.__fireLongTap.bind(this, domEvent, target),\n          qx.event.handler.GestureCore.LONGTAP_TIME\n        )\n      };\n\n      if(domEvent.isPrimary) {\n        this.__isMultiPointerGesture = false;\n        this.__primaryTarget = target;\n        this.__fireTrack(\"trackstart\", domEvent, target);\n      } else {\n        this.__isMultiPointerGesture = true;\n        if(Object.keys(this.__gesture).length === 2) {\n          this.__initialAngle = this._calcAngle();\n          this.__initialDistance = this._calcDistance();\n        }\n      }\n    },\n\n\n    /**\n     * Helper method for gesture move.\n     *\n     * @param domEvent {Event} DOM event\n     * @param target {Element} event target\n     */\n    gestureMove : function(domEvent, target) {\n      var gesture = this.__gesture[domEvent.pointerId];\n\n      if (gesture) {\n        var oldClientX = gesture.clientX;\n        var oldClientY = gesture.clientY;\n\n        gesture.clientX = domEvent.clientX;\n        gesture.clientY = domEvent.clientY;\n        gesture.lastEventTime = new Date().getTime();\n\n        if(oldClientX) {\n          gesture.velocityX = gesture.clientX - oldClientX;\n        }\n        if(oldClientY) {\n          gesture.velocityY = gesture.clientY - oldClientY;\n        }\n\n        if (Object.keys(this.__gesture).length === 2) {\n          this.__fireRotate(domEvent, gesture.target);\n          this.__firePinch(domEvent, gesture.target);\n        }\n\n        if(!this.__isMultiPointerGesture) {\n          this.__fireTrack(\"track\", domEvent, gesture.target);\n          this._fireRoll(domEvent, \"touch\", gesture.target);\n        }\n\n        // abort long tap timer if the distance is too big\n        if (gesture.isTap) {\n          gesture.isTap = this._isBelowTapMaxDistance(domEvent);\n          if (!gesture.isTap) {\n            this.__stopLongTapTimer(gesture);\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Checks if a DOM element located between the target of a gesture\n     * event and the element this handler is attached to has a gesture\n     * handler of its own.\n     *\n     * @param target {Element} The gesture event's target\n     * @return {Boolean}\n     */\n    _hasIntermediaryHandler: function(target) {\n      while (target && target !== this.__defaultTarget) {\n        if (target.$$gestureHandler) {\n          return true;\n        }\n        target = target.parentNode;\n      }\n      return false;\n    },\n\n\n    /**\n     * Helper method for gesture end.\n     *\n     * @param domEvent {Event} DOM event\n     * @param target {Element} event target\n     */\n    gestureFinish : function(domEvent, target) {\n      // If no start position is available for this pointerup event, cancel gesture recognition.\n      if (!this.__gesture[domEvent.pointerId]) {\n        return;\n      }\n\n      var gesture = this.__gesture[domEvent.pointerId];\n      // delete the long tap\n      this.__stopLongTapTimer(gesture);\n\n      /*\n        If the dom event's target or one of its ancestors have\n        a gesture handler, we don't need to fire the gesture again\n        since it bubbles.\n       */\n      if (this._hasIntermediaryHandler(target)) {\n        return;\n      }\n\n      // always start the roll impulse on the original target\n      this.__handleRollImpulse(\n        gesture.velocityX,\n        gesture.velocityY,\n        domEvent,\n        gesture.target\n      );\n\n      this.__fireTrack(\"trackend\", domEvent, gesture.target);\n\n      if (gesture.isTap) {\n        if (target !== gesture.target) {\n\n          delete this.__gesture[domEvent.pointerId];\n          return;\n        }\n\n        this._fireEvent(domEvent, \"tap\", domEvent.target || target);\n\n        var isDblTap = false;\n        if (Object.keys(this.__lastTap).length > 0) {\n          // delete old tap entries\n          var limit = Date.now() - qx.event.handler.GestureCore.DOUBLETAP_TIME;\n          for (var time in this.__lastTap) {\n\n            if (time < limit) {\n              delete this.__lastTap[time];\n            } else {\n              var lastTap = this.__lastTap[time];\n              var isBelowDoubleTapDistance = this.__isBelowDoubleTapDistance(\n                lastTap.x,\n                lastTap.y,\n                domEvent.clientX,\n                domEvent.clientY,\n                domEvent.getPointerType()\n              );\n              var isSameTarget = lastTap.target === (domEvent.target || target);\n              var isSameButton = lastTap.button === domEvent.button;\n\n              if (isBelowDoubleTapDistance && isSameButton && isSameTarget) {\n                isDblTap = true;\n                delete this.__lastTap[time];\n                this._fireEvent(domEvent, \"dbltap\", domEvent.target || target);\n              }\n            }\n          }\n        }\n\n        if (!isDblTap) {\n          this.__lastTap[Date.now()] = {\n            x: domEvent.clientX,\n            y: domEvent.clientY,\n            target: domEvent.target || target,\n            button: domEvent.button\n          };\n        }\n\n      } else if (!this._isBelowTapMaxDistance(domEvent)) {\n        var swipe = this.__getSwipeGesture(domEvent, target);\n        if (swipe) {\n          domEvent.swipe = swipe;\n          this._fireEvent(domEvent, \"swipe\", gesture.target || target);\n        }\n      }\n\n      delete this.__gesture[domEvent.pointerId];\n    },\n\n\n    /**\n     * Stops the momentum scrolling currently running.\n     *\n     * @param id {Integer} The timeoutId of a 'roll' event\n     */\n    stopMomentum : function(id) {\n      this.__stopMomentum[id] = true;\n    },\n\n\n    /**\n     * Cancels the gesture if running.\n     * @param id {Number} The pointer Id.\n     */\n    gestureCancel : function(id) {\n      if (this.__gesture[id]) {\n        this.__stopLongTapTimer(this.__gesture[id]);\n        delete this.__gesture[id];\n      }\n      if (this.__momentum[id]) {\n        this.stopMomentum(this.__momentum[id]);\n        delete this.__momentum[id];\n      }\n    },\n\n\n    /**\n     * Update the target of a running gesture. This is used in virtual widgets\n     * when the DOM element changes.\n     *\n     * @param id {String} The pointer id.\n     * @param target {Element} The new target element.\n     * @internal\n     */\n    updateGestureTarget : function(id, target) {\n      this.__gesture[id].target = target;\n    },\n\n\n    /**\n     * Method which will be called recursively to provide a momentum scrolling.\n     * @param deltaX {Number} The last offset in X direction\n     * @param deltaY {Number} The last offset in Y direction\n     * @param domEvent {Event} The original gesture event\n     * @param target {Element} The target of the momentum roll events\n     * @param time {Number ?} The time in ms between the last two calls\n     */\n    __handleRollImpulse : function(deltaX, deltaY, domEvent, target, time) {\n      var oldTimeoutId = domEvent.timeoutId;\n      if (!time && this.__momentum[domEvent.pointerId]) {\n        // new roll impulse started, stop the old one\n        this.stopMomentum(this.__momentum[domEvent.pointerId]);\n      }\n      // do nothing if we don't need to scroll\n      if ((Math.abs(deltaY) < 1 && Math.abs(deltaX) < 1) || this.__stopMomentum[oldTimeoutId] || !this.getWindow()) {\n        delete this.__stopMomentum[oldTimeoutId];\n        delete this.__momentum[domEvent.pointerId];\n        return;\n      }\n\n      if (!time) {\n        time = 1;\n        var startFactor = 2.8;\n        deltaY = deltaY / startFactor;\n        deltaX = deltaX / startFactor;\n      }\n      time += 0.0006;\n\n      deltaY = deltaY / time;\n      deltaX = deltaX / time;\n\n      // set up a new timer with the new delta\n      var timeoutId = qx.bom.AnimationFrame.request(\n        qx.lang.Function.bind(\n          function(deltaX, deltaY, domEvent, target, time) {\n            this.__handleRollImpulse(deltaX, deltaY, domEvent, target, time);\n          },\n          this, deltaX, deltaY, domEvent, target, time)\n      );\n\n      deltaX = Math.round(deltaX * 100) / 100;\n      deltaY = Math.round(deltaY * 100) / 100;\n\n      // scroll the desired new delta\n      domEvent.delta = {\n        x: -deltaX,\n        y: -deltaY\n      };\n      domEvent.momentum = true;\n      domEvent.timeoutId = timeoutId;\n      this.__momentum[domEvent.pointerId] = timeoutId;\n      this._fireEvent(domEvent, \"roll\", domEvent.target || target);\n    },\n\n\n    /**\n    * Calculates the angle of the primary and secondary pointer.\n    * @return {Number} the rotation angle of the 2 pointers.\n    */\n    _calcAngle : function() {\n      var pointerA = null;\n      var pointerB = null;\n\n      for (var pointerId in this.__gesture) {\n        var gesture = this.__gesture[pointerId];\n        if (pointerA === null) {\n          pointerA = gesture;\n        } else {\n          pointerB = gesture;\n        }\n      }\n\n      var x = pointerA.clientX - pointerB.clientX;\n      var y = pointerA.clientY - pointerB.clientY;\n\n      return (360 + Math.atan2(y, x) * (180/Math.PI)) % 360;\n    },\n\n\n    /**\n     * Calculates the scaling distance between two pointers.\n     * @return {Number} the calculated distance.\n     */\n    _calcDistance : function() {\n      var pointerA = null;\n      var pointerB = null;\n\n      for (var pointerId in this.__gesture) {\n        var gesture = this.__gesture[pointerId];\n        if (pointerA === null) {\n          pointerA = gesture;\n        } else {\n          pointerB = gesture;\n        }\n      }\n\n      var scale = Math.sqrt( Math.pow(pointerA.clientX - pointerB.clientX, 2) + Math.pow(pointerA.clientY - pointerB.clientY, 2));\n      return scale;\n    },\n\n\n    /**\n     * Checks if the distance between the x/y coordinates of DOM event\n     * exceeds TAP_MAX_DISTANCE and returns the result.\n     *\n     * @param domEvent {Event} The DOM event from the browser.\n     * @return {Boolean|null} true if distance is below TAP_MAX_DISTANCE.\n     */\n    _isBelowTapMaxDistance: function(domEvent) {\n      var delta = this._getDeltaCoordinates(domEvent);\n      var maxDistance = qx.event.handler.GestureCore.TAP_MAX_DISTANCE[domEvent.getPointerType()];\n      if (!delta) {\n        return null;\n      }\n\n      return (Math.abs(delta.x) <= maxDistance &&\n              Math.abs(delta.y) <= maxDistance);\n    },\n\n\n    /**\n     * Checks if the distance between the x1/y1 and x2/y2 is\n     * below the TAP_MAX_DISTANCE and returns the result.\n     *\n     * @param x1 {Number} The x position of point one.\n     * @param y1 {Number} The y position of point one.\n     * @param x2 {Number} The x position of point two.\n     * @param y2 {Number} The y position of point two.\n     * @param type {String} The pointer type e.g. \"mouse\"\n     * @return {Boolean} <code>true</code>, if points are in range\n     */\n    __isBelowDoubleTapDistance : function(x1, y1, x2, y2, type) {\n      var clazz = qx.event.handler.GestureCore;\n\n      var inX = Math.abs(x1 - x2) < clazz.DOUBLETAP_MAX_DISTANCE[type];\n      var inY = Math.abs(y1 - y2) < clazz.DOUBLETAP_MAX_DISTANCE[type];\n\n      return inX && inY;\n    },\n\n\n    /**\n    * Calculates the delta coordinates in relation to the position on <code>pointerstart</code> event.\n    * @param domEvent {Event} The DOM event from the browser.\n    * @return {Map} containing the deltaX as x, and deltaY as y.\n    */\n    _getDeltaCoordinates : function(domEvent) {\n      var gesture = this.__gesture[domEvent.pointerId];\n      if (!gesture) {\n        return null;\n      }\n\n      var deltaX = domEvent.clientX - gesture.startX;\n      var deltaY = domEvent.clientY - gesture.startY;\n\n      var axis = \"x\";\n      if (Math.abs(deltaX / deltaY) < 1) {\n        axis = \"y\";\n      }\n\n      return {\n        \"x\": deltaX,\n        \"y\": deltaY,\n        \"axis\": axis\n      };\n    },\n\n\n    /**\n     * Fire a gesture event with the given parameters\n     *\n     * @param domEvent {Event} DOM event\n     * @param type {String} type of the event\n     * @param target {Element ? null} event target\n     * @return {qx.Promise?} a promise, if one or more of the event handlers returned a promise\n     */\n    _fireEvent : function(domEvent, type, target) {\n      // The target may have been removed, e.g. menu hide on tap\n      if (!this.__defaultTarget) {\n        return;\n      }\n      var evt;\n      if (qx.core.Environment.get(\"event.dispatchevent\")) {\n        evt = new qx.event.type.dom.Custom(type, domEvent, {\n          bubbles: true,\n          swipe: domEvent.swipe,\n          scale: domEvent.scale,\n          angle: domEvent.angle,\n          delta: domEvent.delta,\n          pointerType: domEvent.pointerType,\n          momentum : domEvent.momentum\n        });\n        return target.dispatchEvent(evt);\n      } else if (this.__emitter) {\n        evt = new qx.event.type.dom.Custom(type, domEvent, {\n          target : this.__defaultTarget,\n          currentTarget : this.__defaultTarget,\n          srcElement : this.__defaultTarget,\n          swipe: domEvent.swipe,\n          scale: domEvent.scale,\n          angle: domEvent.angle,\n          delta: domEvent.delta,\n          pointerType: domEvent.pointerType,\n          momentum : domEvent.momentum\n        });\n\n        this.__emitter.emit(type, domEvent);\n      }\n    },\n\n\n    /**\n     * Fire \"tap\" and \"dbltap\" events after a native \"dblclick\"\n     * event to fix IE 8's broken mouse event sequence.\n     *\n     * @param domEvent {Event} dblclick event\n     */\n    _onDblClick : function(domEvent) {\n      var target = qx.bom.Event.getTarget(domEvent);\n      this._fireEvent(domEvent, \"tap\", target);\n      this._fireEvent(domEvent, \"dbltap\", target);\n    },\n\n\n    /**\n     * Returns the swipe gesture when the user performed a swipe.\n     *\n     * @param domEvent {Event} DOM event\n     * @param target {Element} event target\n     * @return {Map|null} returns the swipe data when the user performed a swipe, null if the gesture was no swipe.\n     */\n    __getSwipeGesture : function(domEvent, target) {\n      var gesture = this.__gesture[domEvent.pointerId];\n      if (!gesture) {\n        return null;\n      }\n\n      var clazz = qx.event.handler.GestureCore;\n      var deltaCoordinates = this._getDeltaCoordinates(domEvent);\n      var duration = new Date().getTime() - gesture.startTime;\n      var axis = (Math.abs(deltaCoordinates.x) >= Math.abs(deltaCoordinates.y)) ? \"x\" : \"y\";\n      var distance = deltaCoordinates[axis];\n      var direction = clazz.SWIPE_DIRECTION[axis][distance < 0 ? 0 : 1];\n      var velocity = (duration !== 0) ? distance / duration : 0;\n\n      var swipe = {\n        startTime: gesture.startTime,\n        duration: duration,\n        axis: axis,\n        direction: direction,\n        distance: distance,\n        velocity: velocity\n      };\n\n      return swipe;\n    },\n\n\n    /**\n     * Fires a track event.\n     *\n     * @param type {String} the track type\n     * @param domEvent {Event} DOM event\n     * @param target {Element} event target\n     */\n    __fireTrack : function(type, domEvent, target) {\n      domEvent.delta = this._getDeltaCoordinates(domEvent);\n      this._fireEvent(domEvent, type, domEvent.target || target);\n    },\n\n\n    /**\n     * Fires a roll event.\n     *\n     * @param domEvent {Event} DOM event\n     * @param target {Element} event target\n     * @param rollFactor {Integer} the roll factor to apply\n     */\n    __fireRollEvent: function (domEvent, target, rollFactor) {\n      domEvent.delta = {\n        x: qx.util.Wheel.getDelta(domEvent, \"x\") * rollFactor,\n        y: qx.util.Wheel.getDelta(domEvent, \"y\") * rollFactor\n      };\n      domEvent.delta.axis = Math.abs(domEvent.delta.x / domEvent.delta.y) < 1 ? \"y\" : \"x\";\n      domEvent.pointerType = \"wheel\";\n      this._fireEvent(domEvent, \"roll\", domEvent.target || target);\n    },\n\n    /**\n     * Triggers the adaptative roll scrolling.\n     *\n     * @param target {Element} event target\n     */\n    __performAdaptativeRollScrolling: function (target) {\n      var rollFactor = qx.event.handler.GestureCore.ROLL_FACTOR;\n      if (qx.util.Wheel.IS_TOUCHPAD) {\n        // The domEvent was generated by a touchpad\n        rollFactor = qx.event.handler.GestureCore.TOUCHPAD_ROLL_FACTOR;\n      }\n      this.__lastRollEventTime = new Date().getTime();\n      var reLength = this.__rollEvents.length;\n      for (var i = 0; i < reLength; i++) {\n        var domEvent = this.__rollEvents[i];\n        this.__fireRollEvent(domEvent, target, rollFactor);\n      }\n      this.__rollEvents = [];\n    },\n\n    /**\n     * Ends touch pad detection process.\n     */\n    __endTouchPadDetection: function () {\n      if (this.__rollEvents.length > qx.event.handler.GestureCore.TOUCHPAD_WHEEL_EVENTS_THRESHOLD) {\n        qx.util.Wheel.IS_TOUCHPAD = true;\n      } else {\n        qx.util.Wheel.IS_TOUCHPAD = false;\n      }\n      if (qx.core.Environment.get(\"qx.debug.touchpad.detection\")) {\n        qx.log.Logger.debug(this, \"IS_TOUCHPAD : \" + qx.util.Wheel.IS_TOUCHPAD);\n      }\n      this.__touchPadDetectionPerformed = true;\n    },\n\n    /**\n     * Is touchpad detection enabled ? Default implementation activates it only for Mac OS after Sierra (>= 10.12).\n     * @return {boolean} true if touchpad detection should occur.\n     * @internal\n     */\n    _isTouchPadDetectionEnabled: function () {\n      return qx.core.Environment.get(\"os.name\") == \"osx\" && qx.core.Environment.get(\"os.version\") >= 10.12;\n    },\n\n    /**\n     * Fires a roll event after determining the roll factor to apply. Mac OS Sierra (10.12+)\n     * introduces a lot more wheel events fired from the trackpad, so the roll factor to be applied\n     * has to be reduced in order to make the scrolling less sensitive.\n     *\n     * @param domEvent {Event} DOM event\n     * @param type {String} The type of the dom event\n     * @param target {Element} event target\n     */\n    _fireRoll : function(domEvent, type, target) {\n      var now;\n      var detectionTimeout;\n      if (domEvent.type === qx.core.Environment.get(\"event.mousewheel\").type) {\n        if (this._isTouchPadDetectionEnabled()) {\n          now = new Date().getTime();\n          detectionTimeout = qx.event.handler.GestureCore.TOUCHPAD_WHEEL_EVENTS_TIMEOUT;\n          if (this.__lastRollEventTime > 0 && now - this.__lastRollEventTime > detectionTimeout) {\n            // The detection timeout was reached. A new detection step should occur.\n            this.__touchPadDetectionPerformed = false;\n            this.__rollEvents = [];\n            this.__lastRollEventTime = 0;\n          }\n          if (!this.__touchPadDetectionPerformed) {\n            // We are into a detection session. We count the events so that we can decide if\n            // they were fired by a real mouse wheel or a touchpad. Just swallow them until the\n            // detection period is over.\n            if (this.__rollEvents.length === 0) {\n              // detection starts\n              this.__rollEventsCountStart = now;\n              qx.event.Timer.once(function () {\n                if (!this.__touchPadDetectionPerformed) {\n                  // There were not enough events during the TOUCHPAD_WHEEL_EVENTS_PERIOD to actually\n                  // trigger a scrolling. Trigger it manually.\n                  this.__endTouchPadDetection();\n                  this.__performAdaptativeRollScrolling(target);\n                }\n              }, this, qx.event.handler.GestureCore.TOUCHPAD_WHEEL_EVENTS_PERIOD + 50)\n            }\n            this.__rollEvents.push(domEvent);\n            this.__rollEventsCount++;\n            if (now - this.__rollEventsCountStart > qx.event.handler.GestureCore.TOUCHPAD_WHEEL_EVENTS_PERIOD) {\n              this.__endTouchPadDetection();\n            }\n          }\n          if (this.__touchPadDetectionPerformed) {\n            if (this.__rollEvents.length === 0) {\n              this.__rollEvents.push(domEvent);\n            }\n            // Detection is done. We can now decide the roll factor to apply to the delta.\n            // Default to a real mouse wheel event as opposed to a touchpad one.\n            this.__performAdaptativeRollScrolling(target);\n          }\n        } else {\n          this.__fireRollEvent(domEvent, target, qx.event.handler.GestureCore.ROLL_FACTOR);\n        }\n      } else {\n        var gesture = this.__gesture[domEvent.pointerId];\n        domEvent.delta = {\n          x: -gesture.velocityX,\n          y: -gesture.velocityY,\n          axis : Math.abs(gesture.velocityX / gesture.velocityY) < 1 ? \"y\" : \"x\"\n        };\n        this._fireEvent(domEvent, \"roll\", domEvent.target || target);\n      }\n    },\n\n\n    /**\n     * Fires a rotate event.\n     *\n     * @param domEvent {Event} DOM event\n     * @param target {Element} event target\n     */\n    __fireRotate : function(domEvent, target) {\n      if(!domEvent.isPrimary) {\n        var angle = this._calcAngle();\n        domEvent.angle = Math.round((angle - this.__initialAngle) % 360);\n        this._fireEvent(domEvent, \"rotate\", this.__primaryTarget);\n      }\n    },\n\n\n    /**\n     * Fires a pinch event.\n     *\n     * @param domEvent {Event} DOM event\n     * @param target {Element} event target\n     */\n    __firePinch: function(domEvent, target) {\n      if (!domEvent.isPrimary) {\n        var distance = this._calcDistance();\n        var scale = distance / this.__initialDistance;\n        domEvent.scale = (Math.round(scale * 100) / 100);\n        this._fireEvent(domEvent, \"pinch\", this.__primaryTarget);\n      }\n    },\n\n\n    /**\n     * Fires the long tap event.\n     *\n     * @param domEvent {Event} DOM event\n     * @param target {Element} event target\n     */\n    __fireLongTap : function(domEvent, target) {\n      var gesture = this.__gesture[domEvent.pointerId];\n      if (gesture) {\n        this._fireEvent(domEvent, \"longtap\", domEvent.target || target);\n        gesture.longTapTimer = null;\n        gesture.isTap = false;\n      }\n    },\n\n\n    /**\n     * Stops the time for the long tap event.\n     * @param gesture {Map} Data may representing the gesture.\n     */\n    __stopLongTapTimer : function(gesture) {\n      if (gesture.longTapTimer) {\n        window.clearTimeout(gesture.longTapTimer);\n        gesture.longTapTimer = null;\n      }\n    },\n\n    /**\n     * Dispose the current instance\n     */\n    dispose : function() {\n      for(var gesture in this.__gesture) {\n        this.__stopLongTapTimer(gesture);\n      }\n\n      this._stopObserver();\n      this.__defaultTarget = this.__emitter = null;\n    }\n  }\n});\n"
  ]
}