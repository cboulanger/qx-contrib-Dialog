{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/event/message/Bus.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "type",
    "extend",
    "core",
    "Object",
    "statics",
    "getSubscriptions",
    "getInstance",
    "subscribe",
    "message",
    "subscriber",
    "context",
    "checkSubscription",
    "unsubscribe",
    "dispatch",
    "msg",
    "apply",
    "arguments",
    "dispatchByName",
    "name",
    "data",
    "construct",
    "__subscriptions",
    "members",
    "error",
    "sub",
    "warn",
    "push",
    "length",
    "i",
    "subscrList",
    "subscription",
    "splice",
    "msgName",
    "getName",
    "dispatched",
    "key",
    "pos",
    "indexOf",
    "substr",
    "__callSubscribers",
    "event",
    "Message",
    "ret",
    "dispose",
    "subscribers",
    "slice",
    "isDisposed",
    "call",
    "Bus"
  ],
  "mappings": "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",
  "file": "Bus.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007 Christian Boulanger\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Christian Boulanger\n\n************************************************************************ */\n\n/**\n * A simple message bus singleton.\n * The message bus registers subscriptions and notifies subscribers when\n * a matching message is dispatched\n */\nqx.Class.define(\"qx.event.message.Bus\",\n{\n  type : \"singleton\",\n\n  extend : qx.core.Object,\n\n  statics :\n  {\n\n    /**\n     * gets the hash map of message subscriptions\n     *\n     * @return {Map} with registered subscriptions. The key is the\n     *    <code>message</code> and the value is a map with <code>{subscriber: {Function},\n     *    context: {Object|null}}</code>.\n     */\n    getSubscriptions : function() {\n      return this.getInstance().getSubscriptions();\n    },\n\n\n    /**\n     * subscribes to a message\n     *\n     * @param message {String} name of message, can be truncated by *\n     * @param subscriber {Function} subscribing callback function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribe : function(message, subscriber, context)\n    {\n      return this.getInstance().subscribe(message, subscriber, context);\n\n    },\n\n    /**\n     * checks if subscription is already present\n     * if you supply the callback function, match only the exact message monitor\n     * otherwise match all monitors that have the given message\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor is present or not\n     */\n    checkSubscription : function(message, subscriber, context)\n    {\n      return this.getInstance().checkSubscription(message, subscriber, context);\n    },\n\n    /**\n     * unsubscribe a listening method\n     * if you supply the callback function and execution context,\n     * remove only this exact subscription\n     * otherwise remove all subscriptions\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor was removed or not\n     */\n    unsubscribe : function(message, subscriber, context)\n    {\n      return this.getInstance().unsubscribe(message, subscriber, context);\n    },\n\n    /**\n     * dispatch message and call subscribed functions\n     *\n     * @param msg {qx.event.message.Message} message which is being dispatched\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatch : function(msg)\n    {\n      return this.getInstance().dispatch.apply(this.getInstance(), arguments);\n    },\n\n    /**\n     * Dispatches a new message by supplying the name of the\n     * message and its data.\n     *\n     * @param name {String} name of the message\n     * @param data {var} Any type of data to attach\n     *\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatchByName : function(name, data)\n    {\n      return this.getInstance().dispatchByName.apply(this.getInstance(), arguments);\n    }\n  },\n\n  /**\n   * constructor\n   */\n  construct : function()\n  {\n    /*\n     * message subscriptions database\n     */\n    this.__subscriptions = {};\n  },\n\n  members :\n  {\n    __subscriptions : null,\n\n\n    /**\n     * gets the hash map of message subscriptions\n     *\n     * @return {Map} with registered subscriptions. The key is the\n     *    <code>message</code> and the value is a map with <code>{subscriber: {Function},\n     *    context: {Object|null}}</code>.\n     */\n    getSubscriptions : function() {\n      return this.__subscriptions;\n    },\n\n\n    /**\n     * subscribes to a message\n     *\n     * @param message {String} name of message, can be truncated by *\n     * @param subscriber {Function} subscribing callback function\n     * @param context {Object} The execution context of the callback (i.e. \"this\")\n     * @return {Boolean} Success\n     */\n    subscribe : function(message, subscriber, context)\n    {\n      if (!message || typeof subscriber != \"function\")\n      {\n        this.error(\"Invalid parameters! \"+ [message, subscriber, context]);\n\n        return false;\n      }\n\n      var sub = this.getSubscriptions();\n\n      if (this.checkSubscription(message))\n      {\n        if (this.checkSubscription(message, subscriber, context))\n        {\n          this.warn(\"Object method already subscribed to \" + message);\n          return false;\n        }\n\n        // add a subscription\n        sub[message].push(\n        {\n          subscriber : subscriber,\n          context    : context || null\n        });\n\n        return true;\n      }\n      else\n      {\n        // create a subscription\n        sub[message] = [ {\n          subscriber : subscriber,\n          context    : context || null\n        } ];\n\n        return true;\n      }\n    },\n\n\n    /**\n     * checks if subscription is already present\n     * if you supply the callback function, match only the exact message monitor\n     * otherwise match all monitors that have the given message\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor is present or not\n     */\n    checkSubscription : function(message, subscriber, context)\n    {\n      var sub = this.getSubscriptions();\n\n      if (!sub[message] || sub[message].length === 0) {\n        return false;\n      }\n\n      if (subscriber)\n      {\n        for (var i=0; i<sub[message].length; i++)\n        {\n          if (sub[message][i].subscriber === subscriber && sub[message][i].context === (context || null)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      return true;\n    },\n\n\n    /**\n     * unsubscribe a listening method\n     * if you supply the callback function and execution context,\n     * remove only this exact subscription\n     * otherwise remove all subscriptions\n     *\n     * @param message {String} Name of message, can be truncated by *\n     * @param subscriber {Function} Callback Function\n     * @param context {Object} execution context\n     * @return {Boolean} Whether monitor was removed or not\n     */\n    unsubscribe : function(message, subscriber, context)\n    {\n       var sub = this.getSubscriptions();\n       var subscrList = sub[message];\n       if (subscrList) {\n         if (!subscriber) {\n           sub[message] = null;\n           delete sub[message];\n           return true;\n         } else {\n           if (! context) {\n             context = null;\n           }\n           var i = subscrList.length;\n           var subscription;\n           do {\n             subscription = subscrList[--i];\n             if (subscription.subscriber === subscriber && subscription.context === context) {\n               subscrList.splice(i, 1);\n               if (subscrList.length === 0) {\n                 sub[message] = null;\n                 delete sub[message];\n               }\n               return true;\n             }\n           } while (i);\n         }\n       }\n       return false;\n    },\n\n    /**\n     * dispatch message and call subscribed functions\n     *\n     * @param msg {qx.event.message.Message} message which is being dispatched\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatch : function(msg)\n    {\n      var sub = this.getSubscriptions();\n      var msgName = msg.getName();\n      var dispatched = false;\n\n      for (var key in sub)\n      {\n        var pos = key.indexOf(\"*\");\n\n        if (pos > -1)\n        {\n          // use of wildcard\n          if (pos === 0 || key.substr(0, pos) === msgName.substr(0, pos))\n          {\n            this.__callSubscribers(sub[key], msg);\n            dispatched = true;\n          }\n        }\n        else\n        {\n          // exact match\n          if (key === msgName)\n          {\n            this.__callSubscribers(sub[msgName], msg);\n            dispatched = true;\n          }\n        }\n      }\n\n      return dispatched;\n    },\n\n    /**\n     * Dispatches a new message by supplying the name of the\n     * message and its data.\n     *\n     * @param name {String} name of the message\n     * @param data {var} Any type of data to attach\n     *\n     * @return {Boolean} <code>true</code> if the message was dispatched,\n     *    <code>false</code> otherwise.\n     */\n    dispatchByName : function(name, data)\n    {\n      var message = new qx.event.message.Message(name, data);\n\n      // Dispatch the message\n      var ret = this.dispatch(message);\n\n      // We instantiated this message, so it's our responsibility to dispose it.\n      message.dispose();\n      message = null;\n\n      // Let 'em know whether this message was dispatched to any subscribers.\n      return ret;\n    },\n\n\n    /**\n     * Call subscribers with passed message.\n     *\n     * Each currently-subscribed subscriber function will be called in\n     * turn. Any requests to unsubscribe a subscriber from the list, while\n     * processing the currently-subscribed subscriber functions, will take\n     * effect after all currently-subscribed subscriber functions have been\n     * processed.\n     *\n     * @param subscribers {Array} subscribers to call\n     * @param msg {qx.event.message.Message} message for subscribers\n     */\n    __callSubscribers : function(subscribers, msg)\n    {\n      // (Shallow) clone the subscribers array in case one of them alters the\n      // list, e.g., by unsubscribing\n      subscribers = subscribers.slice();\n\n      for (var i=0; i<subscribers.length; i++)\n      {\n        var subscriber = subscribers[i].subscriber;\n        var context = subscribers[i].context;\n\n        // call message monitor subscriber\n        if (context && context.isDisposed)\n        {\n          if (context.isDisposed())\n          {\n            subscribers.splice(i, 1);\n            i--;\n          }\n          else\n          {\n            subscriber.call(context, msg);\n          }\n        }\n        else\n        {\n          subscriber.call(context, msg);\n        }\n      }\n    }\n  }\n});\n"
  ]
}