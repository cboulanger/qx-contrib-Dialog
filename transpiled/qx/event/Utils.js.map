{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/event/Utils.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "statics",
    "ABORT",
    "track",
    "tracker",
    "fn",
    "Promise",
    "value",
    "then",
    "__push",
    "newPromise",
    "promises",
    "undefined",
    "ex",
    "Error",
    "e",
    "push",
    "promise",
    "rejected",
    "self",
    "result",
    "event",
    "Utils",
    "reject",
    "__addCatcher",
    "__thenPromise",
    "__catcher",
    "catch",
    "bind",
    "err",
    "catchers",
    "catch1",
    "catch2",
    "callListener",
    "listener",
    "context",
    "tmp",
    "handler",
    "call",
    "getPropagationStopped",
    "series",
    "arr",
    "ignoreAbort",
    "index",
    "length",
    "item"
  ],
  "mappings": "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",
  "file": "Utils.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2018 Zenesis Ltd, john.spackman@zenesis.com\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * John Spackman (johnspackman)\n\n************************************************************************ */\n\n/**\n * Utility methods which implement a fast, psuedo-promises mechanism used by event handlers\n * and dispatchers.\n *\n * Event handlers are allowed to return instances of `qx.Promise`, in which case the event\n * queue is suspended until the promise is resolved.  The simplest way to handle this would be\n * to convert the result of every event handler into a `qx.Promise` via `qx.Promise.resolve`,\n * but given that by far the majority of event handlers do not return promises, this could add\n * a significant overhead; the static methods in this class allow the event handlers to be\n * triggered and only when a `qx.Promise` is returned from a handler does the event dispatch\n * mechanism switch to using promise to suspend the event queue.\n *\n * To use this, the calling code simply creates an empty object (i.e. `var tracker = {};`)\n * which is then passed to `qx.event.Utils.then`, for example:\n *\n * <code>\n * var tracker = {};\n * Utils.then(tracker, function() { ... });\n * Utils.then(tracker, function() { ... });\n * Utils.then(tracker, function() { ... });\n * Utils.catch(tracker, function() { ... });\n * </code>\n *\n * Following with the morphing nature of this class, the return type will be either the value\n * returned from the event handlers, or a promise which evaluates to that value.\n *\n * When events are aborted (eg via `event.stopPropagation()`) that causes the promise (if there\n * is one) to be rejected.\n *\n * Note that this class is not a replacement for promises and has its limitations because it\n * has been built for the express purposes of the event dispatchers.\n *\n * @internal\n * @ignore(qx.Promise)\n */\nqx.Class.define(\"qx.event.Utils\", {\n  extend: qx.core.Object,\n\n  statics: {\n    ABORT: \"[[ qx.event.Utils.ABORT ]]\",\n\n    /**\n     * Evaluates a value, and adds it to the tracker\n     *\n     * @param tracker {Object} the tracker object\n     * @param fn {Function|Object?} if a function, it's evaluated as a `then`, otherwise\n     *  it's encapulated in a function for `then`\n     * @return {qx.Promise|Object?}\n     */\n    track: qx.core.Environment.select(\"qx.promise\", {\n      \"true\": function(tracker, fn) {\n        if (typeof fn !== \"function\" && !(fn instanceof qx.Promise)) {\n          fn = (function(value) { return function() { return value; } })(fn);\n        }\n        return this.then(tracker, fn);\n      },\n      \"false\": function(tracker, fn) {\n        if (typeof fn === \"function\") {\n          return fn();\n        }\n        return fn;\n      }\n    }),\n\n    /**\n     * Helper method to store a promise in a tracker\n     *\n     * @param tracker {Object} the tracker object\n     * @param newPromise {qx.Promise} the new promise\n     * @return {qx.Promise} the new promise\n     */\n    __push: function(tracker, newPromise) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (tracker.promises === undefined) {\n          tracker.promises = [];\n        }\n        var ex = null;\n        try {\n          throw new Error(\"\");\n        } catch(e) {\n          ex = e;\n        }\n        tracker.promises.push({ promise: newPromise, ex: ex });\n      }\n      tracker.promise = newPromise;\n      return tracker.promise;\n    },\n\n    /**\n     * Equivalent of `promise.then()`\n     *\n     * @param tracker {Object} the tracker object\n     * @param fn {Function} the function to call when previous promises are complete\n     * @return {qx.Promise?} the new promise, or the return value from `fn` if no promises are in use\n     */\n    then: qx.core.Environment.select(\"qx.promise\", {\n      \"true\": function(tracker, fn) {\n        if (tracker.rejected) {\n          return null;\n        }\n        if (tracker.promise) {\n          if (fn instanceof qx.Promise) {\n            this.__push(tracker, tracker.promise.then(fn));\n          } else {\n            var self = this;\n            this.__push(tracker, tracker.promise.then(function (result) {\n                if (tracker.rejected) {\n                  return null;\n                }\n                result = fn(result);\n                if (result === qx.event.Utils.ABORT) {\n                  return self.reject(tracker);\n                }\n                return result;\n              })\n            );\n          }\n          this.__addCatcher(tracker);\n          return tracker.promise;\n        }\n        if (fn instanceof qx.Promise) {\n          return this.__thenPromise(tracker, fn);\n        }\n        var result = fn(tracker.result);\n        if (result instanceof qx.Promise) {\n          return this.__thenPromise(tracker, result);\n        }\n        tracker.result = result;\n        if (result === qx.event.Utils.ABORT) {\n          return this.reject(tracker);\n        }\n\n        return result;\n      },\n\n      \"false\": function(tracker, fn) {\n        if (tracker.rejected) {\n          return null;\n        }\n        var result = tracker.result = fn(tracker.result);\n        if (result === qx.event.Utils.ABORT) {\n          return this.reject(tracker);\n        }\n        return result;\n      }\n    }),\n\n    /**\n     * Helper method to append a promise after the current one\n     *\n     * @param tracker {Object} the tracker object\n     * @param newPromise {qx.Promise} the new promise\n     * @return {qx.Promise} the new promise\n     */\n    __thenPromise: function(tracker, newPromise) {\n      if (tracker.promise) {\n        this.__push(tracker, tracker.promise.then(function() {\n            return newPromise;\n          }));\n      } else {\n        this.__push(tracker, newPromise);\n      }\n      this.__addCatcher(tracker);\n      return tracker.promise;\n    },\n\n    /**\n     * Rejects the tracker, aborting the promise if there is one.  The caller should stop\n     * immediately because if promises are not in use and exception is not thrown.\n     *\n     * @param tracker {Object} the tracker object\n     * @return {qx.Promise?} the last promise or the value returned by the catcher\n     */\n    reject: function(tracker) {\n      if (tracker.rejected) {\n        return qx.event.Utils.ABORT;\n      }\n      tracker.rejected = true;\n\n      if (tracker.promise) {\n        throw new Error(\"Rejecting Event\");\n      }\n      var result = this.__catcher(tracker);\n      return result === undefined ? this.ABORT : result;\n    },\n\n    /**\n     * Helper method that adds a catcher to the tracker\n     *\n     * @param tracker {Object} the tracker object\n     */\n    __addCatcher: function(tracker) {\n      if (tracker.promise && tracker.catch) {\n        if (!tracker.promise[\"qx.event.Utils.hasCatcher\"]) {\n          this.__push(tracker, tracker.promise.catch(this.__catcher.bind(this, tracker)));\n          tracker.promise[\"qx.event.Utils.hasCatcher\"] = true;\n        }\n      }\n    },\n\n    /**\n     * This method is added with `.catch` to every promise created; because this is added\n     * all the way up the promise chain to ensure that it catches everything, this method\n     * supresses multiple invocations (i.e. ignores everything except the first)\n     *\n     * @param tracker {Object} the tracker object\n     */\n    __catcher: function(tracker, err) {\n      var fn = tracker.catch;\n      if (fn) {\n        tracker.catch = null;\n        tracker.rejected = true;\n        return fn(err);\n      }\n      return qx.event.Utils.ABORT;\n    },\n\n    /**\n     * Equivalent to `.catch()`; note that unlike promises, this method must be called *before*\n     * `.then()` so that it is able to handle rejections when promises are not in use; this is\n     * because `Promise.catch` only catches rejections from previous promises, but because promises\n     * are *always* asynchronous the `.catch` goes at the end.  For synchronous, this is nt possible\n     * so `Utils.catch` must go before `Utils.then`\n     *\n     * @param tracker {Object} the tracker object\n     * @param fn {Function} the function to call\n     */\n    \"catch\": function(tracker, fn) {\n      if (tracker.rejected) {\n        fn();\n        return;\n      }\n\n      if (tracker.catchers === undefined) {\n        tracker.catchers = [fn];\n      } else {\n        tracker.catchers.push(fn);\n      }\n\n      if (tracker.catch) {\n        tracker.catch = (function(catch1, catch2) {\n            return function() {\n              catch1();\n              catch2();\n            };\n          })(tracker.catch, fn)\n      } else {\n        tracker.catch = fn;\n      }\n      this.__addCatcher(tracker);\n    },\n\n    /**\n     * Calls a listener, converting propagationStopped into a rejection\n     *\n     * @param tracker {Object} the tracker object\n     * @param listener {Function} the event handler\n     * @param context {Object?} the `this` for the event handler\n     * @param event {Event} the event being fired\n     * @returns {qx.Promise|?} the result of the handler\n     */\n    callListener: function(tracker, listener, context, event) {\n      if (tracker.rejected) {\n        return qx.event.Utils.ABORT;\n      }\n      var tmp = listener.handler.call(context, event);\n      if (event.getPropagationStopped()) {\n        return qx.event.Utils.ABORT;\n      }\n      return tmp;\n    },\n\n    /**\n     * Provides a handy way to iterate over an array which at any point could\n     * become asynchronous\n     *\n     * @param arr {Array} an array to interate over\n     * @param fn {Function?} the function to call, with parameters (item, index)\n     * @param ignoreAbort {Boolean?} whether to ignore the \"ABORT\" return value\n     * @return {qx.Promise|Object?}\n     */\n    series: qx.core.Environment.select(\"qx.promise\", {\n      \"true\": function(arr, fn, ignoreAbort) {\n        var tracker = {};\n        for (var index = 0; index < arr.length; index++) {\n          var result = fn(arr[index], index);\n          if (result instanceof qx.Promise) {\n            for (++index; index < arr.length; index++) {\n              (function(item, index) {\n                result = result.then(function() {\n                  var tmp = fn(item, index);\n                  if (!ignoreAbort && tmp === qx.event.Utils.ABORT) {\n                    throw new Error(\"Rejecting in series()\");\n                  }\n                  return tmp;\n                });\n              })(arr[index], index);\n            }\n            return result;\n          }\n\n          if (!ignoreAbort && result === qx.event.Utils.ABORT) {\n            return this.reject(tracker);\n          }\n        }\n\n        return null;\n      },\n\n      \"false\": function(arr, fn, ignoreAbort) {\n        var tracker = {};\n        for (var index = 0; index < arr.length; index++) {\n          var result = fn(arr[index], index);\n          if (!ignoreAbort && result === qx.event.Utils.ABORT) {\n            return this.reject(tracker);\n          }\n        }\n      }\n    })\n  }\n});\n"
  ]
}