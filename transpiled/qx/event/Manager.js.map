{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/event/Manager.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "Object",
    "implement",
    "core",
    "IDisposable",
    "construct",
    "win",
    "registration",
    "__window",
    "__windowId",
    "ObjectRegistry",
    "toHashCode",
    "__registration",
    "self",
    "method",
    "bom",
    "Event",
    "removeNativeListener",
    "dispose",
    "Environment",
    "get",
    "addNativeListener",
    "event",
    "GlobalError",
    "observeMethod",
    "__listeners",
    "__handlers",
    "__dispatchers",
    "__handlerCache",
    "__clearBlackList",
    "util",
    "DeferredCall",
    "__blacklist",
    "$$blackListCleaner",
    "statics",
    "__lastUnique",
    "getNextUniqueId",
    "__globalEventMonitor",
    "getGlobalEventMonitor",
    "setGlobalEventMonitor",
    "cb",
    "members",
    "__disposeWrapper",
    "getWindow",
    "getWindowId",
    "getHandler",
    "clazz",
    "handler",
    "classname",
    "getDispatcher",
    "dispatcher",
    "getListeners",
    "target",
    "type",
    "capture",
    "targetKey",
    "$$hash",
    "targetMap",
    "entryKey",
    "entryList",
    "concat",
    "getAllListeners",
    "serializeListeners",
    "result",
    "indexOf",
    "entry",
    "substring",
    "charAt",
    "i",
    "l",
    "length",
    "push",
    "context",
    "toggleAttachedEvents",
    "enable",
    "charCodeAt",
    "__registerAtHandler",
    "__unregisterAtHandler",
    "hasListener",
    "log",
    "Logger",
    "trace",
    "Error",
    "importListeners",
    "list",
    "Manager",
    "listKey",
    "item",
    "listener",
    "unique",
    "addListener",
    "msg",
    "Assert",
    "assertObject",
    "assertString",
    "assertFunctionOrAsyncFunction",
    "undefined",
    "assertBoolean",
    "findHandler",
    "isDomNode",
    "isWindow",
    "isObject",
    "isDocument",
    "key",
    "nodeType",
    "tagName",
    "toLowerCase",
    "cache",
    "classes",
    "getHandlers",
    "IEventHandler",
    "instance",
    "supportedTypes",
    "targetCheck",
    "SUPPORTED_TYPES",
    "TARGET_CHECK",
    "found",
    "TARGET_DOMNODE",
    "TARGET_WINDOW",
    "TARGET_OBJECT",
    "TARGET_DOCUMENT",
    "IGNORE_CAN_HANDLE",
    "canHandleEvent",
    "registerEvent",
    "warn",
    "removeListener",
    "assertFunction",
    "lang",
    "Array",
    "removeAt",
    "__addToBlacklist",
    "removeListenerById",
    "id",
    "split",
    "removeAllListeners",
    "forEach",
    "deleteAllListeners",
    "unregisterEvent",
    "dispatchEvent",
    "assertNotUndefined",
    "assertNotNull",
    "assertInstance",
    "preventDefault",
    "getDefaultPrevented",
    "error",
    "ex",
    "getType",
    "getBubbles",
    "Pool",
    "getInstance",
    "poolObject",
    "getTarget",
    "setTarget",
    "getDispatchers",
    "dispatched",
    "tracker",
    "canDispatchEvent",
    "Utils",
    "track",
    "then",
    "removeManager",
    "DisposeUtil",
    "disposeMap",
    "uid",
    "schedule",
    "isBlacklisted"
  ],
  "mappings": "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",
  "file": "Manager.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Fabian Jakobs (fjakobs)\n     * Sebastian Werner (wpbasti)\n\n************************************************************************ */\n\n/**\n * Wrapper for browser DOM event handling for each browser window/frame.\n *\n * @require(qx.bom.Event)\n */\nqx.Class.define(\"qx.event.Manager\",\n{\n  extend : Object,\n  implement: [ qx.core.IDisposable ],\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * Creates a new instance of the event handler.\n   *\n   * @param win {Window} The DOM window this manager handles the events for\n   * @param registration {qx.event.Registration} The event registration to use\n   */\n  construct : function(win, registration)\n  {\n    // Assign window object\n    this.__window = win;\n    this.__windowId = qx.core.ObjectRegistry.toHashCode(win);\n    this.__registration = registration;\n\n    // Register to the page unload event.\n    // Only for iframes and other secondary documents.\n    if (win.qx !== qx)\n    {\n      var self = this;\n      var method = function () {\n        qx.bom.Event.removeNativeListener(win, \"unload\", method);\n        self.dispose();\n      };\n      if (qx.core.Environment.get(\"qx.globalErrorHandling\")) {\n        qx.bom.Event.addNativeListener(win, \"unload\", qx.event.GlobalError.observeMethod(method));\n      } else {\n        qx.bom.Event.addNativeListener(win, \"unload\", method);\n      }\n    }\n\n    // Registry for event listeners\n    this.__listeners = {};\n\n    // The handler and dispatcher instances\n    this.__handlers = {};\n    this.__dispatchers = {};\n\n    this.__handlerCache = {};\n\n    this.__clearBlackList = new qx.util.DeferredCall(function() {\n      this.__blacklist = null;\n    }, this);\n    this.__clearBlackList.$$blackListCleaner = true;\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics :\n  {\n    /** @type {Integer} Last used ID for an event */\n    __lastUnique : 0,\n\n\n    /**\n     * Returns an unique ID which may be used in combination with a target and\n     * a type to identify an event entry.\n     *\n     * @return {String} The next free identifier (auto-incremented)\n     */\n    getNextUniqueId : function() {\n      return (this.__lastUnique++) + \"\";\n    },\n    \n    \n    /** @type {Function} global event monitor, called with parameters of target and event */\n    __globalEventMonitor: null,\n    \n    \n    /**\n     * Returns the global event monitor\n     * \n     * @return {Function?} the global monitor function\n     */\n    getGlobalEventMonitor: function() {\n      return this.__globalEventMonitor;\n    },\n    \n    \n    /**\n     * Sets the global event monitor\n     * \n     * @param cb {Function?} the global monitor function\n     */\n    setGlobalEventMonitor: function(cb) {\n      this.__globalEventMonitor = cb;\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    __registration : null,\n    __listeners : null,\n\n    __dispatchers : null,\n    __disposeWrapper : null,\n\n    __handlers : null,\n    __handlerCache : null,\n    __window : null,\n    __windowId : null,\n\n    __blacklist : null,\n    __clearBlackList : null,\n\n\n    /*\n    ---------------------------------------------------------------------------\n      HELPERS\n    ---------------------------------------------------------------------------\n    */\n\n\n    /**\n     * Get the window instance the event manager is responsible for\n     *\n     * @return {Window} DOM window instance\n     */\n    getWindow : function() {\n      return this.__window;\n    },\n\n\n    /**\n     * Get the hashcode of the manager's window\n     *\n     * @return {String} The window's hashcode\n     */\n    getWindowId : function() {\n      return this.__windowId;\n    },\n\n\n    /**\n     * Returns an instance of the given handler class for this manager(window).\n     *\n     * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}\n     * @return {Object} The instance used by this manager\n     */\n    getHandler : function(clazz)\n    {\n      var handler = this.__handlers[clazz.classname];\n\n      if (handler) {\n        return handler;\n      }\n\n      return this.__handlers[clazz.classname] = new clazz(this);\n    },\n\n\n    /**\n     * Returns an instance of the given dispatcher class for this manager(window).\n     *\n     * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}\n     * @return {Object} The instance used by this manager\n     */\n    getDispatcher : function(clazz)\n    {\n      var dispatcher = this.__dispatchers[clazz.classname];\n\n      if (dispatcher) {\n        return dispatcher;\n      }\n\n      return this.__dispatchers[clazz.classname] = new clazz(this, this.__registration);\n    },\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT LISTENER MANAGEMENT\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Get a copy of all event listeners for the given combination\n     * of target, event type and phase.\n     *\n     * This method is especially useful and for event handlers to\n     * to query the listeners registered in the manager.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Event type\n     * @param capture {Boolean ? false} Whether the listener is for the\n     *       capturing phase of the bubbling phase.\n     * @return {Array | null} Array of registered event handlers. May return\n     *       null when no listener were found.\n     */\n    getListeners : function(target, type, capture)\n    {\n      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        return null;\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      return entryList ? entryList.concat() : null;\n    },\n\n\n    /**\n     * Returns all registered listeners.\n     *\n     * @internal\n     *\n     * @return {Map} All registered listeners. The key is the hash code form an object.\n     */\n    getAllListeners : function() {\n      return this.__listeners;\n    },\n\n\n    /**\n     * Returns a serialized array of all events attached on the given target.\n     *\n     * @param target {Object} Any valid event target\n     * @return {Map[]} Array of maps where everyone contains the keys:\n     *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.\n     */\n    serializeListeners : function(target)\n    {\n      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n      var result = [];\n\n      if (targetMap)\n      {\n        var indexOf, type, capture, entryList, entry;\n        for (var entryKey in targetMap)\n        {\n          indexOf = entryKey.indexOf(\"|\");\n          type = entryKey.substring(0, indexOf);\n          capture = entryKey.charAt(indexOf+1) == \"c\";\n          entryList = targetMap[entryKey];\n\n          for (var i=0, l=entryList.length; i<l; i++)\n          {\n            entry = entryList[i];\n            result.push(\n            {\n              self: entry.context,\n              handler: entry.handler,\n              type: type,\n              capture: capture\n            });\n          }\n        }\n      }\n\n      return result;\n    },\n\n\n    /**\n     * This method might be used to temporally remove all events\n     * directly attached to the given target. This do not work\n     * have any effect on bubbling events normally.\n     *\n     * This is mainly thought for detaching events in IE, before\n     * cloning them. It also removes all leak scenarios\n     * when unloading a document and may be used here as well.\n     *\n     * @internal\n     * @param target {Object} Any valid event target\n     * @param enable {Boolean} Whether to enable or disable the events\n     */\n    toggleAttachedEvents : function(target, enable)\n    {\n      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (targetMap)\n      {\n        var indexOf, type, capture, entryList;\n        for (var entryKey in targetMap)\n        {\n          indexOf = entryKey.indexOf(\"|\");\n          type = entryKey.substring(0, indexOf);\n          capture = entryKey.charCodeAt(indexOf+1) === 99; // checking for character \"c\".\n          entryList = targetMap[entryKey];\n\n          if (enable) {\n            this.__registerAtHandler(target, type, capture);\n          } else {\n            this.__unregisterAtHandler(target, type, capture);\n          }\n        }\n      }\n    },\n\n\n    /**\n     * Check whether there are one or more listeners for an event type\n     * registered at the target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} The event type\n     * @param capture {Boolean ? false} Whether to check for listeners of\n     *         the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the target has event listeners of the given type.\n     */\n    hasListener : function(target, type, capture)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (target == null)\n        {\n          qx.log.Logger.trace(this);\n          throw new Error(\"Invalid object: \" + target);\n        }\n      }\n\n      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        return false;\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      return !!(entryList && entryList.length > 0);\n    },\n\n\n    /**\n     * Imports a list of event listeners at once. This only\n     * works for newly created elements as it replaces\n     * all existing data structures.\n     *\n     * Works with a map of data. Each entry in this map should be a\n     * map again with the keys <code>type</code>, <code>listener</code>,\n     * <code>self</code>, <code>capture</code> and an optional <code>unique</code>.\n     *\n     * The values are identical to the parameters of {@link #addListener}.\n     * For details please have a look there.\n     *\n     * @param target {Object} Any valid event target\n     * @param list {Map} A map where every listener has an unique key.\n     */\n    importListeners : function(target, list)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (target == null)\n        {\n          qx.log.Logger.trace(this);\n          throw new Error(\"Invalid object: \" + target);\n        }\n      }\n\n      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey] = {};\n      var clazz = qx.event.Manager;\n\n      for (var listKey in list)\n      {\n        var item = list[listKey];\n\n        var entryKey = item.type + (item.capture ? \"|capture\" : \"|bubble\");\n        var entryList = targetMap[entryKey];\n\n        if (!entryList)\n        {\n          entryList = targetMap[entryKey] = [];\n\n          // This is the first event listener for this type and target\n          // Inform the event handler about the new event\n          // they perform the event registration at DOM level if needed\n          this.__registerAtHandler(target, item.type, item.capture);\n        }\n\n        // Append listener to list\n        entryList.push(\n        {\n          handler : item.listener,\n          context : item.self,\n          unique : item.unique || (clazz.__lastUnique++) + \"\"\n        });\n      }\n    },\n\n\n    /**\n     * Add an event listener to any valid target. The event listener is passed an\n     * instance of {@link qx.event.type.Event} containing all relevant information\n     * about the event as parameter.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Name of the event e.g. \"click\", \"keydown\", ...\n     * @param listener {Function} Event listener function\n     * @param self {Object ? null} Reference to the 'this' variable inside\n     *         the event listener. When not given, the corresponding dispatcher\n     *         usually falls back to a default, which is the target\n     *         by convention. Note this is not a strict requirement, i.e.\n     *         custom dispatchers can follow a different strategy.\n     * @param capture {Boolean ? false} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event. The default is\n     *         to attach the event handler to the bubbling phase.\n     * @return {String} An opaque ID, which can be used to remove the event listener\n     *         using the {@link #removeListenerById} method.\n     * @throws {Error} if the parameters are wrong\n     */\n    addListener : function(target, type, listener, self, capture)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        var msg = \"Failed to add event listener for type '\"+ type +\"'\" +\n          \" to the target '\" + target.classname + \"': \";\n\n        qx.core.Assert.assertObject(target, msg + \"Invalid Target.\");\n        qx.core.Assert.assertString(type, msg + \"Invalid event type.\");\n        qx.core.Assert.assertFunctionOrAsyncFunction(listener, msg + \"Invalid callback function\");\n\n        if (capture !== undefined) {\n          qx.core.Assert.assertBoolean(capture, \"Invalid capture flag.\");\n        }\n      }\n      \n      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        targetMap = this.__listeners[targetKey] = {};\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      if (!entryList) {\n        entryList = targetMap[entryKey] = [];\n      }\n\n      // This is the first event listener for this type and target\n      // Inform the event handler about the new event\n      // they perform the event registration at DOM level if needed\n      if (entryList.length === 0) {\n        this.__registerAtHandler(target, type, capture);\n      }\n\n      // Append listener to list\n      var unique = (qx.event.Manager.__lastUnique++) + \"\";\n      var entry =\n      {\n        handler : listener,\n        context : self,\n        unique : unique\n      };\n\n      entryList.push(entry);\n\n      return entryKey + \"|\" + unique;\n    },\n\n\n    /**\n     * Get the event handler class matching the given event target and type\n     *\n     * @param target {var} The event target\n     * @param type {String} The event type\n     * @return {qx.event.IEventHandler|null} The best matching event handler or\n     *     <code>null</code>.\n     */\n    findHandler : function(target, type)\n    {\n      var isDomNode=false, isWindow=false, isObject=false, isDocument = false;\n      var key;\n\n      if (target.nodeType === 1)\n      {\n        isDomNode = true;\n        key = \"DOM_\" + target.tagName.toLowerCase() + \"_\" + type;\n      } else if (target.nodeType === 9) {\n        isDocument = true;\n        key = \"DOCUMENT_\" + type;\n      }\n\n      // Please note:\n      // Identical operator does not work in IE (as of version 7) because\n      // document.parentWindow is not identical to window. Crazy stuff.\n      else if (target == this.__window)\n      {\n        isWindow = true;\n        key = \"WIN_\" + type;\n      }\n      else if (target.classname)\n      {\n        isObject = true;\n        key = \"QX_\" + target.classname + \"_\" + type;\n      }\n      else\n      {\n        key = \"UNKNOWN_\" + target + \"_\" + type;\n      }\n\n\n      var cache = this.__handlerCache;\n      if (cache[key]) {\n        return cache[key];\n      }\n\n\n      var classes = this.__registration.getHandlers();\n      var IEventHandler = qx.event.IEventHandler;\n      var clazz, instance, supportedTypes, targetCheck;\n\n      for (var i=0, l=classes.length; i<l; i++)\n      {\n        clazz = classes[i];\n\n        // shortcut type check\n        supportedTypes = clazz.SUPPORTED_TYPES;\n        if (supportedTypes && !supportedTypes[type]) {\n          continue;\n        }\n\n        // shortcut target check\n        targetCheck = clazz.TARGET_CHECK;\n        if (targetCheck)\n        {\n          // use bitwise & to compare for the bitmask!\n          var found = false;\n          if (isDomNode && ((targetCheck & IEventHandler.TARGET_DOMNODE) != 0)) {\n            found = true;\n          } else if (isWindow && ((targetCheck & IEventHandler.TARGET_WINDOW) != 0)) {\n            found = true;\n          } else if (isObject && ((targetCheck & IEventHandler.TARGET_OBJECT) != 0)) {\n            found = true;\n          } else if (isDocument && ((targetCheck & IEventHandler.TARGET_DOCUMENT) != 0)) {\n            found = true;\n          }\n\n          if (!found) {\n            continue;\n          }\n        }\n\n        instance = this.getHandler(classes[i]);\n        if (clazz.IGNORE_CAN_HANDLE || instance.canHandleEvent(target, type))\n        {\n          cache[key] = instance;\n          return instance;\n        }\n      }\n\n      return null;\n    },\n\n\n    /**\n     * This method is called each time an event listener for one of the\n     * supported events is added using {qx.event.Manager#addListener}.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} event type\n     * @param capture {Boolean} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event.\n     * @throws {Error} if there is no handler for the event\n     */\n    __registerAtHandler : function(target, type, capture)\n    {\n      var handler = this.findHandler(target, type);\n\n      if (handler)\n      {\n        handler.registerEvent(target, type, capture);\n        return;\n      }\n\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        qx.log.Logger.warn(\n          this,\n          \"There is no event handler for the event '\" + type +\n          \"' on target '\" + target + \"'!\"\n        );\n      }\n    },\n\n\n    /**\n     * Remove an event listener from an event target.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} Name of the event\n     * @param listener {Function} The pointer to the event listener\n     * @param self {Object ? null} Reference to the 'this' variable inside\n     *         the event listener.\n     * @param capture {Boolean ? false} Whether to remove the event listener of\n     *         the bubbling or of the capturing phase.\n     * @return {Boolean} Whether the event was removed successfully (was existant)\n     * @throws {Error} if the parameters are wrong\n     */\n    removeListener : function(target, type, listener, self, capture)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        var msg = \"Failed to remove event listener for type '\" + type + \"'\" +\n          \" from the target '\" + target.classname + \"': \";\n\n        qx.core.Assert.assertObject(target, msg + \"Invalid Target.\");\n        qx.core.Assert.assertString(type, msg + \"Invalid event type.\");\n        qx.core.Assert.assertFunction(listener, msg + \"Invalid callback function\");\n\n        if (self !== undefined) {\n          qx.core.Assert.assertObject(self, \"Invalid context for callback.\");\n        }\n\n        if (capture !== undefined) {\n          qx.core.Assert.assertBoolean(capture, \"Invalid capture flag.\");\n        }\n      }\n\n      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        return false;\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      if (!entryList) {\n        return false;\n      }\n\n      var entry;\n      for (var i=0, l=entryList.length; i<l; i++)\n      {\n        entry = entryList[i];\n\n        if (entry.handler === listener && entry.context === self)\n        {\n          qx.lang.Array.removeAt(entryList, i);\n          this.__addToBlacklist(entry.unique);\n\n          if (entryList.length == 0) {\n            this.__unregisterAtHandler(target, type, capture);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n\n    /**\n     * Removes an event listener from an event target by an ID returned by\n     * {@link #addListener}.\n     *\n     * @param target {Object} The event target\n     * @param id {String} The ID returned by {@link #addListener}\n     * @return {Boolean} <code>true</code> if the handler was removed\n     */\n    removeListenerById : function(target, id)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        var msg = \"Failed to remove event listener for id '\" + id + \"'\" +\n          \" from the target '\" + target.classname + \"': \";\n\n        qx.core.Assert.assertObject(target, msg + \"Invalid Target.\");\n        qx.core.Assert.assertString(id, msg + \"Invalid id type.\");\n      }\n\n      var split = id.split(\"|\");\n      var type = split[0];\n      var capture = split[1].charCodeAt(0) == 99; // detect leading \"c\"\n      var unique = split[2];\n\n      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n\n      if (!targetMap) {\n        return false;\n      }\n\n      var entryKey = type + (capture ? \"|capture\" : \"|bubble\");\n      var entryList = targetMap[entryKey];\n\n      if (!entryList) {\n        return false;\n      }\n\n      var entry;\n      for (var i=0, l=entryList.length; i<l; i++)\n      {\n        entry = entryList[i];\n\n        if (entry.unique === unique)\n        {\n          qx.lang.Array.removeAt(entryList, i);\n          this.__addToBlacklist(entry.unique);\n\n          if (entryList.length == 0) {\n            this.__unregisterAtHandler(target, type, capture);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n\n    /**\n     * Remove all event listeners, which are attached to the given event target.\n     *\n     * @param target {Object} The event target to remove all event listeners from.\n     * @return {Boolean} Whether the events were existant and were removed successfully.\n     */\n    removeAllListeners : function(target)\n    {\n      var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);\n      var targetMap = this.__listeners[targetKey];\n      if (!targetMap) {\n        return false;\n      }\n\n      // Deregister from event handlers\n      var split, type, capture;\n      for (var entryKey in targetMap)\n      {\n        if (targetMap[entryKey].length > 0)\n        {\n          // This is quite expensive, see bug #1283\n          split = entryKey.split(\"|\");\n\n          targetMap[entryKey].forEach(function(entry) {\n            this.__addToBlacklist(entry.unique);\n          }, this);\n\n          type = split[0];\n          capture = split[1] === \"capture\";\n\n          this.__unregisterAtHandler(target, type, capture);\n        }\n      }\n\n      delete this.__listeners[targetKey];\n      return true;\n    },\n\n\n    /**\n     * Internal helper for deleting the internal listener  data structure for\n     * the given targetKey.\n     *\n     * @param targetKey {String} Hash code for the object to delete its\n     *   listeners.\n     *\n     * @internal\n     */\n    deleteAllListeners : function(targetKey) {\n      delete this.__listeners[targetKey];\n    },\n\n\n    /**\n     * This method is called each time the an event listener for one of the\n     * supported events is removed by using {qx.event.Manager#removeListener}\n     * and no other event listener is listening on this type.\n     *\n     * @param target {Object} Any valid event target\n     * @param type {String} event type\n     * @param capture {Boolean} Whether to attach the event to the\n     *         capturing phase or the bubbling phase of the event.\n     * @throws {Error} if there is no handler for the event\n     */\n    __unregisterAtHandler : function(target, type, capture)\n    {\n      var handler = this.findHandler(target, type);\n\n      if (handler)\n      {\n        handler.unregisterEvent(target, type, capture);\n        return;\n      }\n\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        qx.log.Logger.warn(\n          this,\n          \"There is no event handler for the event '\" + type +\n          \"' on target '\" + target + \"'!\"\n        );\n      }\n    },\n\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n      EVENT DISPATCH\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Dispatches an event object using the qooxdoo event handler system. The\n     * event will only be visible in event listeners attached using\n     * {@link #addListener}. After dispatching the event object will be pooled\n     * for later reuse or disposed.\n     *\n     * @param target {Object} Any valid event target\n     * @param event {qx.event.type.Event} The event object to dispatch. The event\n     *     object must be obtained using {@link qx.event.Registration#createEvent}\n     *     and initialized using {@link qx.event.type.Event#init}.\n     * @return {Boolean|qx.Promise} whether the event default was prevented or not.\n     *     Returns true, when the event was NOT prevented.\n     * @throws {Error} if there is no dispatcher for the event\n     */\n    dispatchEvent : function(target, event)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        var msg = \"Could not dispatch event '\" + event + \"' on target '\" + target.classname +\"': \";\n\n        qx.core.Assert.assertNotUndefined(target, msg + \"Invalid event target.\");\n        qx.core.Assert.assertNotNull(target, msg + \"Invalid event target.\");\n        qx.core.Assert.assertInstance(event, qx.event.type.Event, msg + \"Invalid event object.\");\n      }\n      \n      if (qx.event.Manager.__globalEventMonitor) {\n        try {\n          var preventDefault = event.getDefaultPrevented();\n          qx.event.Manager.__globalEventMonitor(target, event);\n          if (preventDefault != event.getDefaultPrevented()) {\n            qx.log.Logger.error(\"Unexpected change by GlobalEventMonitor, modifications to events: \");\n          }\n        }catch (ex) {\n          qx.log.Logger.error(\"Error in GlobalEventMonitor: \" + ex);\n        }\n      }\n\n      // Preparations\n      var type = event.getType();\n\n      if (!event.getBubbles() && !this.hasListener(target, type))\n      {\n        qx.event.Pool.getInstance().poolObject(event);\n        return true;\n      }\n\n      if (!event.getTarget()) {\n        event.setTarget(target);\n      }\n\n      // Interacion data\n      var classes = this.__registration.getDispatchers();\n      var instance;\n\n      // Loop through the dispatchers\n      var dispatched = false;\n      var tracker = {};\n\n      for (var i=0, l=classes.length; i<l; i++)\n      {\n        instance = this.getDispatcher(classes[i]);\n\n        // Ask if the dispatcher can handle this event\n        if (instance.canDispatchEvent(target, event, type))\n        {\n          qx.event.Utils.track(tracker, instance.dispatchEvent(target, event, type));\n          dispatched = true;\n          break;\n        }\n      }\n\n      if (!dispatched)\n      {\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          qx.log.Logger.error(this, \"No dispatcher can handle event of type \" + type + \" on \" + target);\n        }\n        return true;\n      }\n\n      return qx.event.Utils.then(tracker, function() {\n        // check whether \"preventDefault\" has been called\n        var preventDefault = event.getDefaultPrevented();\n  \n        // Release the event instance to the event pool\n        qx.event.Pool.getInstance().poolObject(event);\n  \n        return !preventDefault;\n      });\n    },\n\n\n    /**\n     * Dispose the event manager\n     */\n    dispose : function()\n    {\n      // Remove from manager list\n      this.__registration.removeManager(this);\n\n      qx.util.DisposeUtil.disposeMap(this, \"__handlers\");\n      qx.util.DisposeUtil.disposeMap(this, \"__dispatchers\");\n\n      // Dispose data fields\n      this.__listeners = this.__window = this.__disposeWrapper = null;\n      this.__registration = this.__handlerCache = null;\n    },\n\n    /**\n     * Add event to blacklist.\n     *\n     * @param uid {number} unique event id\n     */\n    __addToBlacklist : function(uid) {\n      if (this.__blacklist === null) {\n        this.__blacklist = {};\n        this.__clearBlackList.schedule();        \n      }\n      this.__blacklist[uid] = true;\n    },\n\n    /**\n     * Check if the event with the given id has been removed and is therefore blacklisted for event handling\n     *\n     * @param uid {number} unique event id\n     * @return {boolean}\n     */\n    isBlacklisted : function(uid) {\n      return (this.__blacklist !== null && this.__blacklist[uid] === true);\n    }\n  }\n});\n"
  ]
}