{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/util/fsm/State.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "stateName",
    "stateInfo",
    "context",
    "setName",
    "Error",
    "window",
    "setUserData",
    "field",
    "setOnentry",
    "__bindIfFunction",
    "setOnexit",
    "setAutoActionsBeforeOnentry",
    "setAutoActionsAfterOnentry",
    "setAutoActionsBeforeOnexit",
    "setAutoActionsAfterOnexit",
    "setEvents",
    "debug",
    "getEvents",
    "transitions",
    "statics",
    "_commonTransformAutoActions",
    "actionType",
    "value",
    "funcFragment",
    "func",
    "param",
    "objectAndGroupList",
    "f",
    "functionRequest",
    "Array",
    "i",
    "length",
    "params",
    "j",
    "a",
    "g",
    "lang",
    "Function",
    "bind",
    "properties",
    "name",
    "transform",
    "nullable",
    "onentry",
    "init",
    "fsm",
    "event",
    "onexit",
    "autoActionsBeforeOnentry",
    "autoActionsAfterOnentry",
    "autoActionsBeforeOnexit",
    "autoActionsAfterOnexit",
    "events",
    "members",
    "__transformName",
    "__transformOnentry",
    "getUserData",
    "__transformOnexit",
    "__transformEvents",
    "e",
    "action",
    "util",
    "FiniteStateMachine",
    "EventHandling",
    "PREDICATE",
    "BLOCKED",
    "action_e",
    "__transformAutoActionsBeforeOnentry",
    "State",
    "__transformAutoActionsAfterOnentry",
    "__transformAutoActionsBeforeOnexit",
    "__transformAutoActionsAfterOnexit",
    "addTransition",
    "trans",
    "Transition",
    "getName"
  ],
  "mappings": "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",
  "file": "State.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2006, 2007, 2011 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Create a new state which may be added to a finite state machine.\n */\nqx.Class.define(\"qx.util.fsm.State\",\n{\n  extend : qx.core.Object,\n\n  /**\n   * @param stateName {String}\n   *   The name of this state.  This is the name which may be referenced in\n   *   objects of class qx.util.fsm.Transition, when passing of\n   *   the transition's predicate means transition to this state.\n   *\n   * @param stateInfo {Map}\n   *   <pre>\n   *   An object containing any of the following properties:\n   *\n   *     context -\n   *       A context in which all of the following functions should be run.\n   *\n   *     onentry -\n   *       A function which is called upon entry to the state.  Its signature\n   *       is function(fsm, event) and it is saved in the onentry property of\n   *       the state object.  (This function is called after the Transition's\n   *       action function and after the previous state's onexit function.)\n   *\n   *       In the onentry function:\n   *\n   *         fsm -\n   *           The finite state machine object to which this state is attached.\n   *\n   *         event -\n   *           The event that caused the finite state machine to run\n   *\n   *     onexit -\n   *       A function which is called upon exit from the state.  Its signature\n   *       is function(fsm, event) and it is saved in the onexit property of\n   *       the state object.  (This function is called after the Transition's\n   *       action function and before the next state's onentry function.)\n   *\n   *       In the onexit function:\n   *\n   *         fsm -\n   *           The finite state machine object to which this state is attached.\n   *\n   *         event -\n   *           The event that caused the finite state machine to run\n   *\n   *     autoActionsBeforeOnentry -\n   *     autoActionsAfterOnentry -\n   *     autoActionsBeforeOnexit -\n   *     autoActionsAfterOnexit -\n   *       Automatic actions which take place at the time specified by the\n   *       property name.  In all cases, the action takes place immediately\n   *       before or after the specified function.\n   *\n   *       The property value for each of these properties is an object which\n   *       describes some number of functions to invoke on a set of specified\n   *       objects (typically widgets).\n   *\n   *       An example, using autoActionsBeforeOnentry, might look like this:\n   *\n   *       \"autoActionsBeforeOnentry\" :\n   *       {\n   *         // The name of a function.\n   *         \"setEnabled\" :\n   *         [\n   *           {\n   *             // The parameter value, thus \"setEnabled(true);\"\n   *             \"parameters\" : [ true ],\n   *\n   *             // The function would be called on each object:\n   *             //  this.getObject(\"obj1\").setEnabled(true);\n   *             //  this.getObject(\"obj2\").setEnabled(true);\n   *             \"objects\" : [ \"obj1\", \"obj2\" ],\n   *\n   *             // And similarly for each object in each specified group.\n   *             \"groups\"  : [ \"group1\", \"group2\" ]\n   *           }\n   *         ],\n   *\n   *         // The name of another function.\n   *         \"setVisible\" :\n   *         [\n   *           {\n   *             // The parameter value, thus \"setVisible(false);\"\n   *             \"parameters\" : [ false ],\n   *\n   *             // The function would be called on each object and group, as\n   *             // described above.\n   *             \"objects\" : [ \"obj3\", \"obj4\" ],\n   *             \"groups\"  : [ \"group3\", \"group4\" ]\n   *           }\n   *         ]\n   *       };\n   *\n   *     events (required) -\n   *       A description to the finite state machine of how to handle a\n   *       particular event, optionally associated with a specific target\n   *       object on which the event was dispatched.  This should be an object\n   *       containing one property for each event which is either handled or\n   *       blocked.  The property name should be the event name.  The property\n   *       value should be one of:\n   *\n   *         (a) qx.util.fsm.FiniteStateMachine.EventHandling.PREDICATE\n   *\n   *         (b) qx.util.fsm.FiniteStateMachine.EventHandling.BLOCKED\n   *\n   *         (c) a string containing the name of an explicit Transition to use\n   *\n   *         (d) an object where each property name is the Friendly Name of an\n   *             object (meaning that this rule applies if both the event and\n   *             the event's target object's Friendly Name match), and its\n   *             property value is one of (a), (b) or (c), above.\n   *\n   *       This object is saved in the events property of the state object.\n   *\n   *     Additional properties may be provided in stateInfo.  They will not be\n   *     used by the finite state machine, but will be available via\n   *     this.getUserData(\"<propertyName>\") during the state's onentry and\n   *     onexit functions.\n   *   </pre>\n   *\n   * @throws {Error} If the state info is not a valid object.\n   * @throws {Error} If the events object is not provided in new state info.\n   *\n   */\n  construct : function(stateName, stateInfo)\n  {\n    var context;\n\n    // Call our superclass' constructor\n    this.base(arguments);\n\n    // Save the state name\n    this.setName(stateName);\n\n    // Ensure they passed in an object\n    if (typeof (stateInfo) != \"object\") {\n      throw new Error(\"State info must be an object\");\n    }\n\n    // If a context was specified, retrieve it.\n    context = stateInfo.context || window;\n\n    // Save it for future use\n    this.setUserData(\"context\", context);\n\n    // Save data from the stateInfo object\n    for (var field in stateInfo)\n    {\n      // If we find one of our properties, call its setter.\n      switch(field)\n      {\n      case \"onentry\":\n        this.setOnentry(\n          this.__bindIfFunction(stateInfo[field], context));\n        break;\n\n      case \"onexit\":\n        this.setOnexit(\n          this.__bindIfFunction(stateInfo[field], context));\n        break;\n\n      case \"autoActionsBeforeOnentry\":\n        this.setAutoActionsBeforeOnentry(stateInfo[field]);\n        break;\n\n      case \"autoActionsAfterOnentry\":\n        this.setAutoActionsAfterOnentry(stateInfo[field]);\n        break;\n\n      case \"autoActionsBeforeOnexit\":\n        this.setAutoActionsBeforeOnexit(stateInfo[field]);\n        break;\n\n      case \"autoActionsAfterOnexit\":\n        this.setAutoActionsAfterOnexit(stateInfo[field]);\n        break;\n\n      case \"events\":\n        this.setEvents(stateInfo[field]);\n        break;\n\n      case \"context\":\n        // already handled\n        break;\n\n      default:\n        // Anything else is user-provided data for their own use.  Save it.\n        this.setUserData(field, stateInfo[field]);\n\n        // Log it in case it was a typo and they intended a built-in field\n        this.debug(\"State \" + stateName + \": \" +\n                   \"Adding user-provided field to state: \" + field);\n\n        break;\n      }\n    }\n\n    // Check for required but missing properties\n    if (!this.getEvents()) {\n      throw new Error(\"The events object must be provided in new state info\");\n    }\n\n    // Initialize the transition list\n    this.transitions = {};\n  },\n\n\n  statics :\n  {\n    /**\n     * Common function for checking the value provided for\n     * auto actions.\n     *\n     * Auto-action property values passed to us look akin to:\n     *\n     *     <pre class='javascript'>\n     *     {\n     *       // The name of a function.\n     *       \"setEnabled\" :\n     *       [\n     *         {\n     *           // The parameter value(s), thus \"setEnabled(true);\"\n     *           \"parameters\"   : [ true ],\n     *\n     *           // The function would be called on each object:\n     *           //  this.getObject(\"obj1\").setEnabled(true);\n     *           //  this.getObject(\"obj2\").setEnabled(true);\n     *           \"objects\" : [ \"obj1\", \"obj2\" ]\n     *\n     *           // And similarly for each object in each specified group.\n     *           \"groups\"  : [ \"group1\", \"group2\" ],\n     *         }\n     *       ];\n     *\n     *       \"setTextColor\" :\n     *       [\n     *         {\n     *           \"parameters\" : [ \"blue\" ]\n     *           \"groups\"     : [ \"group3\", \"group4\" ],\n     *           \"objects\"    : [ \"obj3\", \"obj4\" ]\n     *         }\n     *       ];\n     *     };\n     *     </pre>\n     *\n     *\n     * @param actionType {String}\n     *   The name of the action being validated (for debug messages)\n     *\n     * @param value {Object}\n     *   The property value which is being validated\n     *\n     * @param context {Object}\n     *   The object to which the created function should be bound.\n     *\n     * @return {Function}\n     *   Function that implements calls to each of the requested automatic\n     *   actions\n     *\n     * @throws {Error} If the value has an invalid type.\n     * @throws {Error} If the function type is not an array.\n     * @throws {Error} If the function request parameter type is not valid.\n     * @throws {Error} If the function parameters are not valid.\n     * @throws {Error} If 'objects' list is invalid.\n     * @throws {Error} If a name in the 'objects' list is not valid.\n     * @throws {Error} If the 'groups' list is not valid.\n     */\n    _commonTransformAutoActions : function(actionType, value, context)\n    {\n      // Validate that we received an object property value\n      if (typeof (value) != \"object\") {\n        throw new Error(\"Invalid \" + actionType + \" value: \" +\n                        typeof (value));\n      }\n\n      // We'll create a function to do the requested actions.  Initialize the\n      // string into which we'll generate the common fragment added to the\n      // function for each object.\n      var funcFragment;\n\n      // Here, we'll keep the function body.  Initialize a try block.\n      var func = \"try\" + \"{\";\n\n      var param;\n      var objectAndGroupList;\n\n      // Retrieve the function request, e.g.\n      // \"enabled\" :\n      for (var f in value)\n      {\n        // Get the function request value object, e.g.\n        // \"setEnabled\" :\n        // [\n        //   {\n        //     \"parameters\"   : [ true ],\n        //     \"objects\" : [ \"obj1\", \"obj2\" ]\n        //     \"groups\"  : [ \"group1\", \"group2\" ],\n        //   }\n        // ];\n        var functionRequest = value[f];\n\n        // The function request value should be an object\n        if (!functionRequest instanceof Array) {\n          throw new Error(\"Invalid function request type: \" +\n                          \"expected array, found \" +\n                          typeof (functionRequest));\n        }\n\n        // For each function request...\n        for (var i=0; i<functionRequest.length; i++)\n        {\n          // Retrieve the object and group list object\n          objectAndGroupList = functionRequest[i];\n\n          // The object and group list should be an object, e.g.\n          // {\n          //   \"parameters\"   : [ true ],\n          //   \"objects\" : [ \"obj1\", \"obj2\" ]\n          //   \"groups\"  : [ \"group1\", \"group2\" ],\n          // }\n          if (typeof (objectAndGroupList) != \"object\") {\n            throw new Error(\"Invalid function request parameter type: \" +\n                            \"expected object, found \" +\n                            typeof (functionRequest[param]));\n          }\n\n          // Retrieve the parameter list\n          var params = objectAndGroupList[\"parameters\"];\n\n          // If it didn't exist, ...\n          if (!params)\n          {\n            // ... use an empty array.\n            params = [];\n          }\n          else\n          {\n            // otherwise, ensure we got an array\n            if (!params instanceof Array) {\n              throw new Error(\"Invalid function parameters: \" +\n                              \"expected array, found \" +\n                              typeof (params));\n            }\n          }\n\n          // Create the function to call on each object.  The object on which\n          // the function is called will be prepended later.\n          funcFragment = f + \"(\";\n\n          // For each parameter...\n          for (var j=0; j<params.length; j++)\n          {\n            // If this isn't the first parameter, add a separator\n            if (j != 0) {\n              funcFragment += \",\";\n            }\n\n            if (typeof (params[j]) == \"function\")\n            {\n              // If the parameter is a function, arrange for it to be called\n              // at run time.\n              funcFragment += \"(\" + params[j] + \")(fsm)\";\n            }\n            else if (typeof (params[j]) == \"string\")\n            {\n              // If the parameter is a string, quote it.\n              funcFragment += '\"' + params[j] + '\"';\n            }\n            else\n            {\n              // Otherwise, just add the parameter's literal value\n              funcFragment += params[j];\n            }\n          }\n\n          // Complete the function call\n          funcFragment += \")\";\n\n          // Get the \"objects\" list, e.g.\n          //   \"objects\" : [ \"obj1\", \"obj2\" ]\n          var a = objectAndGroupList[\"objects\"];\n\n          // Was there an \"objects\" list?\n          if (!a)\n          {\n            // Nope.  Simplify code by creating an empty array.\n            a = [];\n          }\n          else if (!a instanceof Array)\n          {\n            throw new Error(\"Invalid 'objects' list: expected array, got \" +\n                            typeof (a));\n          }\n\n          for (var j=0; j<a.length; j++)\n          {\n            // Ensure we got a string\n            if (typeof (a[j]) != \"string\") {\n              throw new Error(\"Invalid friendly name in 'objects' list: \" +\n                              a[j]);\n            }\n\n            func += \" fsm.getObject('\" + a[j] + \"').\" + funcFragment + \";\";\n          }\n\n          // Get the \"groups\" list, e.g.\n          //   \"groups\" : [ \"group1, \"group2\" ]\n          var g = objectAndGroupList[\"groups\"];\n\n          // Was a \"groups\" list found?\n          if (g)\n          {\n            // Yup.  Ensure it's an array.\n            if (!g instanceof Array)\n            {\n              throw new Error(\"Invalid 'groups' list: expected array, got \" +\n                              typeof (g));\n            }\n\n            for (j=0; j<g.length; j++)\n            {\n              // Arrange to call the function on each object in each group\n              func +=\n                \"  var groupObjects = \" +\n                \"    fsm.getGroupObjects('\" + g[j] + \"');\" +\n                \"  for (var i = 0; i < groupObjects.length; i++)\" +\n                \"  {\" +\n                \"    var objName = groupObjects[i];\" +\n                \"    fsm.getObject(objName).\" + funcFragment + \";\" +\n                \"  }\";\n            }\n          }\n        }\n      }\n\n      // Terminate the try block for function invocations\n      func += \"}\" + \"catch(ex)\" + \"{\" + \"  fsm.debug(ex);\" + \"}\";\n\n      // We've now built the entire body of a function that implements calls\n      // to each of the requested automatic actions.  Create and return the\n      // function, which will become the property value.\n      return qx.lang.Function.bind(new Function(\"fsm\", func), context);\n    }\n  },\n\n\n\n  properties :\n  {\n    /**\n     * The name of this state.  This name may be used as a Transition's\n     * nextState value, or an explicit next state in the 'events' handling\n     * list in a State.\n     */\n    name :\n    {\n      transform : \"__transformName\",\n      nullable : true\n    },\n\n\n    /**\n     * The onentry function for this state.  This is documented in the\n     * constructor, and is typically provided through the constructor's\n     * stateInfo object, but it is also possible (but highly NOT recommended)\n     * to change this dynamically.\n     */\n    onentry :\n    {\n      transform : \"__transformOnentry\",\n      nullable : true,\n      init : function(fsm, event) {}\n    },\n\n\n    /**\n     * The onexit function for this state.  This is documented in the\n     * constructor, and is typically provided through the constructor's\n     * stateInfo object, but it is also possible (but highly NOT recommended)\n     * to change this dynamically.\n     */\n    onexit :\n    {\n      transform : \"__transformOnexit\",\n      nullable : true,\n      init : function(fsm, event) {}\n    },\n\n\n    /**\n     * Automatic actions to take prior to calling the state's onentry function.\n     *\n     * The value passed to setAutoActionsBeforeOnentry() should like something\n     * akin to:\n     *\n     *     <pre class='javascript'>\n     *     \"autoActionsBeforeOnentry\" :\n     *     {\n     *       // The name of a function.  This would become \"setEnabled(\"\n     *       \"enabled\" :\n     *       [\n     *         {\n     *           // The parameter value, thus \"setEnabled(true);\"\n     *           \"parameters\" : [ true ],\n     *\n     *           // The function would be called on each object:\n     *           //  this.getObject(\"obj1\").setEnabled(true);\n     *           //  this.getObject(\"obj2\").setEnabled(true);\n     *           \"objects\" : [ \"obj1\", \"obj2\" ]\n     *\n     *           // And similarly for each object in each specified group.\n     *           \"groups\"  : [ \"group1\", \"group2\" ],\n     *         }\n     *       ];\n     *     };\n     *     </pre>\n     */\n    autoActionsBeforeOnentry :\n    {\n      transform : \"__transformAutoActionsBeforeOnentry\",\n      nullable : true,\n      init : function(fsm, event) {}\n    },\n\n\n    /**\n     * Automatic actions to take after return from the state's onentry\n     * function.\n     *\n     * The value passed to setAutoActionsAfterOnentry() should like something\n     * akin to:\n     *\n     *     <pre class='javascript'>\n     *     \"autoActionsAfterOnentry\" :\n     *     {\n     *       // The name of a function.  This would become \"setEnabled(\"\n     *       \"enabled\" :\n     *       [\n     *         {\n     *           // The parameter value, thus \"setEnabled(true);\"\n     *           \"parameters\" : [ true ],\n     *\n     *           // The function would be called on each object:\n     *           //  this.getObject(\"obj1\").setEnabled(true);\n     *           //  this.getObject(\"obj2\").setEnabled(true);\n     *           \"objects\" : [ \"obj1\", \"obj2\" ]\n     *\n     *           // And similarly for each object in each specified group.\n     *           \"groups\"  : [ \"group1\", \"group2\" ],\n     *         }\n     *       ];\n     *     };\n     *     </pre>\n     */\n    autoActionsAfterOnentry :\n    {\n      transform : \"__transformAutoActionsAfterOnentry\",\n      nullable : true,\n      init : function(fsm, event) {}\n    },\n\n\n    /**\n     * Automatic actions to take prior to calling the state's onexit function.\n     *\n     * The value passed to setAutoActionsBeforeOnexit() should like something\n     * akin to:\n     *\n     *     <pre class='javascript'>\n     *     \"autoActionsBeforeOnexit\" :\n     *     {\n     *       // The name of a function.  This would become \"setEnabled(\"\n     *       \"enabled\" :\n     *       [\n     *         {\n     *           // The parameter value, thus \"setEnabled(true);\"\n     *           \"parameters\" : [ true ],\n     *\n     *           // The function would be called on each object:\n     *           //  this.getObject(\"obj1\").setEnabled(true);\n     *           //  this.getObject(\"obj2\").setEnabled(true);\n     *           \"objects\" : [ \"obj1\", \"obj2\" ]\n     *\n     *           // And similarly for each object in each specified group.\n     *           \"groups\"  : [ \"group1\", \"group2\" ],\n     *         }\n     *       ];\n     *     };\n     *     </pre>\n     */\n    autoActionsBeforeOnexit :\n    {\n      transform : \"__transformAutoActionsBeforeOnexit\",\n      nullable : true,\n      init : function(fsm, event) {}\n    },\n\n\n    /**\n     * Automatic actions to take after returning from the state's onexit\n     * function.\n     *\n     * The value passed to setAutoActionsAfterOnexit() should like something\n     * akin to:\n     *\n     *     <pre class='javascript'>\n     *     \"autoActionsBeforeOnexit\" :\n     *     {\n     *       // The name of a function.  This would become \"setEnabled(\"\n     *       \"enabled\" :\n     *       [\n     *         {\n     *           // The parameter value, thus \"setEnabled(true);\"\n     *           \"parameters\" : [ true ],\n     *\n     *           // The function would be called on each object:\n     *           //  this.getObject(\"obj1\").setEnabled(true);\n     *           //  this.getObject(\"obj2\").setEnabled(true);\n     *           \"objects\" : [ \"obj1\", \"obj2\" ]\n     *\n     *           // And similarly for each object in each specified group.\n     *           \"groups\"  : [ \"group1\", \"group2\" ],\n     *         }\n     *       ];\n     *     };\n     *     </pre>\n     */\n    autoActionsAfterOnexit :\n    {\n      transform : \"__transformAutoActionsAfterOnexit\",\n      nullable : true,\n      init : function(fsm, event) {}\n    },\n\n\n    /**\n     * The object representing handled and blocked events for this state.\n     * This is documented in the constructor, and is typically provided\n     * through the constructor's stateInfo object, but it is also possible\n     * (but highly NOT recommended) to change this dynamically.\n     */\n    events :\n    {\n      transform : \"__transformEvents\",\n      nullable : true\n    }\n  },\n\n\n  members :\n  {\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Value passed to setter\n     * @return {var} the final value\n     * @throws {Error} when an invalid value is detected\n     */\n    __transformName : function(value)\n    {\n      // Ensure that we got a valid state name\n      if (typeof (value) != \"string\" || value.length < 1)\n      {\n        throw new Error(\"Invalid state name\");\n      }\n\n      return value;\n    },\n\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {var} the final value\n     * @throws {Error} when an invalid value is detected\n     */\n    __transformOnentry : function(value)\n    {\n      // Validate the onentry function\n      switch(typeof (value))\n      {\n        case \"undefined\":\n          // None provided.  Convert it to a null function\n          return function(fsm, event) {};\n\n        case \"function\":\n          // We're cool.  No changes required\n          return qx.lang.Function.bind(value, this.getUserData(\"context\"));\n\n        default:\n          throw new Error(\"Invalid onentry type: \" + typeof (value));\n      }\n    },\n\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {var} the final value\n     * @throws {Error} when an invalid value is detected\n     */\n    __transformOnexit : function(value)\n    {\n      // Validate the onexit function\n      switch(typeof (value))\n      {\n        case \"undefined\":\n          // None provided.  Convert it to a null function\n          return function(fsm, event) {};\n\n        case \"function\":\n          // We're cool.  No changes required\n        return qx.lang.Function.bind(value, this.getUserData(\"context\"));\n\n        default:\n          throw new Error(\"Invalid onexit type: \" + typeof (value));\n      }\n    },\n\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {var} the final value\n     * @throws {Error} when an invalid value is detected\n     */\n    __transformEvents : function(value)\n    {\n      // Validate that events is an object\n      if (typeof (value) != \"object\") {\n        throw new Error(\"events must be an object\");\n      }\n\n      // Confirm that each property is a valid value\n      // The property value should be one of:\n      //\n      // (a) qx.util.fsm.FiniteStateMachine.EventHandling.PREDICATE\n      //\n      // (b) qx.util.fsm.FiniteStateMachine.EventHandling.BLOCKED\n      //\n      // (c) a string containing the name of an explicit Transition to use\n      //\n      // (d) an object where each property name is the Friendly Name of an\n      //     object (meaning that this rule applies if both the event and\n      //     the event's target object's Friendly Name match), and its\n      //     property value is one of (a), (b) or (c), above.\n      for (var e in value)\n      {\n        var action = value[e];\n\n        if (typeof (action) == \"number\" &&\n            action != qx.util.fsm.FiniteStateMachine.EventHandling.PREDICATE &&\n            action != qx.util.fsm.FiniteStateMachine.EventHandling.BLOCKED)\n        {\n          throw new Error(\"Invalid numeric value in events object: \" +\n                          e + \": \" + action);\n        }\n        else if (typeof (action) == \"object\")\n        {\n          for (var action_e in action)\n          {\n            if (typeof (action[action_e]) == \"number\" &&\n                action[action_e] !=\n                  qx.util.fsm.FiniteStateMachine.EventHandling.PREDICATE &&\n                action[action_e] !=\n                  qx.util.fsm.FiniteStateMachine.EventHandling.BLOCKED)\n            {\n              throw new Error(\"Invalid numeric value in events object \" +\n                              \"(\" + e + \"): \" +\n                              action_e + \": \" +\n                              action[action_e]);\n            }\n            else if (typeof (action[action_e]) != \"string\" &&\n                     typeof (action[action_e]) != \"number\")\n            {\n              throw new Error(\"Invalid value in events object \" +\n                              \"(\" + e + \"): \" +\n                              action_e + \": \" + action[action_e]);\n            }\n          }\n        }\n        else if (typeof (action) != \"string\" && typeof (action) != \"number\")\n        {\n          throw new Error(\"Invalid value in events object: \" +\n                          e + \": \" + value[e]);\n        }\n      }\n\n      // We're cool.  No changes required.\n      return value;\n    },\n\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {var} the final value\n     */\n    __transformAutoActionsBeforeOnentry : function(value)\n    {\n      return qx.util.fsm.State._commonTransformAutoActions(\n        \"autoActionsBeforeOnentry\",\n        value,\n        this.getUserData(\"context\"));\n    },\n\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {var} the final value\n     */\n    __transformAutoActionsAfterOnentry : function(value)\n    {\n      return qx.util.fsm.State._commonTransformAutoActions(\n        \"autoActionsAfterOnentry\",\n        value,\n        this.getUserData(\"context\"));\n    },\n\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {var} the final value\n     */\n    __transformAutoActionsBeforeOnexit : function(value)\n    {\n      return qx.util.fsm.State._commonTransformAutoActions(\n        \"autoActionsBeforeOnexit\",\n        value,\n        this.getUserData(\"context\"));\n    },\n\n\n    /**\n     * Internal transform method\n     *\n     * @param value {var} Current value\n     * @return {var} the final value\n     */\n    __transformAutoActionsAfterOnexit : function(value)\n    {\n      return qx.util.fsm.State._commonTransformAutoActions(\n        \"autoActionsAfterOnexit\",\n        value,\n        this.getUserData(\"context\"));\n    },\n\n\n    /**\n     * If given a function, bind it to a specified context.\n     *\n     * @param f {Function|var}\n     *   The (possibly) function to be bound to the specified context.\n     *\n     * @param context {Object}\n     *   The context to bind the function to.\n     *\n     * @return {Function}\n     *   If f was a function, the return value is f wrapped such that it will\n     *   be called in the specified context. Otherwise, f is returned\n     *   unaltered.\n     */\n    __bindIfFunction : function(f, context)\n    {\n      // Is the first parameter a function?\n      if (typeof(f) == \"function\")\n      {\n        // Yup. Bind it to the specified context.\n        f = qx.lang.Function.bind(f, context);\n      }\n\n      return f;\n    },\n\n\n    /**\n     * Add a transition to a state\n     *\n     *\n     * @param trans {qx.util.fsm.Transition}\n     *   An object of class qx.util.fsm.Transition representing a transition\n     *   which is to be a part of this state.\n     *\n     */\n    addTransition : function(trans)\n    {\n      // Ensure that we got valid transition info\n      if (!trans instanceof qx.util.fsm.Transition) {\n        throw new Error(\"Invalid transition: not an instance of \" +\n                        \"qx.util.fsm.Transition\");\n      }\n\n      // Add the new transition object to the state\n      this.transitions[trans.getName()] = trans;\n    }\n  }\n});\n"
  ]
}