{
  "className": "qx.util.TimerManager",
  "packageName": "qx.util",
  "name": "TimerManager",
  "superClass": "qx.core.Object",
  "interfaces": [],
  "mixins": [],
  "functionName": null,
  "clazz": {
    "location": {
      "start": {
        "line": 73,
        "column": 0
      },
      "end": {
        "line": 305,
        "column": 3
      }
    },
    "jsdoc": {
      "@description": [
        {
          "name": "@description",
          "body": "***********************************************************************\n\nqooxdoo - the new era of web development\n\nhttp://qooxdoo.org\n\nCopyright:\n2008 Derrell Lipman\n\nLicense:\nMIT: https://opensource.org/licenses/MIT\nSee the LICENSE file in the project's top-level directory for details.\n\nAuthors:\nDerrell Lipman (derrell)\n\n***********************************************************************"
        },
        {
          "name": "@description",
          "body": "Timer manipulation for handling multiple timed callbacks with the use of\nonly a single native timer object.\n\nUse of these timers is via the methods start() and stop().  Examples:\n<pre class='javascript'>\nvar timer = qx.util.TimerManager.getInstance();\n\n// Start a 5-second recurrent timer.\n// Note that the first expiration is after 3 seconds\n// (last parameter is 3000) but each subsequent expiration is\n// at 5 second intervals.\ntimer.start(function(userData, timerId)\n{\nthis.debug(\"Recurrent 5-second timer: \" + timerId);\n},\n5000,\nthis,\nnull,\n3000);\n\n// Start a 1-second one-shot timer\ntimer.start(function(userData, timerId)\n{\nthis.debug(\"One-shot 1-second timer: \" + timerId);\n},\n0,\nthis,\nnull,\n1000);\n\n// Start a 2-second recurrent timer that stops itself after\n// three iterations\ntimer.start(function(userData, timerId)\n{\nthis.debug(\"Recurrent 2-second timer with limit 3:\" +\ntimerId);\nif (++userData.count == 3)\n{\nthis.debug(\"Stopping recurrent 2-second timer\");\ntimer.stop(timerId);\n}\n},\n2000,\nthis,\n{ count : 0 });\n\n// Start an immediate one-shot timer\ntimer.start(function(userData, timerId)\n{\nthis.debug(\"Immediate one-shot timer: \" + timerId);\n});\n</pre>"
        }
      ]
    }
  },
  "type": "class",
  "isAbstract": false,
  "isStatic": false,
  "isSingleton": false,
  "statics": {
    "__timerQueue": {
      "location": {
        "start": {
          "line": 81,
          "column": 4
        },
        "end": {
          "line": 81,
          "column": 21
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Time-ordered queue of timers"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    },
    "__timerData": {
      "location": {
        "start": {
          "line": 84,
          "column": 4
        },
        "end": {
          "line": 84,
          "column": 21
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Saved data for each timer"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    },
    "__timerId": {
      "location": {
        "start": {
          "line": 87,
          "column": 4
        },
        "end": {
          "line": 87,
          "column": 20
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Next timer id value is determined by incrementing this"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    }
  },
  "members": {
    "__timerListenerActive": {
      "location": {
        "start": {
          "line": 93,
          "column": 4
        },
        "end": {
          "line": 93,
          "column": 33
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Whether we're currently listening on the interval timer event"
          }
        ]
      },
      "type": "variable",
      "access": "private"
    },
    "start": {
      "location": {
        "start": {
          "line": 131,
          "column": 4
        },
        "end": {
          "line": 157,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Start a new timer"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "callback {Function}\nFunction to be called upon expiration of the timer.  The function is\npassed these parameters:\n<dl>\n<dt>userData</dt>\n<dd>The user data provided to the start() method</dd>\n<dt>timerId</dt>\n<dd>The timer id, as was returned by the start() method</dd>\n</dl>",
            "paramName": "callback",
            "description": "\nFunction to be called upon expiration of the timer.  The function is\npassed these parameters:\n<dl>\n<dt>userData</dt>\n<dd>The user data provided to the start() method</dd>\n<dt>timerId</dt>\n<dd>The timer id, as was returned by the start() method</dd>\n</dl>",
            "type": "qx.util.Function"
          },
          {
            "name": "@param",
            "body": "recurTime {Integer|null}\nIf null, the timer will not recur.  Once the callback function\nreturns the first time, the timer will be removed from the timer\nqueue.  If non-null, upon return from the callback function, the\ntimer will be reset to this number of milliseconds.",
            "paramName": "recurTime",
            "description": "\nIf null, the timer will not recur.  Once the callback function\nreturns the first time, the timer will be removed from the timer\nqueue.  If non-null, upon return from the callback function, the\ntimer will be reset to this number of milliseconds.",
            "type": [
              "Integer",
              "null"
            ]
          },
          {
            "name": "@param",
            "body": "context {qx.core.Object|null}\nContext (this) the callback function is called with.  If not\nprovided, this Timer singleton object is used.",
            "paramName": "context",
            "description": "\nContext (this) the callback function is called with.  If not\nprovided, this Timer singleton object is used.",
            "type": [
              "qx.core.Object",
              "null"
            ]
          },
          {
            "name": "@param",
            "body": "userData {var}\nData which is passed to the callback function upon timer expiry",
            "paramName": "userData",
            "description": "\nData which is passed to the callback function upon timer expiry",
            "type": "var"
          },
          {
            "name": "@param",
            "body": "initialTime {Integer|null}\nMilliseconds before the callback function is called the very first\ntime.  If not specified and recurTime is specified, then recurTime\nwill be used as initialTime; otherwise initialTime will default\nto zero.",
            "paramName": "initialTime",
            "description": "\nMilliseconds before the callback function is called the very first\ntime.  If not specified and recurTime is specified, then recurTime\nwill be used as initialTime; otherwise initialTime will default\nto zero.",
            "type": [
              "Integer",
              "null"
            ]
          }
        ],
        "@return": [
          {
            "name": "@return",
            "body": "{Integer}\nThe timer id of this unique timer.  It may be provided to the stop()\nmethod to cancel a timer before expiration.",
            "type": "Integer",
            "description": "\nThe timer id of this unique timer.  It may be provided to the stop()\nmethod to cancel a timer before expiration."
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "stop": {
      "location": {
        "start": {
          "line": 165,
          "column": 4
        },
        "end": {
          "line": 195,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Stop a running timer"
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "timerId {Integer}\nA timer id previously returned by start()",
            "paramName": "timerId",
            "description": "\nA timer id previously returned by start()",
            "type": "Integer"
          }
        ]
      },
      "type": "function",
      "access": "public"
    },
    "__insertNewTimer": {
      "location": {
        "start": {
          "line": 207,
          "column": 4
        },
        "end": {
          "line": 246,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Insert a timer on the time-ordered list of active timers."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "body": "expireAt {Integer}\nMilliseconds from now when this timer should expire",
            "paramName": "expireAt",
            "description": "\nMilliseconds from now when this timer should expire",
            "type": "Integer"
          },
          {
            "name": "@param",
            "body": "timerId {Integer}\nId of the timer to be time-ordered",
            "paramName": "timerId",
            "description": "\nId of the timer to be time-ordered",
            "type": "Integer"
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "__processQueue": {
      "location": {
        "start": {
          "line": 255,
          "column": 4
        },
        "end": {
          "line": 303,
          "column": 5
        }
      },
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Process the queue of timers.  Call the registered callback function for\nany timer which has expired.  If the timer is marked as recurrent, the\ntimer is restarted with the recurrent timeout following completion of\nthe callback function."
          }
        ]
      },
      "type": "function",
      "access": "private"
    },
    "getQxOwner": {
      "type": "function",
      "name": "getQxOwner",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.Object",
      "property": "get",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Gets the (computed) value of the property <code>qxOwner</code>.\n\nFor further details take a look at the property definition: {@link #qxOwner}."
          }
        ],
        "@return": [
          {
            "name": "@return",
            "type": "qx.core.Object",
            "desc": "Returns the value for qxOwner"
          }
        ]
      }
    },
    "setQxOwner": {
      "type": "function",
      "name": "setQxOwner",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.Object",
      "property": "set",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Sets the user value of the property <code>qxOwner</code>.\n\nFor further details take a look at the property definition: {@link #qxOwner}."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "type": "qx.core.Object",
            "paramName": "value",
            "desc": "Value for qxOwner"
          }
        ]
      }
    },
    "resetQxOwner": {
      "type": "function",
      "name": "resetQxOwner",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.Object",
      "property": "reset"
    },
    "getQxObjectId": {
      "type": "function",
      "name": "getQxObjectId",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.Object",
      "property": "get",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Gets the (computed) value of the property <code>qxObjectId</code>.\n\nFor further details take a look at the property definition: {@link #qxObjectId}."
          }
        ],
        "@return": [
          {
            "name": "@return",
            "desc": "Returns the value for qxObjectId"
          }
        ]
      }
    },
    "setQxObjectId": {
      "type": "function",
      "name": "setQxObjectId",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.Object",
      "property": "set",
      "jsdoc": {
        "@description": [
          {
            "name": "@description",
            "body": "Sets the user value of the property <code>qxObjectId</code>.\n\nFor further details take a look at the property definition: {@link #qxObjectId}."
          }
        ],
        "@param": [
          {
            "name": "@param",
            "paramName": "value",
            "desc": "Value for qxObjectId"
          }
        ]
      }
    },
    "resetQxObjectId": {
      "type": "function",
      "name": "resetQxObjectId",
      "abstract": false,
      "mixin": false,
      "inherited": true,
      "access": "public",
      "overriddenFrom": "qx.core.Object",
      "property": "reset"
    }
  },
  "descendants": []
}