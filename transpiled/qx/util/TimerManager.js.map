{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/util/TimerManager.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "type",
    "statics",
    "__timerQueue",
    "__timerData",
    "__timerId",
    "members",
    "__timerListenerActive",
    "start",
    "callback",
    "recurTime",
    "context",
    "userData",
    "initialTime",
    "expireAt",
    "Date",
    "getTime",
    "__insertNewTimer",
    "stop",
    "timerId",
    "timerQueue",
    "length",
    "i",
    "splice",
    "event",
    "Idle",
    "getInstance",
    "removeListener",
    "__processQueue",
    "timerData",
    "push",
    "addListener",
    "timeNow",
    "expiredTimerId",
    "shift",
    "expiredTimerData",
    "call",
    "now",
    "util",
    "TimerManager"
  ],
  "mappings": "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",
  "file": "TimerManager.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2008 Derrell Lipman\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Derrell Lipman (derrell)\n\n************************************************************************ */\n\n/**\n * Timer manipulation for handling multiple timed callbacks with the use of\n * only a single native timer object.\n *\n * Use of these timers is via the methods start() and stop().  Examples:\n * <pre class='javascript'>\n * var timer = qx.util.TimerManager.getInstance();\n *\n * // Start a 5-second recurrent timer.\n * // Note that the first expiration is after 3 seconds\n * // (last parameter is 3000) but each subsequent expiration is\n * // at 5 second intervals.\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Recurrent 5-second timer: \" + timerId);\n *             },\n *             5000,\n *             this,\n *             null,\n *             3000);\n *\n * // Start a 1-second one-shot timer\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"One-shot 1-second timer: \" + timerId);\n *             },\n *             0,\n *             this,\n *             null,\n *             1000);\n *\n * // Start a 2-second recurrent timer that stops itself after\n * // three iterations\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Recurrent 2-second timer with limit 3:\" +\n *                          timerId);\n *               if (++userData.count == 3)\n *               {\n *                 this.debug(\"Stopping recurrent 2-second timer\");\n *                 timer.stop(timerId);\n *               }\n *             },\n *             2000,\n *             this,\n *             { count : 0 });\n *\n * // Start an immediate one-shot timer\n * timer.start(function(userData, timerId)\n *             {\n *               this.debug(\"Immediate one-shot timer: \" + timerId);\n *             });\n * </pre>\n */\nqx.Class.define(\"qx.util.TimerManager\",\n{\n  extend : qx.core.Object,\n  type   : \"singleton\",\n\n  statics :\n  {\n    /** Time-ordered queue of timers */\n    __timerQueue : [],\n\n    /** Saved data for each timer */\n    __timerData  : {},\n\n    /** Next timer id value is determined by incrementing this */\n    __timerId    : 0\n  },\n\n  members :\n  {\n    /** Whether we're currently listening on the interval timer event */\n    __timerListenerActive : false,\n\n    /**\n     * Start a new timer\n     *\n     * @param callback {Function}\n     *   Function to be called upon expiration of the timer.  The function is\n     *   passed these parameters:\n     *   <dl>\n     *     <dt>userData</dt>\n     *       <dd>The user data provided to the start() method</dd>\n     *     <dt>timerId</dt>\n     *       <dd>The timer id, as was returned by the start() method</dd>\n     *   </dl>\n     *\n     * @param recurTime {Integer|null}\n     *   If null, the timer will not recur.  Once the callback function\n     *   returns the first time, the timer will be removed from the timer\n     *   queue.  If non-null, upon return from the callback function, the\n     *   timer will be reset to this number of milliseconds.\n     *\n     * @param context {qx.core.Object|null}\n     *   Context (this) the callback function is called with.  If not\n     *   provided, this Timer singleton object is used.\n     *\n     * @param userData {var}\n     *   Data which is passed to the callback function upon timer expiry\n     *\n     * @param initialTime {Integer|null}\n     *   Milliseconds before the callback function is called the very first\n     *   time.  If not specified and recurTime is specified, then recurTime\n     *   will be used as initialTime; otherwise initialTime will default\n     *   to zero.\n     *\n     * @return {Integer}\n     *   The timer id of this unique timer.  It may be provided to the stop()\n     *   method to cancel a timer before expiration.\n     */\n    start : function(callback, recurTime, context, userData, initialTime)\n    {\n      // Get the expiration time for this timer\n      if (typeof initialTime != \"number\")\n      {\n        initialTime = recurTime || 0;\n      }\n\n      var expireAt = (new Date()).getTime() + initialTime;\n\n      // Save the callback, user data, and requested recurrency time as well\n      // as the current expiry time\n      this.self(arguments).__timerData[++this.self(arguments).__timerId] =\n        {\n          callback  : callback,\n          userData  : userData || null,\n          expireAt  : expireAt,\n          recurTime : recurTime,\n          context   : context || this\n        };\n\n      // Insert this new timer on the time-ordered timer queue\n      this.__insertNewTimer(expireAt, this.self(arguments).__timerId);\n\n      // Give 'em the timer id\n      return this.self(arguments).__timerId;\n    },\n\n    /**\n     * Stop a running timer\n     *\n     * @param timerId {Integer}\n     *   A timer id previously returned by start()\n     */\n    stop : function(timerId)\n    {\n      // Find this timer id in the time-ordered list\n      var timerQueue = this.self(arguments).__timerQueue;\n      var length = timerQueue.length;\n      for (var i = 0; i < length; i++)\n      {\n        // Is this the one we're looking for?\n        if (timerQueue[i] == timerId)\n        {\n          // Yup.  Remove it.\n          timerQueue.splice(i, 1);\n\n          // We found it so no need to continue looping through the queue\n          break;\n        }\n      }\n\n      // Ensure it's gone from the timer data map as well\n      delete this.self(arguments).__timerData[timerId];\n\n      // If there are no more timers pending...\n      if (timerQueue.length == 0 && this.__timerListenerActive)\n      {\n        // ... then stop listening for the periodic timer\n        qx.event.Idle.getInstance().removeListener(\"interval\",\n                                                   this.__processQueue,\n                                                   this);\n        this.__timerListenerActive = false;\n      }\n    },\n\n    /**\n     * Insert a timer on the time-ordered list of active timers.\n     *\n     * @param expireAt {Integer}\n     *   Milliseconds from now when this timer should expire\n     *\n     * @param timerId {Integer}\n     *   Id of the timer to be time-ordered\n     *\n     */\n    __insertNewTimer : function(expireAt, timerId)\n    {\n      // The timer queue is time-ordered so that processing timers need not\n      // search the queue; rather, it can simply look at the first element\n      // and if not yet ready to fire, be done.  Search the queue for the\n      // appropriate place to insert this timer.\n      var timerQueue = this.self(arguments).__timerQueue;\n      var timerData = this.self(arguments).__timerData;\n      var length = timerQueue.length;\n      for (var i = 0; i < length; i++)\n      {\n        // Have we reached a later time?\n        if (timerData[timerQueue[i]].expireAt > expireAt)\n        {\n          // Yup.  Insert our new timer id before this element.\n          timerQueue.splice(i, 0, timerId);\n\n          // No need to loop through the queue further\n          break;\n        }\n      }\n\n      // Did we find someplace in the middle of the queue for it?\n      if (timerQueue.length == length)\n      {\n        // Nope.  Insert it at the end.\n        timerQueue.push(timerId);\n      }\n\n      // If this is the first element on the queue...\n      if (! this.__timerListenerActive)\n      {\n        // ... then start listening for the periodic timer.\n        qx.event.Idle.getInstance().addListener(\"interval\",\n                                                this.__processQueue,\n                                                this);\n        this.__timerListenerActive = true;\n      }\n\n    },\n\n    /**\n     * Process the queue of timers.  Call the registered callback function for\n     * any timer which has expired.  If the timer is marked as recurrent, the\n     * timer is restarted with the recurrent timeout following completion of\n     * the callback function.\n     *\n     */\n    __processQueue : function()\n    {\n      // Get the current time\n      var timeNow = (new Date()).getTime();\n\n      // While there are timer elements that need processing...\n      var timerQueue = this.self(arguments).__timerQueue;\n      var timerData = this.self(arguments).__timerData;\n\n      // Is it time to process the first timer element yet?\n      while (timerQueue.length > 0 &&\n             timerData[timerQueue[0]].expireAt <= timeNow)\n      {\n        // Yup.  Do it.  First, remove element from the queue.\n        var expiredTimerId = timerQueue.shift();\n\n        // Call the handler function for this timer\n        var expiredTimerData = timerData[expiredTimerId];\n        expiredTimerData.callback.call(expiredTimerData.context,\n                                       expiredTimerData.userData,\n                                       expiredTimerId);\n\n        // If this is a recurrent timer which wasn't stopped by the callback...\n        if (expiredTimerData.recurTime && timerData[expiredTimerId])\n        {\n          // ... then restart it.\n          var now = (new Date()).getTime();\n          expiredTimerData.expireAt = now + expiredTimerData.recurTime;\n\n          // Insert this timer back on the time-ordered timer queue\n          this.__insertNewTimer(expiredTimerData.expireAt, expiredTimerId);\n        }\n        else\n        {\n          // If it's not a recurrent timer, we can purge its data too.\n          delete timerData[expiredTimerId];\n        }\n      }\n\n      // If there are no more timers pending...\n      if (timerQueue.length == 0 && this.__timerListenerActive)\n      {\n        // ... then stop listening for the periodic timer\n        qx.event.Idle.getInstance().removeListener(\"interval\",\n                                                   this.__processQueue,\n                                                   this);\n        this.__timerListenerActive = false;\n      }\n    }\n  }\n});\n"
  ]
}