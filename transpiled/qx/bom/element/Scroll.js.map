{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/bom/element/Scroll.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "statics",
    "__scrollbarSize",
    "getScrollbarWidth",
    "Style",
    "bom",
    "element",
    "getStyleSize",
    "el",
    "propertyName",
    "parseInt",
    "get",
    "getBorderRight",
    "getBorderLeft",
    "getInsetRight",
    "core",
    "Environment",
    "select",
    "clientWidth",
    "Math",
    "max",
    "offsetWidth",
    "clientLeft",
    "ov",
    "sbv",
    "getScrollBarSizeRight",
    "t",
    "document",
    "createElement",
    "s",
    "style",
    "height",
    "width",
    "overflow",
    "body",
    "appendChild",
    "c",
    "removeChild",
    "intoViewX",
    "stop",
    "align",
    "parent",
    "parentNode",
    "doc",
    "dom",
    "Node",
    "getDocument",
    "parentLocation",
    "parentLeft",
    "parentRight",
    "parentOuterWidth",
    "parentClientWidth",
    "parentScrollWidth",
    "parentLeftBorder",
    "parentRightBorder",
    "parentScrollBarWidth",
    "elementLocation",
    "elementLeft",
    "elementRight",
    "elementWidth",
    "leftOffset",
    "rightOffset",
    "scrollDiff",
    "alignLeft",
    "alignRight",
    "scrollWidth",
    "scrollLeft",
    "Viewport",
    "getWidth",
    "Location",
    "left",
    "right",
    "event",
    "Registration",
    "fireNonBubblingEvent",
    "intoViewY",
    "parentTop",
    "parentBottom",
    "parentOuterHeight",
    "parentClientHeight",
    "parentScrollHeight",
    "parentTopBorder",
    "parentBottomBorder",
    "parentScrollBarHeight",
    "elementTop",
    "elementBottom",
    "elementHeight",
    "topOffset",
    "bottomOffset",
    "alignTop",
    "alignBottom",
    "scrollHeight",
    "clientHeight",
    "scrollTop",
    "getHeight",
    "top",
    "bottom",
    "offsetHeight",
    "intoView",
    "alignX",
    "alignY",
    "Scroll"
  ],
  "mappings": "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",
  "file": "Scroll.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n\n************************************************************************ */\n\n\n/**\n * Contains methods to control and query the element's scroll properties\n */\nqx.Class.define(\"qx.bom.element.Scroll\",\n{\n  /*\n  *****************************************************************************\n     STATICS\n  *****************************************************************************\n  */\n\n  statics :\n  {\n    /** @type {Integer} The typical native scrollbar size in the environment */\n    __scrollbarSize : null,\n\n    /**\n     * Get the typical native scrollbar size in the environment\n     *\n     * @return {Number} The native scrollbar size\n     */\n    getScrollbarWidth : function()\n    {\n      if (this.__scrollbarSize !== null) {\n        return this.__scrollbarSize;\n      }\n\n      var Style = qx.bom.element.Style;\n\n      var getStyleSize = function(el, propertyName) {\n        return parseInt(Style.get(el, propertyName), 10) || 0;\n      };\n\n      var getBorderRight = function(el)\n      {\n        return (\n          Style.get(el, \"borderRightStyle\") == \"none\"\n          ? 0\n          : getStyleSize(el, \"borderRightWidth\")\n        );\n      };\n\n      var getBorderLeft = function(el)\n      {\n        return (\n          Style.get(el, \"borderLeftStyle\") == \"none\"\n          ? 0\n          : getStyleSize(el, \"borderLeftWidth\")\n        );\n      };\n\n      var getInsetRight = qx.core.Environment.select(\"engine.name\",\n      {\n        \"mshtml\" : function(el)\n        {\n          if (\n            Style.get(el, \"overflowY\") == \"hidden\" ||\n            el.clientWidth == 0\n          ) {\n            return getBorderRight(el);\n          }\n\n          return Math.max(0, el.offsetWidth - el.clientLeft - el.clientWidth);\n        },\n\n          \"default\" : function(el)\n        {\n          // Alternative method if clientWidth is unavailable\n          // clientWidth == 0 could mean both: unavailable or really 0\n          if (el.clientWidth == 0)\n          {\n            var ov = Style.get(el, \"overflow\");\n            var sbv = (\n              ov == \"scroll\" ||\n              ov == \"-moz-scrollbars-vertical\" ? 16 : 0\n            );\n            return Math.max(0, getBorderRight(el) + sbv);\n          }\n\n          return Math.max(\n            0,\n            (el.offsetWidth - el.clientWidth - getBorderLeft(el))\n          );\n        }\n      });\n\n      var getScrollBarSizeRight = function(el) {\n        return getInsetRight(el) - getBorderRight(el);\n      };\n\n      var t = document.createElement(\"div\");\n      var s = t.style;\n\n      s.height = s.width = \"100px\";\n      s.overflow = \"scroll\";\n\n      document.body.appendChild(t);\n      var c = getScrollBarSizeRight(t);\n      this.__scrollbarSize = c;\n      document.body.removeChild(t);\n\n      return this.__scrollbarSize;\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      SCROLL INTO VIEW\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * The method scrolls the element into view (x-axis only).\n     *\n     * @param element {Element} DOM element to scroll into view\n     * @param stop {Element?null} Any parent element which functions as\n     *   outermost element to scroll. Default is the HTML document.\n     * @param align {String?null} Alignment of the element. Allowed values:\n     *   <code>left</code> or <code>right</code>. Could also be null.\n     *   Without a given alignment the method tries to scroll the widget\n     *   with the minimum effort needed.\n     */\n    intoViewX : function(element, stop, align)\n    {\n      var parent = element.parentNode;\n      var doc = qx.dom.Node.getDocument(element);\n      var body = doc.body;\n\n      var parentLocation, parentLeft, parentRight;\n      var parentOuterWidth, parentClientWidth, parentScrollWidth;\n      var parentLeftBorder, parentRightBorder, parentScrollBarWidth;\n      var elementLocation, elementLeft, elementRight, elementWidth;\n      var leftOffset, rightOffset, scrollDiff;\n\n      var alignLeft = align === \"left\";\n      var alignRight = align === \"right\";\n\n      // Correcting stop position\n      stop = stop ? stop.parentNode : doc;\n\n      // Go up the parent chain\n      while (parent && parent != stop)\n      {\n        // \"overflow\" is always visible for both: document.body and document.documentElement\n        if (parent.scrollWidth > parent.clientWidth && (parent === body || qx.bom.element.Style.get(parent, \"overflowY\") != \"visible\"))\n        {\n          // Calculate parent data\n          // Special handling for body element\n          if (parent === body)\n          {\n            parentLeft = parent.scrollLeft;\n            parentRight = parentLeft + qx.bom.Viewport.getWidth();\n            parentOuterWidth = qx.bom.Viewport.getWidth();\n            parentClientWidth = parent.clientWidth;\n            parentScrollWidth = parent.scrollWidth;\n            parentLeftBorder = 0;\n            parentRightBorder = 0;\n            parentScrollBarWidth = 0;\n          }\n          else\n          {\n            parentLocation = qx.bom.element.Location.get(parent);\n            parentLeft = parentLocation.left;\n            parentRight = parentLocation.right;\n            parentOuterWidth = parent.offsetWidth;\n            parentClientWidth = parent.clientWidth;\n            parentScrollWidth = parent.scrollWidth;\n            parentLeftBorder = parseInt(qx.bom.element.Style.get(parent, \"borderLeftWidth\"), 10) || 0;\n            parentRightBorder = parseInt(qx.bom.element.Style.get(parent, \"borderRightWidth\"), 10) || 0;\n            parentScrollBarWidth = parentOuterWidth - parentClientWidth - parentLeftBorder - parentRightBorder;\n          }\n\n          // Calculate element data\n          elementLocation = qx.bom.element.Location.get(element);\n          elementLeft = elementLocation.left;\n          elementRight = elementLocation.right;\n          elementWidth = element.offsetWidth;\n\n          // Relative position from each other\n          leftOffset = elementLeft - parentLeft - parentLeftBorder;\n          rightOffset = elementRight - parentRight + parentRightBorder;\n\n          // Scroll position rearrangement\n          scrollDiff = 0;\n\n          // be sure that element is on left edge\n          if (alignLeft)\n          {\n            scrollDiff = leftOffset;\n          }\n\n          // be sure that element is on right edge\n          else if (alignRight)\n          {\n            scrollDiff = rightOffset + parentScrollBarWidth;\n          }\n\n          // element must go down\n          // * when current left offset is smaller than 0\n          // * when width is bigger than the inner width of the parent\n          else if (leftOffset < 0 || elementWidth > parentClientWidth)\n          {\n            scrollDiff = leftOffset;\n          }\n\n          // element must go up\n          // * when current right offset is bigger than 0\n          else if (rightOffset > 0)\n          {\n            scrollDiff = rightOffset + parentScrollBarWidth;\n          }\n\n          parent.scrollLeft += scrollDiff;\n\n          // Browsers that follow the CSSOM View Spec fire the \"scroll\"\n          // event asynchronously. See #intoViewY for more details.\n          qx.event.Registration.fireNonBubblingEvent(parent, \"scroll\");\n        }\n\n        if (parent === body) {\n          break;\n        }\n\n        parent = parent.parentNode;\n      }\n    },\n\n\n    /**\n     * The method scrolls the element into view (y-axis only).\n     *\n     * @param element {Element} DOM element to scroll into view\n     * @param stop {Element?null} Any parent element which functions as\n     *   outermost element to scroll. Default is the HTML document.\n     * @param align {String?null} Alignment of the element. Allowed values:\n     *   <code>top</code> or <code>bottom</code>. Could also be null.\n     *   Without a given alignment the method tries to scroll the widget\n     *   with the minimum effort needed.\n     */\n    intoViewY : function(element, stop, align)\n    {\n      var parent = element.parentNode;\n      var doc = qx.dom.Node.getDocument(element);\n      var body = doc.body;\n\n      var parentLocation, parentTop, parentBottom;\n      var parentOuterHeight, parentClientHeight, parentScrollHeight;\n      var parentTopBorder, parentBottomBorder, parentScrollBarHeight;\n      var elementLocation, elementTop, elementBottom, elementHeight;\n      var topOffset, bottomOffset, scrollDiff;\n\n      var alignTop = align === \"top\";\n      var alignBottom = align === \"bottom\";\n\n      // Correcting stop position\n      stop = stop ? stop.parentNode : doc;\n\n      // Go up the parent chain\n      while (parent && parent != stop)\n      {\n        // \"overflow\" is always visible for both: document.body and document.documentElement\n        if (parent.scrollHeight > parent.clientHeight && (parent === body || qx.bom.element.Style.get(parent, \"overflowY\") != \"visible\"))\n        {\n          // Calculate parent data\n          // Special handling for body element\n          if (parent === body)\n          {\n            parentTop = parent.scrollTop;\n            parentBottom = parentTop + qx.bom.Viewport.getHeight();\n            parentOuterHeight = qx.bom.Viewport.getHeight();\n            parentClientHeight = parent.clientHeight;\n            parentScrollHeight = parent.scrollHeight;\n            parentTopBorder = 0;\n            parentBottomBorder = 0;\n            parentScrollBarHeight = 0;\n          }\n          else\n          {\n            parentLocation = qx.bom.element.Location.get(parent);\n            parentTop = parentLocation.top;\n            parentBottom = parentLocation.bottom;\n            parentOuterHeight = parent.offsetHeight;\n            parentClientHeight = parent.clientHeight;\n            parentScrollHeight = parent.scrollHeight;\n            parentTopBorder = parseInt(qx.bom.element.Style.get(parent, \"borderTopWidth\"), 10) || 0;\n            parentBottomBorder = parseInt(qx.bom.element.Style.get(parent, \"borderBottomWidth\"), 10) || 0;\n            parentScrollBarHeight = parentOuterHeight - parentClientHeight - parentTopBorder - parentBottomBorder;\n          }\n\n          // Calculate element data\n          elementLocation = qx.bom.element.Location.get(element);\n          elementTop = elementLocation.top;\n          elementBottom = elementLocation.bottom;\n          elementHeight = element.offsetHeight;\n\n          // Relative position from each other\n          topOffset = elementTop - parentTop - parentTopBorder;\n          bottomOffset = elementBottom - parentBottom + parentBottomBorder;\n\n          // Scroll position rearrangement\n          scrollDiff = 0;\n\n          // be sure that element is on top edge\n          if (alignTop)\n          {\n            scrollDiff = topOffset;\n          }\n\n          // be sure that element is on bottom edge\n          else if (alignBottom)\n          {\n            scrollDiff = bottomOffset + parentScrollBarHeight;\n          }\n\n          // element must go down\n          // * when current top offset is smaller than 0\n          // * when height is bigger than the inner height of the parent\n          else if (topOffset < 0 || elementHeight > parentClientHeight)\n          {\n            scrollDiff = topOffset;\n          }\n\n          // element must go up\n          // * when current bottom offset is bigger than 0\n          else if (bottomOffset > 0)\n          {\n            scrollDiff = bottomOffset + parentScrollBarHeight;\n          }\n\n          parent.scrollTop += scrollDiff;\n\n          // Browsers that follow the CSSOM View Spec fire the \"scroll\"\n          // event asynchronously.\n          //\n          // The widget layer expects the \"scroll\" event to be fired before\n          // the \"appear\" event. Fire non-bubbling \"scroll\" in all browsers,\n          // since a duplicate \"scroll\" should not cause any issues and it\n          // is hard to track which version of the browser engine started to\n          // follow the CSSOM Spec. Fixes [BUG #4570].\n          qx.event.Registration.fireNonBubblingEvent(parent, \"scroll\");\n        }\n\n        if (parent === body) {\n          break;\n        }\n\n        parent = parent.parentNode;\n      }\n    },\n\n\n    /**\n     * The method scrolls the element into view.\n     *\n     * @param element {Element} DOM element to scroll into view\n     * @param stop {Element?null} Any parent element which functions as\n     *   outermost element to scroll. Default is the HTML document.\n     * @param alignX {String} Alignment of the element. Allowed values:\n     *   <code>left</code> or <code>right</code>. Could also be undefined.\n     *   Without a given alignment the method tries to scroll the widget\n     *   with the minimum effort needed.\n     * @param alignY {String} Alignment of the element. Allowed values:\n     *   <code>top</code> or <code>bottom</code>. Could also be undefined.\n     *   Without a given alignment the method tries to scroll the widget\n     *   with the minimum effort needed.\n     */\n    intoView : function(element, stop, alignX, alignY)\n    {\n      this.intoViewX(element, stop, alignX);\n      this.intoViewY(element, stop, alignY);\n    }\n  }\n});\n"
  ]
}