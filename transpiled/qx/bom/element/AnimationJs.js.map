{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/bom/element/AnimationJs.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__maxStepTime",
    "__units",
    "__transitionKeys",
    "animate",
    "el",
    "desc",
    "duration",
    "_animate",
    "animateReverse",
    "reverse",
    "$$animation",
    "lang",
    "Object",
    "clone",
    "undefined",
    "keyFrames",
    "keys",
    "__getOrderedKeys",
    "stepTime",
    "__getStepTime",
    "steps",
    "parseInt",
    "__normalizeKeyFrames",
    "delta",
    "__calculateDelta",
    "timing",
    "handle",
    "bom",
    "element",
    "AnimationHandle",
    "jsAnimation",
    "i",
    "initValues",
    "repeatSteps",
    "__applyRepeat",
    "repeat",
    "delay",
    "self",
    "delayId",
    "window",
    "setTimeout",
    "play",
    "units",
    "percent",
    "name",
    "prefixed",
    "Style",
    "getPropertyName",
    "prefixedName",
    "getCssName",
    "item",
    "__getUnit",
    "frame",
    "style",
    "getComputedStyle",
    "indexOf",
    "__normalizeKeyFrameTransforms",
    "transforms",
    "transformStyle",
    "Transform",
    "getCss",
    "split",
    "length",
    "replace",
    "Array",
    "keyIndex",
    "last",
    "next",
    "stepsToNext",
    "Math",
    "floor",
    "calculationIndex",
    "nItem",
    "isArray",
    "j",
    "x",
    "__getNextValue",
    "charAt",
    "value0",
    "util",
    "ColorUtil",
    "cssStringToRgb",
    "value1",
    "stepValue",
    "range",
    "timingX",
    "AnimationFrame",
    "calculateTiming",
    "rgbToHexString",
    "isNaN",
    "parseFloat",
    "substring",
    "nextItem",
    "lastItem",
    "emit",
    "id",
    "setInterval",
    "values",
    "get",
    "String",
    "camelCase",
    "AnimationJs",
    "__applyStyles",
    "alternate",
    "stop",
    "animationId",
    "pause",
    "clearInterval",
    "clearTimeout",
    "keep",
    "stopped",
    "ended",
    "Number",
    "MAX_VALUE",
    "styles",
    "key",
    "set",
    "minDiff",
    "min",
    "round",
    "sort",
    "a",
    "b"
  ],
  "mappings": "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",
  "file": "AnimationJs.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2012 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Martin Wittemann (wittemann)\n\n************************************************************************ */\n\n/**\n * This class offers the same API as the CSS3 animation layer in\n * {@link qx.bom.element.AnimationCss} but uses JavaScript to fake the behavior.\n *\n * {@link qx.bom.element.Animation} is the class, which takes care of the\n * feature detection for CSS animations and decides which implementation\n * (CSS or JavaScript) should be used. Most likely, this implementation should\n * be the one to use.\n *\n * @ignore(qx.bom.element.Style.*)\n * @use(qx.bom.element.AnimationJs#play)\n */\nqx.Bootstrap.define(\"qx.bom.element.AnimationJs\",\n{\n  statics :\n  {\n    /**\n     * The maximal time a frame should take.\n     */\n    __maxStepTime : 30,\n\n    /**\n     * The supported CSS units.\n     */\n    __units : [\"%\", \"in\", \"cm\", \"mm\", \"em\", \"ex\", \"pt\", \"pc\", \"px\"],\n\n    /** The used keys for transforms. */\n    __transitionKeys : {\n      \"scale\": true,\n      \"rotate\" : true,\n      \"skew\" : true,\n      \"translate\" : true\n    },\n\n    /**\n     * This is the main function to start the animation. For further details,\n     * take a look at the documentation of the wrapper\n     * {@link qx.bom.element.Animation}.\n     * @param el {Element} The element to animate.\n     * @param desc {Map} Animation description.\n     * @param duration {Integer?} The duration of the animation which will\n     *   override the duration given in the description.\n     * @return {qx.bom.element.AnimationHandle} The handle.\n     */\n    animate : function(el, desc, duration) {\n      return this._animate(el, desc, duration, false);\n    },\n\n\n    /**\n     * This is the main function to start the animation in reversed mode.\n     * For further details, take a look at the documentation of the wrapper\n     * {@link qx.bom.element.Animation}.\n     * @param el {Element} The element to animate.\n     * @param desc {Map} Animation description.\n     * @param duration {Integer?} The duration of the animation which will\n     *   override the duration given in the description.\n     * @return {qx.bom.element.AnimationHandle} The handle.\n     */\n    animateReverse : function(el, desc, duration) {\n      return this._animate(el, desc, duration, true);\n    },\n\n\n    /**\n     * Helper to start the animation, either in reversed order or not.\n     *\n     * @param el {Element} The element to animate.\n     * @param desc {Map} Animation description.\n     * @param duration {Integer?} The duration of the animation which will\n     *   override the duration given in the description.\n     * @param reverse {Boolean} <code>true</code>, if the animation should be\n     *   reversed.\n     * @return {qx.bom.element.AnimationHandle} The handle.\n     */\n    _animate : function(el, desc, duration, reverse) {\n      // stop if an animation is already running\n      if (el.$$animation) {\n        return el.$$animation;\n      }\n\n      desc = qx.lang.Object.clone(desc, true);\n\n      if (duration == undefined) {\n        duration = desc.duration;\n      }\n\n      var keyFrames = desc.keyFrames;\n\n      var keys = this.__getOrderedKeys(keyFrames);\n      var stepTime = this.__getStepTime(duration, keys);\n      var steps = parseInt(duration / stepTime, 10);\n\n      this.__normalizeKeyFrames(keyFrames, el);\n\n      var delta = this.__calculateDelta(steps, stepTime, keys, keyFrames, duration, desc.timing);\n      var handle = new qx.bom.element.AnimationHandle();\n      handle.jsAnimation = true;\n\n      if (reverse) {\n        delta.reverse();\n        handle.reverse = true;\n      }\n\n      handle.desc = desc;\n      handle.el = el;\n      handle.delta = delta;\n      handle.stepTime = stepTime;\n      handle.steps = steps;\n      el.$$animation = handle;\n\n      handle.i = 0;\n      handle.initValues = {};\n      handle.repeatSteps = this.__applyRepeat(steps, desc.repeat);\n\n      var delay = desc.delay || 0;\n      var self = this;\n      handle.delayId = window.setTimeout(function() {\n        handle.delayId = null;\n        self.play(handle);\n      }, delay);\n      return handle;\n    },\n\n\n    /**\n     * Try to normalize the keyFrames by adding the default / set values of the\n     * element.\n     * @param keyFrames {Map} The map of key frames.\n     * @param el {Element} The element to animate.\n     */\n    __normalizeKeyFrames : function(keyFrames, el) {\n      // collect all possible keys and its units\n      var units = {};\n      for (var percent in keyFrames) {\n        for (var name in keyFrames[percent]) {\n          // prefixed key calculation\n          var prefixed = qx.bom.Style.getPropertyName(name);\n          if (prefixed && prefixed != name) {\n            var prefixedName = qx.bom.Style.getCssName(prefixed);\n            keyFrames[percent][prefixedName] = keyFrames[percent][name];\n            delete keyFrames[percent][name];\n            name = prefixedName;\n          }\n          // check for the available units\n          if (units[name] == undefined) {\n            var item = keyFrames[percent][name];\n            if (typeof item == \"string\") {\n              units[name] = this.__getUnit(item);\n            } else {\n              units[name] = \"\";\n            }\n          }\n        };\n      }\n      // add all missing keys\n      for (var percent in keyFrames) {\n        var frame = keyFrames[percent];\n        for (var name in units) {\n          if (frame[name] == undefined) {\n            if (name in el.style) {\n              // get the computed style if possible\n              if (window.getComputedStyle) {\n                frame[name] = getComputedStyle(el, null)[name];\n              } else {\n                frame[name] = el.style[name];\n              }\n            } else {\n              frame[name] = el[name];\n            }\n            // if its a unit we know, set 0 as fallback\n            if (frame[name] === \"\" && this.__units.indexOf(units[name]) != -1) {\n              frame[name] = \"0\" + units[name];\n            }\n          }\n        };\n      };\n    },\n\n\n    /**\n     * Checks for transform keys and returns a cloned frame\n     * with the right transform style set.\n     * @param frame {Map} A single key frame of the description.\n     * @return {Map} A modified clone of the given frame.\n     */\n    __normalizeKeyFrameTransforms : function(frame) {\n      frame = qx.lang.Object.clone(frame);\n      var transforms;\n      for (var name in frame) {\n        if (name in this.__transitionKeys) {\n          if (!transforms) {\n            transforms = {};\n          }\n          transforms[name] = frame[name];\n          delete frame[name];\n        }\n      };\n      if (transforms) {\n        var transformStyle = qx.bom.element.Transform.getCss(transforms).split(\":\");\n        if (transformStyle.length > 1) {\n          frame[transformStyle[0]] = transformStyle[1].replace(\";\", \"\");\n        }\n      }\n      return frame;\n    },\n\n\n    /**\n     * Precalculation of the delta which will be applied during the animation.\n     * The whole deltas will be calculated prior to the animation and stored\n     * in a single array. This method takes care of that calculation.\n     *\n     * @param steps {Integer} The amount of steps to take to the end of the\n     *   animation.\n     * @param stepTime {Integer} The amount of milliseconds each step takes.\n     * @param keys {Array} Ordered list of keys in the key frames map.\n     * @param keyFrames {Map} The map of key frames.\n     * @param duration {Integer} Time in milliseconds the animation should take.\n     * @param timing {String} The given timing function.\n     * @return {Array} An array containing the animation deltas.\n     */\n    __calculateDelta : function(steps, stepTime, keys, keyFrames, duration, timing) {\n      var delta = new Array(steps);\n\n      var keyIndex = 1;\n      delta[0] = this.__normalizeKeyFrameTransforms(keyFrames[0]);\n      var last = keyFrames[0];\n      var next = keyFrames[keys[keyIndex]];\n      var stepsToNext = Math.floor(keys[keyIndex] / (stepTime / duration * 100));\n\n      var calculationIndex = 1; // is used as counter for the timing calculation\n      // for every step\n      for (var i=1; i < delta.length; i++) {\n        // switch key frames if we crossed a percent border\n        if (i * stepTime / duration * 100 > keys[keyIndex]) {\n          last = next;\n          keyIndex++;\n          next = keyFrames[keys[keyIndex]];\n          stepsToNext = Math.floor(keys[keyIndex] / (stepTime / duration * 100)) - stepsToNext;\n          calculationIndex = 1;\n        }\n\n        delta[i] = {};\n\n        var transforms;\n        // for every property\n        for (var name in next) {\n          var nItem = next[name] + \"\";\n\n          // transform values\n          if (name in this.__transitionKeys) {\n            if (!transforms) {\n              transforms = {};\n            }\n\n            if (qx.Bootstrap.isArray(last[name])) {\n              if (!qx.Bootstrap.isArray(next[name])) {\n                next[name] = [next[name]];\n              }\n              transforms[name] = [];\n              for (var j = 0; j < next[name].length; j++) {\n                var item = next[name][j] + \"\";\n                var x = calculationIndex / stepsToNext;\n                transforms[name][j] = this.__getNextValue(item, last[name], timing, x);\n              }\n            } else {\n              var x = calculationIndex / stepsToNext;\n              transforms[name] = this.__getNextValue(nItem, last[name], timing, x);\n            }\n\n          // color values\n          } else if (nItem.charAt(0) == \"#\") {\n            // get the two values from the frames as RGB arrays\n            var value0 = qx.util.ColorUtil.cssStringToRgb(last[name]);\n            var value1 = qx.util.ColorUtil.cssStringToRgb(nItem);\n            var stepValue = [];\n            // calculate every color channel\n            for (var j=0; j < value0.length; j++) {\n              var range = value0[j] - value1[j];\n              var x = calculationIndex / stepsToNext;\n              var timingX = qx.bom.AnimationFrame.calculateTiming(timing, x);\n              stepValue[j] = parseInt(value0[j] - range * timingX, 10);\n            }\n\n            delta[i][name] = qx.util.ColorUtil.rgbToHexString(stepValue);\n\n          } else if (!isNaN(parseFloat(nItem))) {\n            var x = calculationIndex / stepsToNext;\n            delta[i][name] = this.__getNextValue(nItem, last[name], timing, x);\n          } else {\n            delta[i][name] = last[name] + \"\";\n          }\n        }\n        // save all transformations in the delta values\n        if (transforms) {\n          var transformStyle = qx.bom.element.Transform.getCss(transforms).split(\":\");\n          if (transformStyle.length > 1) {\n            delta[i][transformStyle[0]] = transformStyle[1].replace(\";\", \"\");\n          }\n        }\n\n        calculationIndex++;\n      }\n      // make sure the last key frame is right\n      delta[delta.length -1] = this.__normalizeKeyFrameTransforms(keyFrames[100]);\n\n      return delta;\n    },\n\n\n    /**\n     * Ties to parse out the unit of the given value.\n     *\n     * @param item {String} A CSS value including its unit.\n     * @return {String} The unit of the given value.\n     */\n    __getUnit : function(item) {\n      return item.substring((parseFloat(item) + \"\").length, item.length);\n    },\n\n\n    /**\n     * Returns the next value based on the given arguments.\n     *\n     * @param nextItem {String} The CSS value of the next frame\n     * @param lastItem {String} The CSS value of the last frame\n     * @param timing {String} The timing used for the calculation\n     * @param x {Number} The x position of the animation on the time axis\n     * @return {String} The calculated value including its unit.\n     */\n    __getNextValue : function(nextItem, lastItem, timing, x) {\n      var range = parseFloat(nextItem) - parseFloat(lastItem);\n      return (parseFloat(lastItem) + range * qx.bom.AnimationFrame.calculateTiming(timing, x)) + this.__getUnit(nextItem);\n    },\n\n\n    /**\n     * Internal helper for the {@link qx.bom.element.AnimationHandle} to play\n     * the animation.\n     * @internal\n     * @param handle {qx.bom.element.AnimationHandle} The hand which\n     *   represents the animation.\n     * @return {qx.bom.element.AnimationHandle} The handle for chaining.\n     */\n    play : function(handle) {\n      handle.emit(\"start\", handle.el);\n      var id = window.setInterval(function() {\n        handle.repeatSteps--;\n        var values = handle.delta[handle.i % handle.steps];\n        // save the init values\n        if (handle.i === 0) {\n          for (var name in values) {\n            if (handle.initValues[name] === undefined) {\n              // animate element property\n              if (handle.el[name] !== undefined) {\n                handle.initValues[name] = handle.el[name];\n              }\n              // animate CSS property\n              else if (qx.bom.element.Style) {\n                handle.initValues[name] = qx.bom.element.Style.get(\n                  handle.el, qx.lang.String.camelCase(name)\n                );\n              } else {\n                handle.initValues[name] = handle.el.style[qx.lang.String.camelCase(name)];\n              }\n            }\n          }\n        }\n        qx.bom.element.AnimationJs.__applyStyles(handle.el, values);\n\n        handle.i++;\n        // iteration condition\n        if (handle.i % handle.steps == 0) {\n          handle.emit(\"iteration\", handle.el);\n          if (handle.desc.alternate) {\n            handle.delta.reverse();\n          }\n        }\n        // end condition\n        if (handle.repeatSteps < 0) {\n          qx.bom.element.AnimationJs.stop(handle);\n        }\n      }, handle.stepTime);\n\n      handle.animationId = id;\n\n      return handle;\n    },\n\n\n    /**\n     * Internal helper for the {@link qx.bom.element.AnimationHandle} to pause\n     * the animation.\n     * @internal\n     * @param handle {qx.bom.element.AnimationHandle} The hand which\n     *   represents the animation.\n     * @return {qx.bom.element.AnimationHandle} The handle for chaining.\n     */\n\n    pause : function(handle) {\n      // stop the interval\n      window.clearInterval(handle.animationId);\n      handle.animationId = null;\n\n      return handle;\n    },\n\n\n    /**\n     * Internal helper for the {@link qx.bom.element.AnimationHandle} to stop\n     * the animation.\n     * @internal\n     * @param handle {qx.bom.element.AnimationHandle} The hand which\n     *   represents the animation.\n     * @return {qx.bom.element.AnimationHandle} The handle for chaining.\n     */\n    stop : function(handle) {\n      var desc = handle.desc;\n      var el = handle.el;\n      var initValues = handle.initValues;\n      if (handle.animationId) {\n        window.clearInterval(handle.animationId);\n      }\n\n      // clear the delay if the animation has not been started\n      if (handle.delayId) {\n        window.clearTimeout(handle.delayId);\n      }\n\n      // check if animation is already stopped\n      if (el == undefined) {\n        return handle;\n      }\n\n      // if we should keep a frame\n      var keep = desc.keep;\n      if (keep != undefined && !handle.stopped) {\n        if (handle.reverse || (desc.alternate && desc.repeat && desc.repeat % 2 == 0)) {\n          keep = 100 - keep;\n        }\n        this.__applyStyles(el, desc.keyFrames[keep]);\n      } else {\n        this.__applyStyles(el, initValues);\n      }\n\n      el.$$animation = null;\n      handle.el = null;\n      handle.ended = true;\n      handle.animationId = null;\n\n      handle.emit(\"end\", el);\n\n      return handle;\n    },\n\n\n    /**\n     * Takes care of the repeat key of the description.\n     * @param steps {Integer} The number of steps one iteration would take.\n     * @param repeat {Integer|String} It can be either a number how often the\n     * animation should be repeated or the string 'infinite'.\n     * @return {Integer} The number of steps to animate.\n     */\n    __applyRepeat : function(steps, repeat) {\n      if (repeat == undefined) {\n        return steps;\n      }\n      if (repeat == \"infinite\") {\n        return Number.MAX_VALUE;\n      }\n      return steps * repeat;\n    },\n\n\n    /**\n     * Central method to apply css styles and element properties.\n     * @param el {Element} The DOM element to apply the styles.\n     * @param styles {Map} A map containing styles and values.\n     */\n    __applyStyles : function(el, styles) {\n      for (var key in styles) {\n        // ignore undefined values (might be a bad detection)\n        if (styles[key] === undefined) {\n          continue;\n        }\n\n        // apply element property value - only if a CSS property\n        // is *not* available\n        if (typeof el.style[key] === \"undefined\" && key in el) {\n          el[key] = styles[key];\n          continue;\n        }\n\n        var name = qx.bom.Style.getPropertyName(key) || key;\n        if (qx.bom.element.Style) {\n          qx.bom.element.Style.set(el, name, styles[key]);\n        } else {\n          el.style[name] = styles[key];\n        }\n      }\n    },\n\n\n    /**\n     * Dynamic calculation of the steps time considering a max step time.\n     * @param duration {Number} The duration of the animation.\n     * @param keys {Array} An array containing the ordered set of key frame keys.\n     * @return {Integer} The best suited step time.\n     */\n    __getStepTime : function(duration, keys) {\n      // get min difference\n      var minDiff = 100;\n      for (var i=0; i < keys.length - 1; i++) {\n        minDiff = Math.min(minDiff, keys[i+1] - keys[i]);\n      };\n\n      var stepTime = duration * minDiff / 100;\n      while (stepTime > this.__maxStepTime) {\n        stepTime = stepTime / 2;\n      }\n      return Math.round(stepTime);\n    },\n\n\n    /**\n     * Helper which returns the ordered keys of the key frame map.\n     * @param keyFrames {Map} The map of key frames.\n     * @return {Array} An ordered list of keys.\n     */\n    __getOrderedKeys : function(keyFrames) {\n      var keys = Object.keys(keyFrames);\n      for (var i=0; i < keys.length; i++) {\n        keys[i] = parseInt(keys[i], 10);\n      };\n      keys.sort(function(a,b) {return a-b;});\n      return keys;\n    }\n  }\n});\n"
  ]
}