{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/qx-contrib-Dialog/node_modules/qxcompiler/node_modules/qooxdoo-sdk/framework/source/class/qx/bom/element/Location.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__style",
    "elem",
    "style",
    "bom",
    "element",
    "Style",
    "get",
    "COMPUTED_MODE",
    "__num",
    "parseInt",
    "__computeScroll",
    "left",
    "top",
    "win",
    "dom",
    "Node",
    "getWindow",
    "Viewport",
    "getScrollLeft",
    "getScrollTop",
    "__computeBody",
    "core",
    "Environment",
    "select",
    "doc",
    "getDocument",
    "body",
    "clientLeft",
    "documentElement",
    "clientTop",
    "offsetLeft",
    "offsetTop",
    "BoxSizing",
    "__computeOffset",
    "rect",
    "getBoundingClientRect",
    "Math",
    "round",
    "mode",
    "tagName",
    "location",
    "__getBodyLocation",
    "offset",
    "scroll",
    "elementWidth",
    "elementHeight",
    "SVGElement",
    "width",
    "height",
    "offsetWidth",
    "offsetHeight",
    "right",
    "bottom",
    "overX",
    "scrollWidth",
    "overY",
    "scrollHeight",
    "scrollLeft",
    "scrollTop",
    "getLeft",
    "getTop",
    "getRight",
    "getBottom",
    "getRelative",
    "elem1",
    "elem2",
    "mode1",
    "mode2",
    "loc1",
    "loc2",
    "getPosition",
    "getOffsetParent",
    "document",
    "offsetParent",
    "test",
    "Location"
  ],
  "mappings": "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",
  "file": "Location.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n\n   ======================================================================\n\n   This class contains code based on the following work:\n\n   * jQuery Dimension Plugin\n       http://jquery.com/\n       Version 1.1.3\n\n     Copyright:\n       (c) 2007, Paul Bakaus & Brandon Aaron\n\n     License:\n       MIT: http://www.opensource.org/licenses/mit-license.php\n\n     Authors:\n       Paul Bakaus\n       Brandon Aaron\n\n************************************************************************ */\n\n/**\n * Query the location of an arbitrary DOM element in relation to its top\n * level body element. Works in all major browsers:\n *\n * * Mozilla 1.5 + 2.0\n * * Internet Explorer 6.0 + 7.0 (both standard & quirks mode)\n * * Opera 9.2\n * * Safari 3.0 beta\n *\n * @ignore(SVGElement)\n */\nqx.Bootstrap.define(\"qx.bom.element.Location\",\n{\n  statics :\n  {\n    /**\n     * Queries a style property for the given element\n     *\n     * @param elem {Element} DOM element to query\n     * @param style {String} Style property\n     * @return {String} Value of given style property\n     */\n    __style : function(elem, style) {\n      return qx.bom.element.Style.get(elem, style, qx.bom.element.Style.COMPUTED_MODE, false);\n    },\n\n\n    /**\n     * Queries a style property for the given element and parses it to an integer value\n     *\n     * @param elem {Element} DOM element to query\n     * @param style {String} Style property\n     * @return {Integer} Value of given style property\n     */\n    __num : function(elem, style) {\n      return parseInt(qx.bom.element.Style.get(elem, style, qx.bom.element.Style.COMPUTED_MODE, false), 10) || 0;\n    },\n\n\n    /**\n     * Computes the scroll offset of the given element relative to the document\n     * <code>body</code>.\n     *\n     * @param elem {Element} DOM element to query\n     * @return {Map} Map which contains the <code>left</code> and <code>top</code> scroll offsets\n     */\n    __computeScroll : function(elem)\n    {\n      var left = 0, top = 0;\n      // Find window\n      var win = qx.dom.Node.getWindow(elem);\n\n      left -= qx.bom.Viewport.getScrollLeft(win);\n      top -= qx.bom.Viewport.getScrollTop(win);\n\n      return {\n        left : left,\n        top : top\n      };\n    },\n\n\n    /**\n     * Computes the offset of the given element relative to the document\n     * <code>body</code>.\n     *\n     * @param elem {Element} DOM element to query\n     * @return {Map} Map which contains the <code>left</code> and <code>top</code> offsets\n     */\n    __computeBody : qx.core.Environment.select(\"engine.name\",\n    {\n      \"mshtml\" : function(elem)\n      {\n        // Find body element\n        var doc = qx.dom.Node.getDocument(elem);\n        var body = doc.body;\n\n        var left = 0;\n        var top = 0;\n\n        left -= body.clientLeft + doc.documentElement.clientLeft;\n        top -= body.clientTop + doc.documentElement.clientTop;\n\n        if (!qx.core.Environment.get(\"browser.quirksmode\"))\n        {\n          left += this.__num(body, \"borderLeftWidth\");\n          top += this.__num(body, \"borderTopWidth\");\n        }\n\n        return {\n          left : left,\n          top : top\n        };\n      },\n\n      \"webkit\" : function(elem)\n      {\n        // Find body element\n        var doc = qx.dom.Node.getDocument(elem);\n        var body = doc.body;\n\n        // Start with the offset\n        var left = body.offsetLeft;\n        var top = body.offsetTop;\n\n        return {\n          left : left,\n          top : top\n        };\n      },\n\n      \"gecko\" : function(elem)\n      {\n        // Find body element\n        var body = qx.dom.Node.getDocument(elem).body;\n\n        // Start with the offset\n        var left = body.offsetLeft;\n        var top = body.offsetTop;\n\n        // Correct substracted border (only in content-box mode)\n        if (qx.bom.element.BoxSizing.get(body) !== \"border-box\")\n        {\n          left += this.__num(body, \"borderLeftWidth\");\n          top += this.__num(body, \"borderTopWidth\");\n        }\n\n        return {\n          left : left,\n          top : top\n        };\n      },\n\n\n      // At the moment only correctly supported by Opera\n      \"default\" : function(elem)\n      {\n        // Find body element\n        var body = qx.dom.Node.getDocument(elem).body;\n\n        // Start with the offset\n        var left = body.offsetLeft;\n        var top = body.offsetTop;\n\n        return {\n          left : left,\n          top : top\n        };\n      }\n    }),\n\n\n    /**\n     * Computes the sum of all offsets of the given element node.\n     *\n     * @signature function(elem)\n     * @param elem {Element} DOM element to query\n     * @return {Map} Map which contains the <code>left</code> and <code>top</code> offsets\n     */\n    __computeOffset : function(elem)\n    {\n      var rect = elem.getBoundingClientRect();\n\n      // Firefox 3.0 alpha 6 (gecko 1.9) returns floating point numbers\n      // use Math.round() to round them to style compatible numbers\n      // MSHTML returns integer numbers\n      return {\n        left : Math.round(rect.left),\n        top : Math.round(rect.top)\n      };\n    },\n\n\n    /**\n     * Computes the location of the given element in context of\n     * the document dimensions.\n     *\n     * Supported modes:\n     *\n     * * <code>margin</code>: Calculate from the margin box of the element (bigger than the visual appearance: including margins of given element)\n     * * <code>box</code>: Calculates the offset box of the element (default, uses the same size as visible)\n     * * <code>border</code>: Calculate the border box (useful to align to border edges of two elements).\n     * * <code>scroll</code>: Calculate the scroll box (relevant for absolute positioned content).\n     * * <code>padding</code>: Calculate the padding box (relevant for static/relative positioned content).\n     *\n     * @param elem {Element} DOM element to query\n     * @param mode {String?box} A supported option. See comment above.\n     * @return {Map} Returns a map with <code>left</code>, <code>top</code>,\n     *   <code>right</code> and <code>bottom</code> which contains the distance\n     *   of the element relative to the document.\n     */\n    get : function(elem, mode)\n    {\n      if (elem.tagName == \"BODY\")\n      {\n        var location = this.__getBodyLocation(elem);\n        var left = location.left;\n        var top = location.top;\n      }\n      else\n      {\n        var body = this.__computeBody(elem);\n        var offset = this.__computeOffset(elem);\n        // Reduce by viewport scrolling.\n        // Hint: getBoundingClientRect returns the location of the\n        // element in relation to the viewport which includes\n        // the scrolling\n        var scroll = this.__computeScroll(elem);\n\n        var left = offset.left + body.left - scroll.left;\n        var top = offset.top + body.top - scroll.top;\n      }\n\n      var elementWidth;\n      var elementHeight;\n      if (elem instanceof SVGElement) {\n        var rect = elem.getBoundingClientRect();\n        elementWidth = rect.width;\n        elementHeight = rect.height;\n      }\n      else {\n        elementWidth = elem.offsetWidth;\n        elementHeight = elem.offsetHeight;\n      }\n\n      var right = left + elementWidth;\n      var bottom = top + elementHeight;\n\n      if (mode)\n      {\n        // In this modes we want the size as seen from a child what means that we want the full width/height\n        // which may be higher than the outer width/height when the element has scrollbars.\n        if (mode == \"padding\" || mode == \"scroll\")\n        {\n          var overX = qx.bom.element.Style.get(elem, \"overflowX\");\n          if (overX == \"scroll\" || overX == \"auto\") {\n            right += elem.scrollWidth - elementWidth + this.__num(elem, \"borderLeftWidth\") + this.__num(elem, \"borderRightWidth\");\n          }\n\n          var overY = qx.bom.element.Style.get(elem, \"overflowY\");\n          if (overY == \"scroll\" || overY == \"auto\") {\n            bottom += elem.scrollHeight - elementHeight + this.__num(elem, \"borderTopWidth\") + this.__num(elem, \"borderBottomWidth\");\n          }\n        }\n\n        switch(mode)\n        {\n          case \"padding\":\n            left += this.__num(elem, \"paddingLeft\");\n            top += this.__num(elem, \"paddingTop\");\n            right -= this.__num(elem, \"paddingRight\");\n            bottom -= this.__num(elem, \"paddingBottom\");\n            // no break here\n\n          case \"scroll\":\n            left -= elem.scrollLeft;\n            top -= elem.scrollTop;\n            right -= elem.scrollLeft;\n            bottom -= elem.scrollTop;\n            // no break here\n\n          case \"border\":\n            left += this.__num(elem, \"borderLeftWidth\");\n            top += this.__num(elem, \"borderTopWidth\");\n            right -= this.__num(elem, \"borderRightWidth\");\n            bottom -= this.__num(elem, \"borderBottomWidth\");\n            break;\n\n          case \"margin\":\n            left -= this.__num(elem, \"marginLeft\");\n            top -= this.__num(elem, \"marginTop\");\n            right += this.__num(elem, \"marginRight\");\n            bottom += this.__num(elem, \"marginBottom\");\n            break;\n        }\n      }\n\n      return {\n        left : left,\n        top : top,\n        right : right,\n        bottom : bottom\n      };\n    },\n\n\n    /**\n     * Get the location of the body element relative to the document.\n     * @param body {Element} The body element.\n     * @return {Map} map with the keys <code>left</code> and <code>top</code>\n     */\n    __getBodyLocation : function(body)\n    {\n      var top = body.offsetTop;\n      var left = body.offsetLeft;\n\n      top += this.__num(body, \"marginTop\");\n      left += this.__num(body, \"marginLeft\");\n\n      if (qx.core.Environment.get(\"engine.name\") === \"gecko\") {\n        top += this.__num(body, \"borderLeftWidth\");\n        left +=this.__num(body, \"borderTopWidth\");\n      }\n\n      return {left: left, top: top};\n    },\n\n\n    /**\n     * Computes the location of the given element in context of\n     * the document dimensions. For supported modes please\n     * have a look at the {@link qx.bom.element.Location#get} method.\n     *\n     * @param elem {Element} DOM element to query\n     * @param mode {String} A supported option. See comment above.\n     * @return {Integer} The left distance\n     *   of the element relative to the document.\n     */\n    getLeft : function(elem, mode) {\n      return this.get(elem, mode).left;\n    },\n\n\n    /**\n     * Computes the location of the given element in context of\n     * the document dimensions. For supported modes please\n     * have a look at the {@link qx.bom.element.Location#get} method.\n     *\n     * @param elem {Element} DOM element to query\n     * @param mode {String} A supported option. See comment above.\n     * @return {Integer} The top distance\n     *   of the element relative to the document.\n     */\n    getTop : function(elem, mode) {\n      return this.get(elem, mode).top;\n    },\n\n\n    /**\n     * Computes the location of the given element in context of\n     * the document dimensions. For supported modes please\n     * have a look at the {@link qx.bom.element.Location#get} method.\n     *\n     * @param elem {Element} DOM element to query\n     * @param mode {String} A supported option. See comment above.\n     * @return {Integer} The right distance\n     *   of the element relative to the document.\n     */\n    getRight : function(elem, mode) {\n      return this.get(elem, mode).right;\n    },\n\n\n    /**\n     * Computes the location of the given element in context of\n     * the document dimensions. For supported modes please\n     * have a look at the {@link qx.bom.element.Location#get} method.\n     *\n     * @param elem {Element} DOM element to query\n     * @param mode {String} A supported option. See comment above.\n     * @return {Integer} The bottom distance\n     *   of the element relative to the document.\n     */\n    getBottom : function(elem, mode) {\n      return this.get(elem, mode).bottom;\n    },\n\n\n    /**\n     * Returns the distance between two DOM elements. For supported modes please\n     * have a look at the {@link qx.bom.element.Location#get} method.\n     *\n     * @param elem1 {Element} First element\n     * @param elem2 {Element} Second element\n     * @param mode1 {String?null} Mode for first element\n     * @param mode2 {String?null} Mode for second element\n     * @return {Map} Returns a map with <code>left</code> and <code>top</code>\n     *   which contains the distance of the elements from each other.\n     */\n    getRelative : function(elem1, elem2, mode1, mode2)\n    {\n      var loc1 = this.get(elem1, mode1);\n      var loc2 = this.get(elem2, mode2);\n\n      return {\n        left : loc1.left - loc2.left,\n        top : loc1.top - loc2.top,\n        right : loc1.right - loc2.right,\n        bottom : loc1.bottom - loc2.bottom\n      };\n    },\n\n\n    /**\n     * Returns the distance between the given element to its offset parent.\n     *\n     * @param elem {Element} DOM element to query\n     * @return {Map} Returns a map with <code>left</code> and <code>top</code>\n     *   which contains the distance of the elements from each other.\n     */\n    getPosition: function(elem) {\n      return this.getRelative(elem, this.getOffsetParent(elem));\n    },\n\n\n    /**\n     * Detects the offset parent of the given element\n     *\n     * @param element {Element} Element to query for offset parent\n     * @return {Element} Detected offset parent\n     */\n    getOffsetParent : function(element)\n    {\n      // Ther is no offsetParent for SVG elements\n      if (element instanceof SVGElement) {\n        return document.body;\n      }\n\n      var offsetParent = element.offsetParent || document.body;\n      var Style = qx.bom.element.Style;\n\n      while (offsetParent && (!/^body|html$/i.test(offsetParent.tagName) && Style.get(offsetParent, \"position\") === \"static\")) {\n        offsetParent = offsetParent.offsetParent;\n      }\n\n      return offsetParent;\n    }\n  }\n});\n"
  ]
}